<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>microGPU - EE6350 Spring 2025</title>
  <style>
    * {margin: 0; padding: 0; box-sizing: border-box;}
    
    :root {
      --primary: #1e3a5f;
      --primary-light: #2c5282;
      --accent: #5d9cec;
      --accent-light: #8ebaf5;
      --columbia-blue: #b3d9ff;
      --bg-light: #f8fafc;
      --text-dark: #1a202c;
      --text-gray: #4a5568;
      --border: #e2e8f0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background: #f7f9fc;
      color: var(--text-dark);
      line-height: 1.7;
    }
    
    /* Header with gradient and modern design */
    header {
      background: linear-gradient(135deg, #5d9cec 0%, #7db3f5 50%, #9ec9f8 100%);
      color: #ffffff;
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    /* Decorative background pattern */
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .header-content {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 40px 30px;
      text-align: center;
      z-index: 1;
    }
    
    /* Project type badge */
    .project-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.25);
      color: #ffffff;
      padding: 6px 18px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    header h1 {
      font-size: 3.2em;
      font-weight: 600;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
      color: #ffffff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    

    
    .header-meta {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .header-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .header-meta-item::before {
      content: '●';
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Author Info */
    .author-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .authors-list {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .author-name {
      font-size: 1em;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.95);
      text-decoration: none;
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
    }
    
    .author-name:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }
    
    /* Navigation - sleek and modern */
    .nav-buttons {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      border-bottom: 1px solid var(--border);
    }
    
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 40px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .nav-buttons a {
      display: inline-block;
      color: var(--text-dark);
      padding: 8px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .nav-buttons a:hover {
      color: var(--accent);
      background: var(--bg-light);
    }
    
    /* Container */
    .container {
      max-width: 1000px;
      margin: 50px auto;
      padding: 60px 50px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.06);
    }
    
    /* Back Link */
    .back {
      display: inline-flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95em;
      padding: 10px 18px;
      border-radius: 8px;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }
    
    .back:hover {
      background: var(--bg-light);
      border-color: var(--accent);
      transform: translateX(-4px);
    }
    
    .back::before {
      content: '←';
      margin-right: 8px;
      font-size: 1.3em;
      transition: transform 0.3s ease;
    }
    
    .back:hover::before {
      transform: translateX(-4px);
    }
    
    /* Sections */
    section {
      scroll-margin-top: 100px;
      margin-bottom: 70px;
      padding-bottom: 50px;
      border-bottom: 2px solid var(--bg-light);
    }
    
    section:last-of-type {
      border-bottom: none;
    }
    
    h2 {
      color: var(--primary);
      font-size: 2.2em;
      font-weight: 600;
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 50px;
      height: 3px;
      background: var(--accent);
      border-radius: 2px;
    }
    
    h3 {
      color: var(--primary-light);
      font-size: 1.5em;
      font-weight: 600;
      margin-top: 36px;
      margin-bottom: 16px;
    }
    
    .instruction-text {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-left: 4px solid #5d9cec;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 8px;
      color: #1e3a5f;
      font-size: 0.95em;
      font-style: italic;
    }
    
    p {
      color: #4a5568;
      font-size: 1.05em;
      line-height: 1.8;
      margin-bottom: 16px;
    }

    .list {
      color: #4a5568;
      font-size: 1.05em;
      line-height: 1.8;
      margin-left: 0;
      padding-left: 0;
      list-style-position: inside;
    }

    .matrix {
      display: inline-grid;
      grid-template-columns: repeat(4, 1fr);  /* 4 equal-width columns */
      column-gap: 0.75rem;
      row-gap: 0.25rem;
      padding: 4px 8px;
      border-left: 2px solid black;   /* [ */
      border-right: 2px solid black;  /* ] */
    }
    .matrix-cell {
      text-align: center;
      white-space: nowrap;  /* don't wrap your cos/sin terms */
    }
    
    /* Images */
    .image-placeholder {
      width: 100%;
      height: 400px;
      background: linear-gradient(135deg, var(--bg-light) 0%, #e2e8f0 100%);
      border-radius: 12px;
      margin: 24px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed var(--border);
      color: var(--text-light);
      font-size: 1.1em;
      font-weight: 500;
    }
    
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    /* Video */
    .video-container {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Specs Table */
    .specs-table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      background: #ffffff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    
    .specs-table th,
    .specs-table td {
      padding: 18px 24px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .specs-table th {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .specs-table tr:last-child td {
      border-bottom: none;
    }
    
    .specs-table tr:hover {
      background: var(--bg-light);
    }
    
    .specs-table td:first-child {
      font-weight: 600;
      color: var(--text-dark);
    }
    
    /* Team Grid */
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 24px;
      margin: 30px 0;
    }
    
    .team-member {
      background: linear-gradient(135deg, var(--bg-light) 0%, #edf2f7 100%);
      padding: 28px 24px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .team-member:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 28px rgba(0,0,0,0.12);
      border-color: var(--accent);
    }
    
    .team-member strong {
      color: var(--primary);
      font-size: 1.15em;
      display: block;
      margin-bottom: 8px;
    }
    
    .team-member span {
      color: var(--text-gray);
      font-size: 0.9em;
      display: block;
    }
    
    /* Footer */
    footer {
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
      color: rgba(255,255,255,0.95);
      padding: 40px 20px;
      text-align: center;
      margin-top: 80px;
    }
    
    footer p {
      color: rgba(255,255,255,0.95);
      margin-bottom: 8px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .header-content {padding: 70px 30px 50px;}
      header h1 {font-size: 2.2em;}
      .header-subtitle {font-size: 1.1em;}
      .container {padding: 40px 30px; margin: 30px 20px;}
      h2 {font-size: 1.8em;}
      .nav-container {padding: 12px 20px;}
      .nav-buttons a {font-size: 0.85em; padding: 8px 16px;}
      .image-placeholder {height: 250px; font-size: 0.95em;}
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header>
  <div class="header-content">
    <h1>microGPU</h1>
    <div class="header-meta">
      <span class="header-meta-item">EE6350 Spring 2025</span>
      <span class="header-meta-item">Columbia University</span>
      <span class="header-meta-item">TSMC 65nm</span>
    </div>
    
    <div class="author-info">
      <div class="authors-list">
        <a href="mailto:email@columbia.edu" class="author-name">[Author Name 1]</a>
        <a href="https://linkedin.com/in/username" target="_blank" class="author-name">[Author Name 2]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Author Name 3]</a>
      </div>
    </div>
  </div>
</header>

<nav class="nav-buttons">
  <div class="nav-container">
    <a href="#introduction">Introduction</a>
    <a href="#architecture">Architecture</a>
    <a href="#design-flow">Design Flow</a>
    <a href="#software">Software & Testing</a>
    <a href="#pcb">PCB Design</a>
    <a href="#demo">Demonstration</a>
    <a href="#specs">Specifications</a>
    <a href="#conclusions">Conclusions</a>
    <a href="#references">References</a>
    <a href="#acknowledgments">Acknowledgments</a>
  </div>
</nav>

<div class="container">
  <a class="back" href="../index.html">Back to all projects</a>
  
  <section id="introduction">
    <h2>Project Overview</h2>
    <p class="instruction-text">The project implements a compact 3D rendering pipepine that supports geomtry transformations, basic lighting effects, and triangle rasterizations. The chip is capable of generating 480p@60 fps VGA output and processing real-time UART input commands. Fabricated in TSMC 65 nm CMOS technology, the design represents a full end-to-end development effort, from defining the algorithms, architecture design, RTL implementation, testbench and driver development, synthesis and physiscal design to chip bring-up, PCV design and demo system integration.</p>
    <img src="../images/microgpu/02chip_TMUU65_annotated.png" alt="microGPU die photo">
  </section>
  
  <section id="architecture">
    <h2>System Architecture</h2>
    <img src="../images/microgpu/block_diagram.png" alt="microGPU block diagram">
    <p class="instruction-text">[Replace with system architecture description: Explain the overall architecture, main functional blocks, and how they interact. Include block diagrams and architectural decisions.]</p>
      <!-- TODO -->
      <h3>Rendering Engine</h3>
        <h4>Input Assembler</h4> 
		<p> The Input Assembler (IA) is the first stage of the graphics pipeline and is responsible for reliably receiving, framing, and packaging raw configuration and vertex-related data streamed over the UART interface into fixed-width packets for downstream processing. </p>
		<p> It begins by interfacing with the system’s UART receiver, which outputs each validated byte together with a strobe signal; the IA remains idle until detecting a start tag that marks the beginning of a new configuration sequence, ensuring alignment and preventing corrupted data from entering the pipeline. After this start tag, the IA enters a capture phase in which every received byte is shifted into a 48-bit register, and a 6-byte counter tracks alignment so that each group of six bytes forms one complete 48-bit packet. </p>
		<p> Every such packet is pushed into a small synchronous FIFO buffer that decouples the asynchronous UART domain from the synchronous, high-throughput graphics pipeline. The FIFO provides flow-control signals that throttle the IA when nearing capacity and allow the Vertex Shader (VS) to pull parameter packets on demand without stalling rendering. </p>
		<p> The IA is designed to handle 42 bytes per sequence, producing seven 48-bit packets typically representing transformation parameters, viewport configuration, or other pipeline control values. The VS reads these packets during VGA blanking intervals so that new configuration data does not interfere with ongoing rasterization. The IA itself performs no interpretation of packet contents; instead, its purpose is to guarantee correct byte framing, alignment, buffering, and safe delivery of structured parameter words into the pipeline, providing a clean and timing-stable interface between the external UART input stream and the internally clocked 3D graphics processing stages. </p>
        <h4>Vertex Shader</h4>
			<p> The vertex shader is responsible for the all 3D-2D vertex transformations. VS operates in the region that VGA is blank so it won't interferece with the current triangle rasterization process. It starts from the poping FIFO inside IA to read the new configuration parameters if any, and then constructs the transformation matrix using algorithms described in the Software & Testing section. After the 3D viewpoint correction matrix and overall 2D transformation matrix are constructed and stored, it will start to read loaded vertices from memory and completes the matrix-vector multiplication. To expidate the process, we instantiated 4 of the 4-pair-input fully combinational MAC, so that each 4x4 by 4x1 multiplcation can be computed in 1 cycle. The VS also includes 3 DW_div_seq modules to normalize the correct 3D vertices with respected to the W coordinate. The pipeline starts from 3D view point correction, and while it's sent to the normalization stage, the MAC modules are used by the 2D transformation. A LUT is also constructed for providing the sin function output for angles ranges from \(0-90^{\circ}\). After all the triangles are being processed and sent to memory, it asserts a valid signal to start off BF work.</p>
        <h4>Backface Culling & Lighting Module</h4> 
	        <p> Once the vertex shader asserts a valid signal, the BF block starts to iterate over all triangles. For each triangle, it first reads the three vertex indices from the triangle index buffer and then fetches the corresponding 3D vertex coordinates from the vertex buffer.
Using these three vertices, the module reconstructs two edge vectors and computes their cross product to obtain an unnormalized face normal. A signed dot product between this normal and one of the triangle’s vertices is then used to determine the triangle orientation. If the dot product is non-negative, the triangle is classified as a backface, and the module immediately marks it as invalid and writes a zero intensity without performing any further computation.
For front-facing triangles (negative dot product), the module normalizes the face normal by using DW_sqrt_seq and DW_div_seq. The lighting stage computes a simple Lambertian diffuse intensity by taking the dot product between this normalized normal and a pre-normalized light direction vector. The intensity is clamped to non-negative values and stored as a per-triangle (flat) lighting value. In parallel, a 1-bit validity flag is written for each triangle to indicate whether it survived the backface culling. After all triangles have been processed, the BF module deasserts its busy signal and raises a valid signal to notify the following pipeline stages that culling and lighting are complete.
 </p>
        <h4>Rasterizer</h4>
    <p>
  The rasterizer operates on 2D screen-space vertices and triangle indices to determine, for each pixel, which triangle is visible at that location. It first reads the triangle index and the three corresponding vertices from the 2D vertex buffer, then computes the axis-aligned bounding box of the triangle in screen coordinates. To improve throughput, the module works on tiles of
  <code>TILE_HEIGHT = 4</code> pixels in the vertical direction and scans horizontally across the screen.
</p>
    <p>
  The rasterizer scans horizontally across the triangle’s bounding box. For each column, the<code>TILE_HEIGHT</code> pixels are tested in parallel. A pixel is considered inside the triangle if all edge functions are non-positive. In parallel, a 12-bit depth test is performed; only if the incoming
  depth is smaller will the triangle ID and the depth buffer be updated.
</p>
<p>
  Depth memory is initialized once per frame. Successful hits write the triangle index and updated depth
  only to the affected pixels within the tile. This tile-based, incremental rasterization design achieves
  real-time performance and meets the 250&nbsp;MHz frequency target.
</p>

        <h4>VGA Controller</h4> <p> Yangfan Wang </p>
		  <p> The VGA controller is responsible for generating VGA related signals based on the protocol. They include the vga clk (25 MHz), vga vsync, vga_hsync, and vga_blank, which all those are used to control the DAC for monitor synchronization. Meanwhile, it outputs the current col and row that the monitor is scanning, which controls the state of all the engine blocks. Also since the core runs on 250 MHz, there will be 10 cycles for each pixel. The VGA controller asserts a signal that indicates the beginning of a new pixel and that is where the color change can occur. </p>
        <h4>Pixel Module</h4>
    <p>
  The Pixel module converts triangle IDs and lighting information into the final 24-bit VGA color. For each new pixel position <code>(x, y)</code> provided by the VGA controller, the module checks that the coordinate is within the visible 640×480 region and then reads the corresponding packed triangle index from the tile buffer. Each entry in the tile buffer stores <code>TILE_HEIGHT = 4</code> triangle IDs, so the row within the tile is selected using <code>y[1:0]</code>.
</p>
<p>
  Once the triangle index is known, the module uses it to access the per-triangle lighting value from the light-intensity memory and the base color from the color memory. A small FSM sequences the operations through four states: reading the tile buffer, reading color and light data, computing the RGB value, and periodically flushing the tile buffer when the bottom row of a tile has been scanned. During the flush phase, the entire row of tile entries is overwritten with an invalid triangle ID, so that the next frame can reuse the same on-chip memory.
</p>
<p>
  The color generation path supports several configurable shading modes, selected by
  <code>color_config_i[15:14]</code>:
</p>
<ul class="list">
  <li><b>00 – Indexed color:</b> use the 3-bit per-channel color stored in the color memory.</li>
  <li><b>01 – Indexed color × light:</b> modulate the base color by the per-triangle light value.</li>
  <li><b>10 – Solid color:</b> use a 12-bit solid RGB value encoded in <code>color_config_i</code>.</li>
  <li><b>11 – Solid color × light:</b> modulate the solid color by the lighting value.</li>
</ul>
<p>
  The intermediate results are kept in a Q9.9 fixed-point format and then truncated to 8-bit<code>R,G,B</code>. A one-stage register (<code>rgb_delay</code>) aligns the color with the<code>new_pixel</code> handshake, and the output is blanked during the VGA blanking interval. The module therefore produces a continuous 24-bit RGB stream at the VGA pixel rate while the core itself runs at 250&nbsp;MHz.
</p>

      <h3>Memory</h3>
        <h4>Memory Controller</h4>
        The below table shows the usage of our SRAMs.
        <table border="1" cellspacing="0" cellpadding="8" style="width: 100%; border-collapse: collapse;">
        <thead>
          <tr>
            <th></th>
            <th> Number </th>
            <th> Write </th>
            <th> Read </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>index_memory</td><td>1</td><td>Scan Chain</td><td>Vertex Shader</td></tr>
          <tr><td>vertex_memory</td><td>1</td><td>Scan Chain</td><td>Vertex Shader</td></tr>
          <tr><td>vertex_3d_memory</td><td>1</td><td>Vertex Shader</td><td>Backface</td></tr>
          <tr><td>vertex_2d_memory</td><td>1</td><td>Vertex Shader</td><td>Rasterizer</td></tr>
          <tr><td>light_intensity</td><td>1</td><td>Backface</td><td>Pixel Color</td></tr>
          <tr><td>tri_valid_memory</td><td>1</td><td>Backface</td><td>Rasterizer</td></tr>
          <tr><td>color_memory</td><td>1</td><td>Scan Chain</td><td>Pixel Color</td></tr>
          <tr><td>depth_buffer</td><td>1</td><td>Rasterizer</td><td>Rasterizer</td></tr>
          <tr><td>tile_buffer</td><td>2</td><td>Rasterizer</td><td>Pixel Color</td></tr>
        </tbody>
        </table>
        <p>
          An SRAM controller is needed to switch between the two tile buffers, so that when one is read from the pixel color 
          module for the output, the rasterizer can still work in parallel and write to another one. 
        </p>
        <h4>SRAM Macros</h4>
        <p>
          We generated the SRAM macros using the generator. The number of ports, size (width & words) are determined by 
          the chip functionality. The mux value changes the shape of the SRAM, and is set to fit in the chip area better. 
          We made the two buffers be able to do partial write so that it doesn't have to modify the entire line every time.
          The table shows the spec of SRAMs we used in our design. <br>
        </p>
        <style>
          table {
            border-collapse: collapse;
            width: 100%;
          }
          th, td {
            padding: 6px ; /* ← spacing inside cells */
          }
        </style>

        <table border="1">
        <thead>
          <tr>
            <th>Name</th>
            <th>Port</th>
            <th>Width</th>
            <th>Words</th>
            <th>Mux</th>
            <th>Mask</th>
            <th>WP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>index_memory</td>
            <td>sp</td>
            <td>33</td>
            <td>2368</td>
            <td>16</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>vertex_memory</td>
            <td>sp</td>
            <td>48</td>
            <td>1184</td>
            <td>8</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>vertex_3d_memory</td>
            <td>sp</td>
            <td>48</td>
            <td>1184</td>
            <td>8</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>vertex_2d_memory</td>
            <td>sp</td>
            <td>29</td>
            <td>1184</td>
            <td>8</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>light_intensity</td>
            <td>sp</td>
            <td>10</td>
            <td>2368</td>
            <td>8</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>tri_valid_memory</td>
            <td>sp</td>
            <td>2</td>
            <td>2368</td>
            <td>16</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>color_memory</td>
            <td>sp</td>
            <td>9</td>
            <td>2368</td>
            <td>8</td>
            <td>off</td>
            <td>8</td>
          </tr>
          <tr>
            <td>tile_buffer</td>
            <td>sp</td>
            <td>48</td>
            <td>640</td>
            <td>4</td>
            <td>on</td>
            <td>12</td>
          </tr>
          <tr>
            <td>depth_buffer</td>
            <td>dp</td>
            <td>48</td>
            <td>640</td>
            <td>4</td>
            <td>on</td>
            <td>12</td>
          </tr>
        </tbody>
      </table>


      <h3>System Modules</h3>
        <h4>Scan Chain</h4>
	    <p> The scan chain provides the external access point to the on-chip memories and configuration registers. 
			It is used to load model information before the processor starts, and to configure modules such as the Clock Generator and Test FSM. 
			The chain consists of 78 cells, each mapped to a specific memory identifier, address pins, data pins, control signal or register bits, and uses mem_clk to shift data without timing violations safely. 
            The memories that the scan chain can configure are Vertex Memory, Index Memory and Colour Memory.
		    The IO signals that are provided are scan_in: serially shifts data into the scan chain (write path). scan_out: serially shifts data out of the scan chain (read path).
		    scan_i0o1: selects direction: 0 = scan-in, 1 = scan-out. phi / phib: two non-overlapping clocks used to safely shift scan cells. load: loads all scan-cell latch values into the actual memory/register ports.
		</p>
        <h4>Test FSM</h4> 
		<p> This module is used to clock gate the core while external transfers data to memory through scan chain and the core is at reset state. Regarding the implementation, here are two modes: 1) Idle mode where scan chain sends data to memory or core is in the reset state 2) Normal mode where scan chain sends data to the core.</p>
        <h4>Clock Generators</h4> 
	        <p> We use this module to generate the internal clocks required by the system by configuring two parameters, fc and div. 
The fc parameter is used to control the length of the inverter chain. Each time you increase fc, you’re effectively adding another pair of inverters into the clock path, which increases the clock delay and thus slows down the clock. Additionally, the div parameter divides the clock frequency by 2^"div" .
The resulting clock frequency is divided by 1024 and output for oscilloscope measurement.
 </p>
  </section>
  
  <section id="design-flow">
    <h2>Design Flow</h2>
    <p class="instruction-text">[Replace with design flow description: Detail the steps from RTL design to tape-out, including synthesis, place-and-route, verification, and signoff processes.]</p>
    <!-- TODO: design flow pic-->
      <h3>Software Golden Model</h3>
      The project commenced from defining the relevant algorithms and implementing a reference software model. The model serves as the foundation of the project, proving the feasbility of the overall system architecture and validating the correctness of RTL designs. The key algorithms include 3D-2D transformation, backface culling and lighting intensity computation, and rasterization with actual pixel color computation. Implemented in C++, the Golden Model consists of three major components, model file processing, computation, and output storage.<br>
      The application reads three files that construct a 3D model:<br>
      <ol class="list">
        <li>Vertex List: Defines 3D coordinates for all the vertices.</li>
        <li>Surface List: Describes all the surfaces using the indeces of three vertices in the counterclockwise order.</li>
        <li>Color List: Specifies the color value for each individual triangle. (For models that have a single color, this file will be skipped)</li>
      </ol>
      <br>
      Algorithm Details:
      <ol class="list">
		<li>3D-2D Transformation</li>
        The following matrices are constructed first
		<br><br>
        Object Rotation is with respect to its center.
        <br>
        Rotation Z =
        <span class="matrix">
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( -\sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( \sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Rotation Y =
        <span class="matrix">
          <span class="matrix-cell">\( \cos(\text{rot}_y) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \sin(\text{rot}_y) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( -\sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Rotation X =
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( -\sin(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \sin(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Translation = 
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \text{trans}_x \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \text{trans}_y \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( \text{trans}_z \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Camera Rotation uses the three orthogonal vectors to defined the viewpoint diection.
        <br>
        Camera Rotation = 
        <span class="matrix">
          <span class="matrix-cell">\( \text{camera_right}_x \)</span>
          <span class="matrix-cell">\( \text{camera_right}_y \)</span>
          <span class="matrix-cell">\( \text{camera_right}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( \text{camera_up}_x \)</span>
          <span class="matrix-cell">\( \text{camera_up}_y \)</span>
          <span class="matrix-cell">\( \text{camera_up}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( -\text{camera_dir}_x \)</span>
          <span class="matrix-cell">\( -\text{camera_dir}_y \)</span>
          <span class="matrix-cell">\( -\text{camera_dir}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Camera Translation = 
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_x \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_y \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_z \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
		After the rotational and translational adjustmens are completed, the 3D-2D transformation is conducted by remapping the scene to a canonical view using a perspective projection matrix. Near plane and far plane is predefined to be 1 and 50. The bounding box \(\{r, l, t, b\}\) can be computed with a Field of View value and the display aspect ratio (640/480).
        <br>
        Perspective = 
        <span class="matrix">
          <span class="matrix-cell">\( \frac{2n}{r - l} \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \frac{2n}{t - b} \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \frac{n + f}{n - f} \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
        </span>
        <br><br>
		At the transformation stage, two sets of new coordinates will be computed. One is the 3D coordinate in the World Space with view point corrected to the origin and facing to \(-z\), which will be used for backface culling and light intensity. The other is the 2D coordinate in the Screen Space which will be consumed by the Rasterizer. To reduce repetitive computations, the above matrices will be multiplied first and the overall transformation matrix will be applied to each of the vertices.
		<br><br>
		<li>Backface Culling and Light Intensity</li>
		Norm vector for each of the sufaces are computed first by \(n = v_1 \times v_2 \quad v_1=p_1-p_0 \quad v_2=p_2-p_0\)
		<br>
		Backface is checked by \((n \cdot p_0) > 0\)
		<br>
        Light intensity is computed by first normalizing the norm vector and then perform the dot product \(n \cdot \text{light_dir}\), where the light is a directional light source and the direction is a normalized vector.
		<br><br>
		<li> Rasterization</li>
		The key process in the rasterization is to determine whether a pixel locates inside a triangle. This is done by evaluating cross products from the point with the three edges.
		<br>
        \(w_0 = (p - p_0) \times \text{edge}_0\)
		<br>
        \(w_1 = (p - p_1) \times \text{edge}_1\)
		<br>
        \(w_2 = (p - p_2) \times \text{edge}_2\)
		<br>
		A pixel is considered inside the triangle if all three edge functions have the same sign.
		<br>
		To efficiently evalutate these functions for every pixel, we precompute the partial derivatives with respect to the x and y directions. This allows us to incrementally update the edge values across the screen using only additions. Also for each triangle, we identify its bounding box first and start from the leftmost pixel for each row. 
		<br>
		Meanwhile, the rasterizer is responsible for depth check, ensuring that closer pixels are the ones being visible. A depth buffer is allocated for storing the current depth if a pixel is occupied.
	  </ol>

      <h3>Frontend Design</h3>
      The front design process focused on RTL designs and verifications. We started from using the open source project Tiniest-GPU [1] to estimate the area and timing, and shifted to design our own versions with the new architecture that supports up to 2560 vertices and 1280 triangles. As described in the system architecture, IA, VS, RA, BF and Pixel modules are implemented from scratch and VGA controller is being modified so that it oeprates correctly with 250 MHz target clock frequency. Throughout the iterations, we have encounterd several timing issues at Post-APR stage, which enforced us to revisit the RTL. These modifications included replacing square root and division modules with DW library, adding synchronization logic for the output VGA control signals and color buses and breaking long stages so that setup timing can all be met.

        <table class="specs-table">
          <tr>
            <th>Version</th>
            <th>Features</th>
          </tr>
          <tr>
            <td>0.0</td>
            <td>Tiniest-GPU 2-Triangle Baseline</td>
          </tr>
          <tr>
            <td>1.0 (Algorithm Prototyping) </td>
            <td>Parallel computations with 8 vertices and 12 triangles</td>
          </tr>
          <tr>
            <td>2.0 (Engine HW Design)</td>
            <td>Multi-cycle version with pipelines with full functionalities</td>
          </tr>
          <tr>
            <td>2.1</td>
            <td>Integration with Scan Chain</td>
          </tr>
          <tr>
            <td>2.2</td>
            <td>Integration with SRAMs</td>
          </tr>
          <tr>
            <td>2.3</td>
            <td>Integration with Clock Generator</td>
          </tr>
          <tr>
            <td>2.4</td>
            <td>Integration with Test FSM</td>
          </tr>
          <tr>
            <td>3.0 (Post-APR Changes)</td>
            <td>Replacement with DW math modules</td>
          </tr>
          <tr>
            <td>3.1</td>
            <td>Post-APR timing issue fixes</td>
          </tr>

        </table>
      <h3>Backend Design</h3>
        <h4>Automatic Place & Route</h4>
        The automatic place & route stage is where we spent most of our time due to the area limitation. <br>
        <p>
          In the initial approach, we ran place & route for each submodule, but later found that it was wasting too much 
          area since all the submodules have to be in the shape of rectangle. Thus, we ran all our code as a single module 
          and let the APR tool do optimization on the whole design. <br>
          The first step is to place the SRAM macros in the best positions. This is a very critical step since it affects the 
          the routing a lot. The SRAMs should be placed according to your chip working flow, e.g., the SRAMS that are used in 
          the same submodule/function should be put closer. Besides, it would be better to put the SRAMs on the side instead of 
          in the middle, because it minimizes the routing. <br>
          Next is to decide the position for the I/O ports to the four sides. The number of I/O ports 
          that can be put on a side is limited to the package capacity, the offsets required between each pads, 
          and the number of power and ground pads needed. Since we were running out of area, we only used three 
          sides of the chip for I/O. We decided the position of the I/O based on the chip working flow, 
          which is to put inputs on the left and outputs on the top-right and bottom-right. <br>
          Here are the several improvements we did to reduce the area and solve the timing and DRC issues.
        </p>
        <ol>
          <li> Modify the precision of calculation <br>
            SRAMs are account of more than 80% of the area of the entire design. Thus, the first improvement is to reduce the 
            precision of the numbers we stored in order to cut down on the size of SRAMs.
          </li>
          <li> Use standard library for arithmetic operation <br>
            Instead of writing division or other opearions on your own, import the function from the standard library directly, 
            which would give you better area and timing.
          </li>
          <li> Reduce the layer for power stripes <br>
            Since our design is too complex to route, we made the bottom layer of power stripes less dense and allow some routing 
            on that layer of metal. However, it might sometimes be problematic to mix the power and logical signals. 
          </li>
          <li> Add blockage or halo around SRAM cells <br>
            Routing too close to an SRAM might cause DRC errors, and it could be prevented by adding blockage or halo to stop the 
            tool from placing components there. 
          </li>
          <li> Tune the Place & Route parameters <br>
            There are several effor or density configurations you can play with to reach better performance.
          </li>
          <li> Give tighter condition in early design stage <br>
            Set the constraints, e.g., density, to lower in early design stage to allow more space for optimization in 
            the later stages. 
          </li>
        </ol>
        <p>
          We applied the same techniques on our DUT, the test FSM, scan chain, and the clock generator. 
          Below is the APR results for our modules and top. <br>
        </p>
        <h4> I/O and Power Pads Integration </h4>
        <p>
          After finishing all the submodules, we put them all together and integrated with the pads. <br> 
          Our strategy on the power pads is to equally distributed to CVDD, DVDD, VDD, and GND at first. 
          Worried about the large number of output ports we have and the large driving force we need, 
          we decided to sacrifice some of the VDD pads for CVDD and DVDD to ensure enough current on the pads.
          When it comes to the placement of the pads, in order to make sure all the I/O pads get enough 
          current, we put the power pads between sets of I/O ports. The power pads also act as the wall 
          for signals, which could probably enhance signal integrity. <br>
          Below is our final pad placement and the APR results after pad placement.
        </p>
        <h4>Sealring & Dummy</h4>
        <p>
          This part is relatively easy, where we put our top module inside the seal ring provided by the TA. 
          After placement, we exported the design and ran the dummy-filling process. 
          However, due to the limitation in the script and the filling direction, 
          our module didn't passed the DRC density test and we had to hand-place the dummies. 
          Our tips for placing the dummy is to ensure enough space around them.
        </p>
  </section>

  <section id="software">
    <h2>Software & Testing Flow</h2>
    <p class="instruction-text">For testing and demo purposes, we utilize a DE1-SOC FPGA board. The PCB and the FPGA modules are connected through the 40-pin GPIO buses.</p>
    <img src="../images/microgpu/demo_diagram.png" alt="microGPU test diagram">
      <h3>FPGA Transmitter</h3>
      As the testing flow requires a lot of data transmision from 3D obejct model files, and real-time configuration of the rendering, we built a full SoC on FPGA. One part is the ARM Cortex A9 core on the FPGA and we used it to run a Linux OS that we can communicate with the hardware through kernel modules and read USB keyboard input for our application. The other part is the FPGA fabric, which implments the transmitters.
      <br><br>
        <h4>Software</h4>
        The software consists of three parts
        <ol class="list">
            <li> Kernel Driver: The driver includes the ioctl method that the userspace application can dispatch data to the transmitter and initiate one tranmission. It also contains the kernel module configuration files so that when the Linux system boots up, this kernel module can be loaded automatically</li>
            <li> USB Driver: This is obtained from [2] which is used to handle the USB communication with the keyboard.</li>
            <li> Main Application:
                <ul>
                    <li>Starts from loading the 3D model file using methods shared across the software reference model and the testbench driver.</li>
                    <li>Completes the scan chain loading sequence using the ioctl control functions</li>
                    <li>Initializes the USB keyboard context and listens for keypress events in the main loop. After the user issues a command, it invokes corresponding UART transmitter configuration functions</li>
                </ul>
        </ol>
        <br>
        <h4>Hardware</h4>
        The complete FPGA hardware is instantiated using Altera Qsys, where the FPGA transmitters are connected with the ARM core through Avalon Bus.
        <br><br>
        There are two custom transmitters implemented by the team on the FPGA fabric, one for the Scan Chain, and the other for UART.<br>
        For the scan chain transmitter, there are 12 programmable register addresses that could be accessed by the kernel driver, which correspond to the 12 fileds in one scan chain request. There is also one register allocated for starting off the trasmission. This tranmitter toogles <i>phi</i>, <i>phib</i> and deserializes the packed scan chain word to signal <i>scan_in</i>. Overall, to complete one word transmission, it takes at least 91 cycles (12 + 78 + 1). However, as the SC_BIT_SHIFT and SC_LOAD stage need to drive signals to the GPIO and eventually to the chip through level shifters, these stages takes multiple (50) cycles for one bit change in our testing setup.
        <br>
        <img src="../images/microgpu/sc_wave.png" alt="Scan Chain Wave Form">
        <br>
        For the UART transmitter, there are 43 resigters as described in the IA module. After the write received to the address indicating a start, the UART tx will drive the signals following the protocol with 11520 bit/s baud rate which aligns with the chip rx.
        <br>
        All the FPGA hardware runs at 50 MHz.
      <h3>FPGA VGA DAC</h3>
      On the FPGA, the VGA DAC is used to translate the digital pixel values and VGA synchronization signals produced by the chip into the analog voltage levels required by standard VGA displays.
      <h3>Testing Methodology</h3>
        <h4>Pre-silicon</h4> <p> Yangfan Wang </p>
		<p> Pre-silicon verification focuses on the validation of the hardware generated outputs in RTL/Netlist simulation. The verification processes consistes of two parts: block-level testing and end-to-end testing. For each of the blocks in the engine core, the team developed correspoding testbenches and generated random data as inputs. The output is cross-checked with the C-Model result feeding the same configuration and input stimulus. For example, a series of 3D vertices will be sent to VS and we compare the transformed 2D vertices with the C-Model result. After each individual block has been verified and the top level properly constructed, we developed the end-to-end testbench. </p> 
		<br>
		<p>The testbench includes two components: </p>
		<ol class="list">
		  <li>C++ Driver: For reusability, we started with developing this driver to process model file, preparing UART config data based on input control. This part of the codes are reused in the silicon driver. For testing purposes, this driver is also responsible for constructing and saving the output frame images so that we could use it to compare with C-Model generared frames. </li>
		  <li>SystemVerilog Testbench: The testbench generates clocks for the core (for RTL sim where we don't have the clock generator), and the scan chain trasmitter logic. The testbench communicates with the the C++ driver through SystemVerilog DPI, where we imported functions so that the testbench can read new models, get commands, and accesses the memory inside the C++ driver where the 3D model and UART commands are temporarily stored.<br>
		  The testbench sequences are: <br>
		    <ul class="list">
		  	  <li> model reading with C++ initilization </li>
			  <li> scan_chain loading (as described in the scan chain section) </li>
			  <li> next set of UART commands generation </li>
			  <li> run one full frame and send all the pixel color to C memory </li>
		    </ul>
		    The steps are synchronized using the VGA vsync and hsync signals and the capturing process is using generated VGA clk from the core so we can simulate the VGA DAC requirement as much as possible. 
		  </li>
		</ol>
		<br>
		<p> The same set of testbench environment is deployed across RTL simulation, Post-Synthesis simulation with clock generator enabled, and Post-APR simulation with precise timing information. </p>
        <h4>Post-silicon</h4> <p> Yangfan Wang, Yuntian Hu </p>

  </section>

  <section id="pcb">
    <!-- TODO -->
    <h2>PCB Design</h2>
    <p class="instruction-text">[Replace with PCB design description: Detail the test board architecture, power delivery, signal integrity considerations, and measurement infrastructure.]</p>
		<p> As part of the class project, for the Demonstration, a PCB (Printed Circuit Board) had to be designed that would integrate our GPU chip as well as any devices that would communicate with it through its communication interfaces. An overview of our PCB is given below. </p>
		<img src="../images/microgpu/PCB_final.png" alt="microGPU PCB_final">
    <h3>Schematic Design</h3> 
		
		<p> The PCB has 5 main parts: the power supply, the decoupling capacitors, the level shifters, the GPU chip and the external devices. The overall PCB schematic are given below.  </p>
		<img src="../images/microgpu/top_schematic.png" alt="microGPU top_schematic">
	<h4>Power Supply</h4>
		<p> Our primary power source is power supply. The PCB requires three distinct voltage levels: 2.5V and 1V for the chip, 3.3V for FPGA. To meet these requirements, a variable LDO was chosen for the power supply. The output voltage is set by the values of the feedback resistors. Test points are incorporated to facilitate measurement of the LDO's output during testing. The schematic of the power supply is given below. </p>
		<img src="../images/microgpu/power_supply_schematic.png" alt="microGPU power_supply_schematic">

	<h4>Level Shifters</h4>
		<p> Since our peripherals mainly support 3.3V I/O voltage, level shifters have been incorporated into the chip's I/O to convert the 2.5V/1.0V I/O voltage to 3.3V, and vice versa. The schematic of the level shifters is given below. </p>
		<img src="../images/microgpu/level_shifter_schematic.png" alt="microGPU level_shifter_schematic">

	<h4>Decoupling Capacitor</h4>
		<p>  Decoupling capacitors were added to ensure a stable and clean power supply to the chip. Each power domain of the chip is equipped with a 10 ÂµF capacitor, while each input power pin is provided with a 1 ÂµF capacitor. The relevant schematic is given below. </p>
		<img src="../images/microgpu/dcap_schematic.png" alt="microGPU dcap_schematic">
	<h4>FPGA Header</h4>
		<p> This is used for the connection with the FPGA board. The relevant schematic is given below. </p>
		<img src="../images/microgpu/fpga_schematic.png" alt="microGPU fpga_schematic">
	<h4>GPU Core</h4>
		<p> This shows some connections to the GPU core. The relevant schematic is given below. </p>
		<img src="../images/microgpu/GPU_core.png" alt="microGPU GPU_core">
    <h3>Board Architecture</h3> 
	   <p class="instruction-text">[Describe PCB layout, connector pinout, external components, and interface circuits.]</p>
		<p> The PCB is organized around the central QFP-packaged renderer chip (U1), whose wide parallel data, address, and control buses are routed outward to multiple buffer/level-shifter stages (IC2–IC5), each implemented with SN74AXC8T245 bidirectional transceivers that translate between the renderer chip’s 1.8 V core I/O domain and the external connectors operating at 2.5 V or 3.3 V. 
		<p> Along the left and bottom edges, high-density headers (J2, J3, J12, J13) expose these translated signals as clean, grouped pin banks, which each bank corresponding to one 8-bit bus segment, carrying labeled signals such as qspi_data, qspi_ctrl, or general-purpose I/O channels. Every transceiver block is paired with its own decoupling capacitors and optional domain-select jumpers that supply either 3.3 V or 2.5 V to the VCCB side depending on the required logic level. </p>
		<p> On the right side, a set of TPS7A20 low-noise LDO regulators (IC6–IC9) generate isolated power rails (+3.7 V, +2.5 V, +1.0 V), each stabilized by input/output capacitors and fine-tuning resistors. The primary +5 V input enters through the screw terminal at the top left, feeding all regulated domains before distribution across the board. Additional capacitor arrays on the lower right provide dense high-frequency decoupling for the renderer chip’s analog and digital supply pins. </p>
		<p> Overall, the PCB layout is cleanly partitioned into four subsystems—renderer-chip core, voltage-translation banks, regulated supply blocks, and external breakout headers—creating a structured and noise-controlled interface board where each connector pin corresponds to a level-shifted, buffered, and properly decoupled signal from the renderer chip.
 </p>
<img src="../images/microgpu/PCB_layout.png" alt="microGPU PCB_layout">
 
    <h3>Power Distribution</h3>
    <p class="instruction-text">[Explain power supply design, voltage regulators, decoupling strategy, and current monitoring.]</p>
    <p> Our <a href="https://www.mouser.com/ProductDetail/Texas-Instruments/TPS71701DCKR?qs=QZuYiDxzHahqN0uXeRKnxg%3D%3D&utm_id=22380207736&utm_source=google&utm_medium=cpc&utm_marketing_tactic=amercorp&gad_source=1&gad_campaignid=22376567996&gbraid=0AAAAADn_wf0g5UzeCVRPp0Yhb8c27LKWG&gclid=Cj0KCQjww4TGBhCKARIsAFLXndRx8_VsZd0vdCgLvQMXXQyARwInrXAWnluTTFawSqYkY-AuB1U1ylUaAhDLEALw_wcB">LDO voltage regulator</a>]
        accepts input voltage from 2.5V to 6.5V; thus, we used 5V power supply for prototyping and 4 AA batteries for demo. 
        The voltage regulators converts the input voltage to 1V for VDD (core) and CVDD, 2.5V for DVDD, and 3.3V for level shifter to 
        align with the FPGA I/O voltage. <br>
        To ensure power stability, we added several decoupling capacitors (0.1u and 10u) for the three voltages. The decoupling capacitors 
        are used for providing the burst of current when switching, avoiding voltage drop, and filtering out noise. <br>
        To ensure power stability and signal integrity, a ground plane and a power plane are added. The power plane provides a low-impedance power path, 
        so the current can be delivered quickly and with minimal voltage drop. For the signals, the ground plane provides low-impedance return 
        path, which reduces noise and electromagnetic interference (EMI). <br>
        The entire current for our chip during the idle phase is 3 mA, and during the rendering phase is 50 mA.
    </p>

  </section>
  
  <section id="demo">
    <h2>Demonstration</h2>
    <!-- TODO -->
    <h3>Video Demonstration</h3>
    <!-- <iframe width="100%" height="400" src="https://www.youtube.com/embed/rGpk3MRSOx4?start=1" title="YouTube video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->
  </section>

  <section id="specs">
    <h2>Chip Specifications</h2>
    <p class="instruction-text">The chip is designed using TSMC 65nm technology with 2mm x 1mm die size including the core module and I/O pads. The chip is designed and tested to be operating with 250 MHz with rendering 24-bit colored 3D objects 60 frames per second. The maximum output display supported is 480p.</p>
    
    <table class="specs-table">
      <tr>
        <th>Parameter</th>
        <th>Specification</th>
      </tr>
      <tr>
        <td>Technology</td>
        <td>TSMC 65nm</td>
      </tr>
      <tr>
        <td>Die Size</td>
        <td>2mm × 1mm</td>
      </tr>
      <tr>
        <td>Chip Density (Counting Std Cells and MACROs)</td>
        <td>Top: 97.8%</br>Core: 98.5%</td>
      </tr>
      <tr>
        <td>Operating Frequency</td>
        <td>250 MHz</td>
      </tr>
      <tr>
        <td>Supply Voltage</td>
        <td>1.0V Core</br>2.5V I/O</td>
      </tr>
      <tr>
        <td>Power Consumption</td>
        <td>50 mW typical</td>
      </tr>
      <tr>
        <td>Performance Metric</td>
        <td>640x480 60fps</td>
      </tr>
      <tr>
        <td>Package</td>
        <td>CCQ100</td>
      </tr>
    </table>

  </section>

  <section id="conclusions"> <p> Yun-Rong Du </p>
    <h2>Conclusions</h2>
    <p class="instruction-text">[Replace with conclusions: Summarize achievements, lessons learned, challenges overcome, and potential future improvements.]</p>
    
    <h3>Key Achievements</h3>
    <p class="instruction-text">[List major accomplishments and successful design outcomes.]</p>
    
    <h3>Lessons Learned</h3>
    <p class="instruction-text"> 
      Breadboards are suitable only for low-frequency, non-precision circuits. In scenarios involving high-speed signals or higher currents, their parasitic capacitance/inductance and poor contact reliability can significantly
  degrade circuit performance, often causing instability or complete malfunction on the breadboard. The fact that the same design worked on the PCB in a single attempt indicates that the issues stemmed from the breadboard wiring and layout rather than from the
  circuit design itself. Even when a breadboard must be used, power quality should be ensured—for example, by using an LDO to reduce supply ripple and placing proper decoupling capacitors near key components—to minimize uncertainties introduced by the prototyping
  platform.
    </p>
    
    <h3>Future Work</h3>
    <p class="instruction-text">[Describe potential enhancements and next-generation features.]</p>
  </section>

  <section id="references">
    <!-- TODO -->
    <h2>References</h2>
    <p class="instruction-text">[Replace with references: List academic papers, technical manuals, and other resources cited in your project.]</p>
    <ol style="margin-left: 25px; color: var(--text-gray);">
      <li style="margin-bottom: 12px;">[Reference 1: Matt Pongsagon, Tiniest GPU, https://github.com/pongsagon/tt07-tiniest-gpu/tree/main, 2024]</li>
      <li style="margin-bottom: 12px;">[Reference 2: CSEE4840 by Prof. Stephen Edwards, https://www.cs.columbia.edu/~sedwards/classes/2025/4840-spring/index.html, 2025]</li>
      <li style="margin-bottom: 12px;">[Reference 3: Author, Title, Publication, Year]</li>
    </ol>
  </section>

  <section id="acknowledgments">
    <h2>Acknowledgments</h2>
    <p>
      First, we would like to express our appreciation to Apple, who sponsors 
      the course and gives us this precious oppurtunity. <br>
      Besides, we would like to thank Professor Mingoo Seok for guiding us on this project. <br>
      Thanks to the courses and professors in the EE department, 
      Advanced Logic Design by Professor Mingoo Seok, 
      VLSI Design by professor Ken Shepard, 
      Embedded System by Stephen Edwards,
      which provides us with the knowledge and skills for chip design. <br>
      Thank you TAs, Da won Kim, Mosom Jana, and Chuan-Tung Lin for the assistance on the project. 
      We are so lucky to have you answering our questions and handling the tape-out and PCB process. <br>
      Thank you Richard Lee for the help with the lab access and procurement. <br>
      Also shout out to friends and seniors who gave us useful suggestions.
      Finally, huge thanks to the 6350 classmates and teammates for sharing experience and working together. <br>
      It has been a great journey and thanks for all the people who help along the way!
    </p>
    <h3>Team Members</h3>
    <div class="team-grid">
      <div class="team-member">
        <strong>Yangfan Wang</strong>
        <span>Software Golden Model, Frontend Design, Backend Design, FPGA, Testing</span>
      </div>
      <div class="team-member">
        <strong>Yun-Rong (Alice) Du</strong>
        <span>Frontend Design, Backend Design, Testing, PCB Design, Soldering</span>
      </div>
      <div class="team-member">
        <strong>Yuntian Hu</strong>
        <span>Frontend Design, Testing</span>
      </div>
      <div class="team-member">
        <strong>Tianyun Huang</strong>
        <span>Software Golden Model, Frontend Design</span>
      </div>
      <div class="team-member">
        <strong>Zhelin Su</strong>
        <span>Frontend Design, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Yuxi Zhang</strong>
        <span>Frontend Design, Backend Design, Testing, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Fengze Zhong</strong>
        <span>Frontend Design, Testing</span>
        <span>fz2393@columbia.edu</span>
      </div>
    </div>
  </section>
  <a class="back" href="../index.html">Back to all projects</a>
</div>

<footer>
  <p>EE6350 VLSI Design Lab · Department of Electrical Engineering · Columbia University</p>
  <p style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;">Spring 2025</p>
</footer>
</body>
</html>
