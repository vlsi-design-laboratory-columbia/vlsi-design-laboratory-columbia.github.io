<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>microGPU - EE6350 Spring 2025</title>
  <style>
    * {margin: 0; padding: 0; box-sizing: border-box;}
    
    :root {
      --primary: #1e3a5f;
      --primary-light: #2c5282;
      --accent: #5d9cec;
      --accent-light: #8ebaf5;
      --columbia-blue: #b3d9ff;
      --bg-light: #f8fafc;
      --text-dark: #1a202c;
      --text-gray: #4a5568;
      --border: #e2e8f0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background: #f7f9fc;
      color: var(--text-dark);
      line-height: 1.7;
    }
    
    /* Header with gradient and modern design */
    header {
      background: linear-gradient(135deg, #5d9cec 0%, #7db3f5 50%, #9ec9f8 100%);
      color: #ffffff;
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    /* Decorative background pattern */
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .header-content {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 40px 30px;
      text-align: center;
      z-index: 1;
    }
    
    /* Project type badge */
    .project-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.25);
      color: #ffffff;
      padding: 6px 18px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    header h1 {
      font-size: 3.2em;
      font-weight: 600;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
      color: #ffffff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    

    
    .header-meta {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .header-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .header-meta-item::before {
      content: '●';
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Author Info */
    .author-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .authors-list {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .author-name {
      font-size: 1em;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.95);
      text-decoration: none;
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
    }
    
    .author-name:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }
    
    /* Navigation - sleek and modern */
    .nav-buttons {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      border-bottom: 1px solid var(--border);
    }
    
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 40px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .nav-buttons a {
      display: inline-block;
      color: var(--text-dark);
      padding: 8px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .nav-buttons a:hover {
      color: var(--accent);
      background: var(--bg-light);
    }
    
    /* Container */
    .container {
      max-width: 1000px;
      margin: 50px auto;
      padding: 60px 50px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.06);
    }
    
    /* Back Link */
    .back {
      display: inline-flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95em;
      padding: 10px 18px;
      border-radius: 8px;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }
    
    .back:hover {
      background: var(--bg-light);
      border-color: var(--accent);
      transform: translateX(-4px);
    }
    
    .back::before {
      content: '←';
      margin-right: 8px;
      font-size: 1.3em;
      transition: transform 0.3s ease;
    }
    
    .back:hover::before {
      transform: translateX(-4px);
    }
    
    /* Sections */
    section {
      scroll-margin-top: 100px;
      margin-bottom: 70px;
      padding-bottom: 50px;
      border-bottom: 2px solid var(--bg-light);
    }
    
    section:last-of-type {
      border-bottom: none;
    }
    
    h2 {
      color: var(--primary);
      font-size: 2.2em;
      font-weight: 600;
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 50px;
      height: 3px;
      background: var(--accent);
      border-radius: 2px;
    }
    
    h3 {
      color: var(--primary-light);
      font-size: 1.5em;
      font-weight: 600;
      margin-top: 36px;
      margin-bottom: 16px;
    }
    
    .instruction-text {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-left: 4px solid #5d9cec;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 8px;
      color: #1e3a5f;
      font-size: 0.95em;
      font-style: italic;
    }
    
    p {
      color: #4a5568;
      font-size: 1.05em;
      line-height: 1.8;
      margin-bottom: 16px;
    }

    .list {
        margin-left: 0;
        padding-left: 0;
        list-style-position: inside;
    }

    .matrix {
      display: inline-grid;
      grid-template-columns: repeat(4, 1fr);  /* 4 equal-width columns */
      column-gap: 0.75rem;
      row-gap: 0.25rem;
      padding: 4px 8px;
      border-left: 2px solid black;   /* [ */
      border-right: 2px solid black;  /* ] */
    }
    .matrix-cell {
      text-align: center;
      white-space: nowrap;  /* don't wrap your cos/sin terms */
    }
    
    /* Images */
    .image-placeholder {
      width: 100%;
      height: 400px;
      background: linear-gradient(135deg, var(--bg-light) 0%, #e2e8f0 100%);
      border-radius: 12px;
      margin: 24px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed var(--border);
      color: var(--text-light);
      font-size: 1.1em;
      font-weight: 500;
    }
    
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    /* Video */
    .video-container {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Specs Table */
    .specs-table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      background: #ffffff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    
    .specs-table th,
    .specs-table td {
      padding: 18px 24px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .specs-table th {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .specs-table tr:last-child td {
      border-bottom: none;
    }
    
    .specs-table tr:hover {
      background: var(--bg-light);
    }
    
    .specs-table td:first-child {
      font-weight: 600;
      color: var(--text-dark);
    }
    
    /* Team Grid */
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 24px;
      margin: 30px 0;
    }
    
    .team-member {
      background: linear-gradient(135deg, var(--bg-light) 0%, #edf2f7 100%);
      padding: 28px 24px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .team-member:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 28px rgba(0,0,0,0.12);
      border-color: var(--accent);
    }
    
    .team-member strong {
      color: var(--primary);
      font-size: 1.15em;
      display: block;
      margin-bottom: 8px;
    }
    
    .team-member span {
      color: var(--text-gray);
      font-size: 0.9em;
      display: block;
    }
    
    /* Footer */
    footer {
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
      color: rgba(255,255,255,0.95);
      padding: 40px 20px;
      text-align: center;
      margin-top: 80px;
    }
    
    footer p {
      color: rgba(255,255,255,0.95);
      margin-bottom: 8px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .header-content {padding: 70px 30px 50px;}
      header h1 {font-size: 2.2em;}
      .header-subtitle {font-size: 1.1em;}
      .container {padding: 40px 30px; margin: 30px 20px;}
      h2 {font-size: 1.8em;}
      .nav-container {padding: 12px 20px;}
      .nav-buttons a {font-size: 0.85em; padding: 8px 16px;}
      .image-placeholder {height: 250px; font-size: 0.95em;}
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header>
  <div class="header-content">
    <h1>microGPU</h1>
    <div class="header-meta">
      <span class="header-meta-item">EE6350 Spring 2025</span>
      <span class="header-meta-item">Columbia University</span>
      <span class="header-meta-item">TSMC 65nm</span>
    </div>
    
    <div class="author-info">
      <div class="authors-list">
        <a href="mailto:email@columbia.edu" class="author-name">[Author Name 1]</a>
        <a href="https://linkedin.com/in/username" target="_blank" class="author-name">[Author Name 2]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Author Name 3]</a>
      </div>
    </div>
  </div>
</header>

<nav class="nav-buttons">
  <div class="nav-container">
    <a href="#introduction">Introduction</a>
    <a href="#architecture">Architecture</a>
    <a href="#design-flow">Design Flow</a>
    <a href="#software">Software & Testing</a>
    <a href="#pcb">PCB Design</a>
    <a href="#demo">Demonstration</a>
    <a href="#specs">Specifications</a>
    <a href="#conclusions">Conclusions</a>
    <a href="#references">References</a>
    <a href="#acknowledgments">Acknowledgments</a>
  </div>
</nav>

<div class="container">
  <a class="back" href="../index.html">Back to all projects</a>
  
  <section id="introduction">
    <h2>Project Overview</h2>
    <p class="instruction-text">The project implements a compact 3D rendering pipepine that supports geomtry transformations, basic lighting effects, and triangle rasterizations. The chip is capable of generating 480p@60 fps VGA output and processing real-time UART input commands. Fabricated in TSMC 65 nm CMOS technology, the design represents a full end-to-end development effort, from defining the algorithms, architecture design, RTL implementation, testbench and driver development, synthesis and physiscal design to chip bring-up, PCV design and demo system integration.</p>
    <img src="../images/microgpu/02chip_TMUU65_annotated.png" alt="microGPU die photo">
  </section>
  
  <section id="architecture">
    <h2>System Architecture</h2>
    <img src="../images/microgpu/block_diagram.png" alt="microGPU block diagram">
    <p class="instruction-text">[Replace with system architecture description: Explain the overall architecture, main functional blocks, and how they interact. Include block diagrams and architectural decisions.]</p>
      <!-- TODO -->
      <h3>Rendering Engine</h3>
        <h4>Input Assembler</h4> <p> Zhelin Su </p>
        <h4>Vertex Shader</h4>
			<p> The vertex shader is responsible for the all 3D-2D vertex transformations. VS operates in the region that VGA is blank so it won't interferece with the current triangle rasterization process. It starts from the poping FIFO inside IA to read the new configuration parameters if any, and then constructs the transformation matrix using algorithms described in the Software & Testing section. After the 3D viewpoint correction matrix and overall 2D transformation matrix are constructed and stored, it will start to read loaded vertices from memory and completes the matrix-vector multiplication. To expidate the process, we instantiated 4 of the 4-pair-input fully combinational MAC, so that each 4x4 by 4x1 multiplcation can be computed in 1 cycle. The VS also includes 3 DW_div_seq modules to normalize the correct 3D vertices with respected to the W coordinate. The pipeline starts from 3D view point correction, and while it's sent to the normalization stage, the MAC modules are used by the 2D transformation. A LUT is also constructed for providing the sin function output for angles ranges from \(0-90^{\circ}\). After all the triangles are being processed and sent to memory, it asserts a valid signal to start off BF work.</p>
        <h4>Backface Culling & Lighting Module</h4> <p> Yuntian Hu </p>
        <h4>Rasterizer</h4> <p> Tianyun Huang </p>
        <h4>VGA Controller</h4> <p> Yangfan Wang </p>
        <h4>Pixel Module</h4> <p> Tianyun Huang </p>

      <h3>Memory</h3>
        <h4>Memory Controller</h4> <p> Yun-Rong Du </p>
        <h4>SRAM Macros</h4> <p> Yun-Rong Du </p>

      <h3>System Modules</h3>
        <h4>Scan Chain</h4> <p> Fengze Zhong </p>
        <h4>Test FSM</h4> <p> Yuxi Zhang </p>
        <h4>Clock Generators</h4> <p> Yuntian Hu </p>
  </section>
  
  <section id="design-flow">
    <h2>Design Flow</h2>
    <p class="instruction-text">[Replace with design flow description: Detail the steps from RTL design to tape-out, including synthesis, place-and-route, verification, and signoff processes.]</p>
    <!-- TODO: design flow pic-->
      <h3>Software Golden Model</h3>
      The project commenced from defining the relevant algorithms and implementing a reference software model. The model serves as the foundation of the project, proving the feasbility of the overall system architecture and validating the correctness of RTL designs. The key algorithms include 3D-2D transformation, backface culling and lighting intensity computation, and rasterization with actual pixel color computation. Implemented in C++, the Golden Model consists of three major components, model file processing, computation, and output storage.<br>
      The application reads three files that construct a 3D model:<br>
      <ol class="list">
        <li>Vertex List: Defines 3D coordinates for all the vertices.</li>
        <li>Surface List: Describes all the surfaces using the indeces of three vertices in the counterclockwise order.</li>
        <li>Color List: Specifies the color value for each individual triangle. (For models that have a single color, this file will be skipped)</li>
      </ol>
      <br>
      Algorithm Details:
      <ol class="list">
		<li>3D-2D Transformation</li>
        The following matrices are constructed first
		<br><br>
        Object Rotation is with respect to its center.
        <br>
        Rotation Z =
        <span class="matrix">
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( -\sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( \sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Rotation Y =
        <span class="matrix">
          <span class="matrix-cell">\( \cos(\text{rot}_y) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \sin(\text{rot}_y) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( -\sin(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_z) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Rotation X =
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( -\sin(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \sin(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( \cos(\text{rot}_x) \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Translation = 
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \text{trans}_x \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \text{trans}_y \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( \text{trans}_z \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Camera Rotation uses the three orthogonal vectors to defined the viewpoint diection.
        <br>
        Camera Rotation = 
        <span class="matrix">
          <span class="matrix-cell">\( \text{camera_right}_x \)</span>
          <span class="matrix-cell">\( \text{camera_right}_y \)</span>
          <span class="matrix-cell">\( \text{camera_right}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( \text{camera_up}_x \)</span>
          <span class="matrix-cell">\( \text{camera_up}_y \)</span>
          <span class="matrix-cell">\( \text{camera_up}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( -\text{camera_dir}_x \)</span>
          <span class="matrix-cell">\( -\text{camera_dir}_y \)</span>
          <span class="matrix-cell">\( -\text{camera_dir}_z \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
        Camera Translation = 
        <span class="matrix">
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_x \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_y \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
          <span class="matrix-cell">\( -\text{camera_coord}_z \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 1 \)</span>
        </span>
        <br><br>
		After the rotational and translational adjustmens are completed, the 3D-2D transformation is conducted by remapping the scene to a canonical view using a perspective projection matrix. Near plane and far plane is predefined to be 1 and 50. The bounding box \(\{r, l, t, b\}\) can be computed with a Field of View value and the display aspect ratio (640/480).
        <br>
        Perspective = 
        <span class="matrix">
          <span class="matrix-cell">\( \frac{2n}{r - l} \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \frac{2n}{t - b} \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( \frac{n + f}{n - f} \)</span>

          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
          <span class="matrix-cell">\( -1 \)</span>
          <span class="matrix-cell">\( 0 \)</span>
        </span>
        <br><br>
		At the transformation stage, two sets of new coordinates will be computed. One is the 3D coordinate in the World Space with view point corrected to the origin and facing to \(-z\), which will be used for backface culling and light intensity. The other is the 2D coordinate in the Screen Space which will be consumed by the Rasterizer. To reduce repetitive computations, the above matrices will be multiplied first and the overall transformation matrix will be applied to each of the vertices.
		<br><br>
		<li>Backface Culling and Light Intensity</li>
		Norm vector for each of the sufaces are computed first by \(n = v_1 \times v_2 \quad v_1=p_1-p_0 \quad v_2=p_2-p_0\)
		<br>
		Backface is checked by \((n \cdot p_0) > 0\)
		<br>
        Light intensity is computed by first normalizing the norm vector and then perform the dot product \(n \cdot \text{light_dir}\), where the light is a directional light source and the direction is a normalized vector.
		<br><br>
		<li> Rasterization</li>
		The key process in the rasterization is to determine whether a pixel locates inside a triangle. This is done by evaluating cross products from the point with the three edges.
		<br>
        \(w_0 = (p - p_0) \times \text{edge}_0\)
		<br>
        \(w_1 = (p - p_1) \times \text{edge}_1\)
		<br>
        \(w_2 = (p - p_2) \times \text{edge}_2\)
		<br>
		A pixel is considered inside the triangle if all three edge functions have the same sign.
		<br>
		To efficiently evalutate these functions for every pixel, we precompute the partial derivatives with respect to the x and y directions. This allows us to incrementally update the edge values across the screen using only additions. Also for each triangle, we identify its bounding box first and start from the leftmost pixel for each row. 
		<br>
		Meanwhile, the rasterizer is responsible for depth check, ensuring that closer pixels are the ones being visible. A depth buffer is allocated for storing the current depth if a pixel is occupied.
	  </ol>

      <h3>Frontend Design</h3>
      The front design process focused on RTL designs and verifications. We started from using the open source project Tiniest-GPU [1] to estimate the area and timing, and shifted to design our own versions with the new architecture that supports up to 2560 vertices and 1280 triangles. As described in the system architecture, IA, VS, RA, BF and Pixel modules are implemented from scratch and VGA controller is being modified so that it oeprates correctly with 250 MHz target clock frequency. Throughout the iterations, we have encounterd several timing issues at Post-APR stage, which enforced us to revisit the RTL. These modifications included replacing square root and division modules with DW library, adding synchronization logic for the output VGA control signals and color buses and breaking long stages so that setup timing can all be met.

        <table class="specs-table">
          <tr>
            <th>Version</th>
            <th>Features</th>
          </tr>
          <tr>
            <td>0.0</td>
            <td>Tiniest-GPU 2-Triangle Baseline</td>
          </tr>
          <tr>
            <td>1.0 (Algorithm Prototyping) </td>
            <td>Parallel computations with 8 vertices and 12 triangles</td>
          </tr>
          <tr>
            <td>2.0 (Engine HW Design)</td>
            <td>Multi-cycle version with pipelines with full functionalities</td>
          </tr>
          <tr>
            <td>2.1</td>
            <td>Integration with Scan Chain</td>
          </tr>
          <tr>
            <td>2.2</td>
            <td>Integration with SRAMs</td>
          </tr>
          <tr>
            <td>2.3</td>
            <td>Integration with Clock Generator</td>
          </tr>
          <tr>
            <td>2.4</td>
            <td>Integration with Test FSM</td>
          </tr>
          <tr>
            <td>3.0 (Post-APR Changes)</td>
            <td>Replacement with DW math modules</td>
          </tr>
          <tr>
            <td>3.1</td>
            <td>Post-APR timing issue fixes</td>
          </tr>

        </table>
      <h3>Backend Design</h3>
        <h4>Automatic Place & Route</h4> <p> Yun-Rong Du </p>
        <h4>I/O Port Integration</h4> <p> Yun-Rong Du </p>
        <h4>Sealring & Dummy</h4> <p> Yun-Rong Du </p>
  </section>

  <section id="software">
    <h2>Software & Testing Flow</h2>
    <p class="instruction-text">For testing and demo purposes, we utilize a DE1-SOC FPGA board. The PCB and the FPGA modules are connected through the 40-pin GPIO buses.</p>
    <img src="../images/microgpu/demo_diagram.png" alt="microGPU test diagram">
      <h3>FPGA Transmitter</h3>
      As the testing flow requires a lot of data transmision from 3D obejct model files, and real-time configuration of the rendering, we built a full SoC on FPGA. One part is the ARM Cortex A9 core on the FPGA and we used it to run a Linux OS that we can communicate with the hardware through kernel modules and read USB keyboard input for our application. The other part is the FPGA fabric, which implments the transmitters.
      <br><br>
        <h4>Software</h4>
        The software consists of three parts
        <ol class="list">
            <li> Kernel Driver: The driver includes the ioctl method that the userspace application can dispatch data to the transmitter and initiate one tranmission. It also contains the kernel module configuration files so that when the Linux system boots up, this kernel module can be loaded automatically</li>
            <li> USB Driver: This is obtained from [2] which is used to handle the USB communication with the keyboard.</li>
            <li> Main Application:
                <ul>
                    <li>Starts from loading the 3D model file using methods shared across the software reference model and the testbench driver.</li>
                    <li>Completes the scan chain loading sequence using the ioctl control functions</li>
                    <li>Initializes the USB keyboard context and listens for keypress events in the main loop. After the user issues a command, it invokes corresponding UART transmitter configuration functions</li>
                </ul>
        </ol>
        <br>
        <h4>Hardware</h4>
        The complete FPGA hardware is instantiated using Altera Qsys, where the FPGA transmitters are connected with the ARM core through Avalon Bus.
        <br><br>
        There are two custom transmitters implemented by the team on the FPGA fabric, one for the Scan Chain, and the other for UART.<br>
        For the scan chain transmitter, there are 12 programmable register addresses that could be accessed by the kernel driver, which correspond to the 12 fileds in one scan chain request. There is also one register allocated for starting off the trasmission. This tranmitter toogles <i>phi</i>, <i>phib</i> and deserializes the packed scan chain word to signal <i>scan_in</i>. Overall, to complete one word transmission, it takes at least 91 cycles (12 + 78 + 1). However, as the SC_BIT_SHIFT and SC_LOAD stage need to drive signals to the GPIO and eventually to the chip through level shifters, these stages takes multiple (50) cycles for one bit change in our testing setup.
        <br>
        <img src="../images/microgpu/sc_wave.png" alt="Scan Chain Wave Form">
        <br>
        For the UART transmitter, there are 43 resigters as described in the IA module. After the write received to the address indicating a start, the UART tx will drive the signals following the protocol with 11520 bit/s baud rate which aligns with the chip rx.
        <br>
        All the FPGA hardware runs at 50 MHz.
      <h3>FPGA VGA DAC</h3>
      On the FPGA, the VGA DAC is used to translate the digital pixel values and VGA synchronization signals produced by the chip into the analog voltage levels required by standard VGA displays.
      <h3>Testing Methodology</h3>
        <h4>Pre-silicon</h4> <p> Yangfan Wang </p>
        <h4>Post-silicon</h4> <p> Yangfan Wang, Yuntian Hu </p>

  </section>

  <section id="pcb">
    <!-- TODO -->
    <h2>PCB Design</h2>
    <p class="instruction-text">[Replace with PCB design description: Detail the test board architecture, power delivery, signal integrity considerations, and measurement infrastructure.]</p>
    <h3>Schematic Design</h3> <p> Yuxi Zhang </p>
    <h3>Board Architecture</h3> <p> Zhelin Zhang </p>
    <p class="instruction-text">[Describe PCB layout, connector pinout, external components, and interface circuits.]</p>
    <h3>Power Distribution</h3>
    <p class="instruction-text">[Explain power supply design, voltage regulators, decoupling strategy, and current monitoring.]</p>
    <p> Our <a href="https://www.mouser.com/ProductDetail/Texas-Instruments/TPS71701DCKR?qs=QZuYiDxzHahqN0uXeRKnxg%3D%3D&utm_id=22380207736&utm_source=google&utm_medium=cpc&utm_marketing_tactic=amercorp&gad_source=1&gad_campaignid=22376567996&gbraid=0AAAAADn_wf0g5UzeCVRPp0Yhb8c27LKWG&gclid=Cj0KCQjww4TGBhCKARIsAFLXndRx8_VsZd0vdCgLvQMXXQyARwInrXAWnluTTFawSqYkY-AuB1U1ylUaAhDLEALw_wcB">LDO voltage regulator</a>]
        accepts input voltage from 2.5V to 6.5V; thus, we used 5V power supply for prototyping and 4 AA batteries for demo. 
        The voltage regulators converts the input voltage to 1V for VDD (core) and CVDD, 2.5V for DVDD, and 3.3V for level shifter to 
        align with the FPGA I/O voltage. <br>
        To ensure power stability, we added several decoupling capacitors (0.1u and 10u) for the three voltages. The decoupling capacitors 
        are used for providing the burst of current when switching, avoiding voltage drop, and filtering out noise. <br>
        To ensure power stability and signal integrity, a ground plane and a power plane are added. The power plane provides a low-impedance power path, 
        so the current can be delivered quickly and with minimal voltage drop. For the signals, the ground plane provides low-impedance return 
        path, which reduces noise and electromagnetic interference (EMI). <br>
        The entire current for our chip during the idle phase is 3 mA, and during the rendering phase is 50 mA.
    </p>

  </section>
  
  <section id="demo">
    <h2>Demonstration</h2>
    <!-- TODO -->
    <h3>Video Demonstration</h3>
    <!-- <iframe width="100%" height="400" src="https://www.youtube.com/embed/rGpk3MRSOx4?start=1" title="YouTube video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->
  </section>

  <section id="specs">
    <h2>Chip Specifications</h2>
    <p class="instruction-text">The chip is designed using TSMC 65nm technology with 2mm x 1mm die size including the core module and I/O pads. The chip is designed and tested to be operating with 250 MHz with rendering 24-bit colored 3D objects 60 frames per second. The maximum output display supported is 480p.</p>
    
    <table class="specs-table">
      <tr>
        <th>Parameter</th>
        <th>Specification</th>
      </tr>
      <tr>
        <td>Technology</td>
        <td>TSMC 65nm</td>
      </tr>
      <tr>
        <td>Die Size</td>
        <td>2mm × 1mm</td>
      </tr>
      <tr>
        <td>Chip Density (Counting Std Cells and MACROs)</td>
        <td>Top: 97.8%</br>Core: 98.5%</td>
      </tr>
      <tr>
        <td>Operating Frequency</td>
        <td>250 MHz</td>
      </tr>
      <tr>
        <td>Supply Voltage</td>
        <td>1.0V Core</br>2.5V I/O</td>
      </tr>
      <tr>
        <td>Power Consumption</td>
        <td>50 mW typical</td>
      </tr>
      <tr>
        <td>Performance Metric</td>
        <td>640x480 60fps</td>
      </tr>
      <tr>
        <td>Package</td>
        <td>CCQ100</td>
      </tr>
    </table>

  </section>

  <section id="conclusions"> <p> Yun-Rong Du </p>
    <h2>Conclusions</h2>
    <p class="instruction-text">[Replace with conclusions: Summarize achievements, lessons learned, challenges overcome, and potential future improvements.]</p>
    
    <h3>Key Achievements</h3>
    <p class="instruction-text">[List major accomplishments and successful design outcomes.]</p>
    
    <h3>Lessons Learned</h3>
    <p class="instruction-text">[Discuss important insights gained during the design process.]</p>
    
    <h3>Future Work</h3>
    <p class="instruction-text">[Describe potential enhancements and next-generation features.]</p>
  </section>

  <section id="references">
    <!-- TODO -->
    <h2>References</h2>
    <p class="instruction-text">[Replace with references: List academic papers, technical manuals, and other resources cited in your project.]</p>
    <ol style="margin-left: 25px; color: var(--text-gray);">
      <li style="margin-bottom: 12px;">[Reference 1: Matt Pongsagon, Tiniest GPU, https://github.com/pongsagon/tt07-tiniest-gpu/tree/main, 2024]</li>
      <li style="margin-bottom: 12px;">[Reference 2: CSEE4840 by Prof. Stephen Edwards, https://www.cs.columbia.edu/~sedwards/classes/2025/4840-spring/index.html, 2025]</li>
      <li style="margin-bottom: 12px;">[Reference 3: Author, Title, Publication, Year]</li>
    </ol>
  </section>

  <section id="acknowledgments">
    <h2>Acknowledgments</h2> <p> Yun-Rong Du </p>
    <p class="instruction-text">[Replace with acknowledgments: Thank advisors, sponsors, lab staff, and others who contributed to the project.]</p>
    
    <h3>Team Members</h3>  <p> Yun-Rong Du </p>
    <div class="team-grid">
      <div class="team-member">
        <strong>Yangfan Wang</strong>
        <span>Software Golden Model, Frontend Design, Backend Design, FPGA, Testing</span>
      </div>
      <div class="team-member">
        <strong>Yun-Rong (Alice) Du</strong>
        <span>Frontend Design, Backend Design, Testing, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Yuntian Hu</strong>
        <span>Frontend Design, Testing</span>
      </div>
      <div class="team-member">
        <strong>Tianyun Huang</strong>
        <span>Software Golden Model, Frontend Design</span>
      </div>
      <div class="team-member">
        <strong>Zhelin Su</strong>
        <span>Frontend Design, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Yuxi Zhang</strong>
        <span>Frontend Design, Backend Design, Testing, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Fengze Zhong</strong>
        <span>Frontend Design</span>
      </div>
    </div>
  </section>
  <a class="back" href="../index.html">Back to all projects</a>
</div>

<footer>
  <p>EE6350 VLSI Design Lab · Department of Electrical Engineering · Columbia University</p>
  <p style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;">Spring 2025</p>
</footer>
</body>
</html>
