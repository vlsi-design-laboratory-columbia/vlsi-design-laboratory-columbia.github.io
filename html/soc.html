<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoC - EE6350 Spring 2025</title>
  <style>


    * {margin: 0; padding: 0; box-sizing: border-box;}

    /* 让容器变成弹性盒子，子元素会自动水平排列 */
.side-by-side-images {
    display: flex;
    /* 可选：设置对齐方式，比如居中 center，或者两边对齐 space-between */
    justify-content: center;
    /* 可选：设置两张图片之间的间距 */
    gap: 20px;
    /* 可选：确保垂直方向居中对齐 */
    align-items: center;
}

/* 关键：确保图片能够自适应宽度，不会超出容器 */
.side-by-side-images img {
    /* 设置最大宽度为略小于50%，给间距留点位置。
       如果希望两张图强制等宽，可以设置为 width: 48%; */
    max-width: 48%;
    /* 保持图片原始比例 */
    height: auto;
    /* 可选：加个边框方便调试看看效果 */
    /* border: 1px solid #ccc; */
}
    
    :root {
      --primary: #1e3a5f;
      --primary-light: #2c5282;
      --accent: #5d9cec;
      --accent-light: #8ebaf5;
      --columbia-blue: #b3d9ff;
      --bg-light: #f8fafc;
      --text-dark: #1a202c;
      --text-gray: #4a5568;
      --border: #e2e8f0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background: #f7f9fc;
      color: var(--text-dark);
      line-height: 1.7;
    }
    
    /* Header with gradient and modern design */
    header {
      background: linear-gradient(135deg, #5d9cec 0%, #7db3f5 50%, #9ec9f8 100%);
      color: #ffffff;
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    /* Decorative background pattern */
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .header-content {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 40px 30px;
      text-align: center;
      z-index: 1;
    }
    
    /* Project type badge */
    .project-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.25);
      color: #ffffff;
      padding: 6px 18px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    header h1 {
      font-size: 3.2em;
      font-weight: 600;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
      color: #ffffff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    

    
    .header-meta {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .header-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .header-meta-item::before {
      content: '●';
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Author Info */
    .author-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .authors-list {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .author-name {
      font-size: 1em;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.95);
      text-decoration: none;
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
    }
    
    .author-name:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }
    
    /* Navigation - sleek and modern */
    .nav-buttons {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      border-bottom: 1px solid var(--border);
    }
    
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 40px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .nav-buttons a {
      display: inline-block;
      color: var(--text-dark);
      padding: 8px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .nav-buttons a:hover {
      color: var(--accent);
      background: var(--bg-light);
    }
    
    /* Container */
    .container {
      max-width: 1000px;
      margin: 50px auto;
      padding: 60px 50px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.06);
    }
    
    /* Back Link */
    .back {
      display: inline-flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95em;
      padding: 10px 18px;
      border-radius: 8px;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }
    
    .back:hover {
      background: var(--bg-light);
      border-color: var(--accent);
      transform: translateX(-4px);
    }
    
    .back::before {
      content: '←';
      margin-right: 8px;
      font-size: 1.3em;
      transition: transform 0.3s ease;
    }
    
    .back:hover::before {
      transform: translateX(-4px);
    }
    
    /* Sections */
    section {
      scroll-margin-top: 100px;
      margin-bottom: 70px;
      padding-bottom: 50px;
      border-bottom: 2px solid var(--bg-light);
    }
    
    section:last-of-type {
      border-bottom: none;
    }
    
    h2 {
      color: var(--primary);
      font-size: 2.2em;
      font-weight: 600;
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 50px;
      height: 3px;
      background: var(--accent);
      border-radius: 2px;
    }
    
    h3 {
      color: var(--primary-light);
      font-size: 1.5em;
      font-weight: 600;
      margin-top: 36px;
      margin-bottom: 16px;
    }
    
    .instruction-text {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-left: 4px solid #5d9cec;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 8px;
      color: #1e3a5f;
      font-size: 0.95em;
      font-style: italic;
    }
    
    p {
      color: #4a5568;
      font-size: 1.05em;
      line-height: 1.8;
      margin-bottom: 16px;
    }
    
    /* Images */
    .image-placeholder {
      width: 100%;
      height: 400px;
      background: linear-gradient(135deg, var(--bg-light) 0%, #e2e8f0 100%);
      border-radius: 12px;
      margin: 24px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed var(--border);
      color: var(--text-light);
      font-size: 1.1em;
      font-weight: 500;
    }
    
    img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    /* Video */
    .video-container {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Specs Table */
    .specs-table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      background: #ffffff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    
    .specs-table th,
    .specs-table td {
      padding: 18px 24px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .specs-table th {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .specs-table tr:last-child td {
      border-bottom: none;
    }
    
    .specs-table tr:hover {
      background: var(--bg-light);
    }
    
    .specs-table td:first-child {
      font-weight: 600;
      color: var(--text-dark);
    }
    
    /* Team Grid */
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 24px;
      margin: 30px 0;
    }
    
    .team-member {
      background: linear-gradient(135deg, var(--bg-light) 0%, #edf2f7 100%);
      padding: 28px 24px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .team-member:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 28px rgba(0,0,0,0.12);
      border-color: var(--accent);
    }
    
    .team-member strong {
      color: var(--primary);
      font-size: 1.15em;
      display: block;
      margin-bottom: 8px;
    }
    
    .team-member span {
      color: var(--text-gray);
      font-size: 0.9em;
      display: block;
    }
    
    /* Footer */
    footer {
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
      color: rgba(255,255,255,0.95);
      padding: 40px 20px;
      text-align: center;
      margin-top: 80px;
    }
    
    footer p {
      color: rgba(255,255,255,0.95);
      margin-bottom: 8px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .header-content {padding: 70px 30px 50px;}
      header h1 {font-size: 2.2em;}
      .header-subtitle {font-size: 1.1em;}
      .container {padding: 40px 30px; margin: 30px 20px;}
      h2 {font-size: 1.8em;}
      .nav-container {padding: 12px 20px;}
      .nav-buttons a {font-size: 0.85em; padding: 8px 16px;}
      .image-placeholder {height: 250px; font-size: 0.95em;}
    }

/* === Fix: side-by-side images bigger + captions closer === */
.side-by-side-images figure{
  flex: 1;            /* 让每个 figure 平分宽度 */
  margin: 0;
}

.side-by-side-images figure img{
  width: 100%;        /* 图片撑满 figure */
  max-width: 100%;
  height: auto;
  margin: 0 !important;   /* 覆盖全局 img 的 24px margin */
}

.side-by-side-images figcaption{
  margin-top: 10px;
  text-align: center;
  color: #4a5568;
  font-size: 0.95em;
}

    
  </style>
</head>
<body>
<header>
  <div class="header-content">
    <h1>SoC: RISC-V with a Custom Vector Co-Processor</h1>
    <div class="header-meta">
      <span class="header-meta-item">System On Chip</span>
      <span class="header-meta-item">Vector Processing Unit</span>
      <span class="header-meta-item">RISCV</span>
      <span class="header-meta-item">TSMC 65nm</span>
    </div>
    
    <div class="author-info">
      <div class="authors-list">
        <a href="https://www.linkedin.com/in/jiajun-jiang-83764231a/" target="_blank" class="author-name">[Jiajun Jiang]</a>
        <a href="https://www.linkedin.com/in/zhenningyang509/" target="_blank" class="author-name">[Zhenning Yang]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Yicheng Huang]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Zhuohao Chang]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Yu Jia]</a>
      </div>
    </div>
  </div>
</header>

<nav class="nav-buttons">
  <div class="nav-container">
    <a href="#introduction">Introduction</a>
    <a href="#architecture">Architecture</a>
    <a href="#design-flow">Design Flow</a>
    <a href="#software">Software & Testing</a>
    <a href="#pcb">PCB Design</a>
    <a href="#demo">Demonstration</a>
    <a href="#specs">Specifications</a>
    <a href="#conclusions">Conclusions</a>
    <a href="#references">References</a>
    <a href="#acknowledgments">Acknowledgments</a>
  </div>
</nav>

<div class="container">
  <a class="back" href="../index.html">Back to all projects</a>
  
  <section id="introduction">
  <h2>Introduction</h2>

  <p class="instruction-text">
    Welcome to the SoC team page! We present a complete RISC-V System-on-Chip (SoC) implemented and
    taped out in TSMC 65-nm technology. This work was developed as part of Columbia University’s
    EE6350 VLSI Laboratory, and we gratefully acknowledge the supervision of Prof. Mingoo Seok,
    the generous support from Apple Inc., and the support of the course TAs.
    <br><br>
    The chip adopts a CPU–VPU heterogeneous architecture, integrating the open-source PicoRV32 RISC-V
    CPU and a custom-designed VPU, along with on-chip memory and essential I/O (UART, SPI), to
    accelerate data-parallel workloads such as vector operations and convolution-like kernels used in
    image processing and lightweight AI pipelines. The CPU provides system-level programmability and
    orchestration, while the VPU couples a SIMD datapath with a dedicated control plane for vector
    decode, memory sequencing, and PE scheduling. This separation enables straightforward CPU-only vs.
    VPU-offloaded benchmarking, making acceleration benefits easy to reproduce and quantify on silicon.
    <br><br>
    From RTL design and verification through synthesis, place-and-route, and pad integration, we
    completed an end-to-end ASIC flow and validated the chip via post-silicon board bring-up and
    testing. The result is a compact, software-programmable platform that demonstrates digital system
    integration and silicon-proven hardware/software co-design.
  </p>

    <img src="../images/soc/Chip_Raw_Labelled.jpg">
    <!-- <div class="image-placeholder">Insert chip photo or project overview image</div> -->
  </section>
  
  <section id="architecture">
    <h2>System Architecture</h2>
    <p class="instruction-text">This diagram illustrates the architecture of our RISC-V based System-on-Chip (SoC). At its core, a RISC-V processor is paired with a dedicated Vector Processing Unit to handle accelerated parallel computations. These processing units communicate with system resources via a central AXI-Lite Interconnect. Essential external communication is handled through UART and SPI interfaces. Additionally, the design incorporates support infrastructure, including a Clock Generator, Finite State Machine (FSM), and a Scan Chain for hardware testing and debugging.</p>
    <img src="../images/soc/SystemArch.png">
    <h3>Key Highlights: Component Breakdown</h3>
    
    <ul class="key-highlights-list">
        <li>
            <div class="highlight-item">
                <h4>Vector Processing Unit (VPU)</h4>
              <p class="instruction-text">
              This custom VPU is a PCPI-attached accelerator for PicoRV32 that delivers silicon-proven speedup on data-parallel kernels while keeping the CPU microarchitecture unchanged. It integrates a dedicated control plane (instruction decode + multi-cycle control FSM) that autonomously manages instruction sequencing, base/stride address generation, memory handshaking, and PE scheduling, so the CPU simply issues an offload and waits for completion via pcpi_wait/pcpi_ready. Vector state is maintained in small control registers (e.g., vl and vtype), from which SEW/LMUL are derived to parameterize datapath packing and memory behavior. Operands/results are stored in a 288-bit vector register file, with an unpack/pack stage feeding a 9-lane SIMD PE array for element-wise compute (e.g., vector multiply) matched to the register packing granularity. For data movement, a vector load/store subsystem converts each vector memory instruction into a tightly sequenced stream of back-to-back 32-bit DMEM transfers, moving up to nine 32-bit lanes per vector and eliminating scalar loop/address-update overhead. This hardware-sequenced, aggregated access pattern reduces per-transaction overhead and helps sustain throughput on a 32-bit, non-burst memory interface, making the design especially effective for convolution- and MAC-heavy workloads and enabling clean, reproducible CPU-only vs. CPU+VPU benchmarking under the same workload code. Across our measured demos, end-to-end speedup increases monotonically with VPU utilization (vector intensity), ranging from ~1× at low utilization up to ~6× at high utilization. As a result, the SoC is particularly well-suited for CNN-style AI kernels—where the inner loops are dominated by vectorizable multiply–accumulate (MAC) patterns and regular tensor-like memory access—so this design can be viewed as a compact, AI-oriented accelerator chip for convolutional workloads. 
              <br>
              For technical details on the VPU, reach out to Jiajun Jiang.
              </p>
                <img src="../images/soc/VPU_architecture.png">
                <!-- <p>The system's processing powerhouse consists of a standard **RISC-V Core** for general-purpose computing, paired with a high-performance **Vector Coprocessor**. This coprocessor enables efficient, accelerated execution of parallel operations, crucial for demanding applications like signal processing or machine learning tasks.</p> -->
            </div>
        </li>

<li>
            <div class="highlight-item">
                <h4>CPU Core: <a href="https://github.com/YosysHQ/picorv32" target="_blank">picorv32</a></h4>
                <p class="instruction-text">The system is anchored by the PicoRV32, a robust and widely adopted open-source 
                  RISC-V CPU core designed for high reliability and area efficiency. 
                  It implements the standard RISC-V RV32I Instruction Set Architecture (ISA), 
                  providing a comprehensive suite of base integer instructions.
                  Architecturally, the PicoRV32 is engineered with a focus on timing closure; 
                  its design minimizes logic depth in the critical path, allowing the core to 
                  achieve a high maximum operating frequency 270MHz in TSMC65nm even in area-constrained 
                  layouts. Crucially, the core features a dedicated Pico Co-Processor Interface (PCPI). 
                  This low-latency interface serves as the bridge to our custom Vector Processing Unit (VPU), 
                  allowing the PicoRV32 to seamlessly offload complex vector instructions 
                  while maintaining rigorous control over system flow and data consistency. Below Shows the Finite State Machine of this simple RISCV Core.</p>
                <img src="../images/soc/CPU.png">
                <!-- <p>The system's processing powerhouse consists of a standard **RISC-V Core** for general-purpose computing, paired with a high-performance **Vector Coprocessor**. This coprocessor enables efficient, accelerated execution of parallel operations, crucial for demanding applications like signal processing or machine learning tasks.</p> -->
            </div>
</li>
      
        <li>
            <div class="highlight-item">
                <h4>Bus Interconnect: <a href="https://github.com/alexforencich/verilog-axi/blob/master/rtl/axi_interconnect.v" target="_blank">AXI-Lite Interconnect</a></h4>
                <p class="instruction-text">The Opensource AXI-Lite Interconnect we we adopted supports multiple masters and slaves. The maximum frequency after synthesizing is around 500MHz and the area is pretty small. It does not supports burst transactions, OoO and outstanding in AXI protocol.</p>
                <section id="memory-map">
                    <h4>System Memory Map</h4>
                    <table class="specs-table">
                      <thead>
                        <tr>
                          <th>Device / Region</th>
                          <th>Start Address</th>
                          <th>End Address</th>
                          <th>Size</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td><strong>Instruction Memory (IMEM)</strong></td>
                          <td><code>0x0000_0000</code></td>
                          <td><code>0x0000_7FFF</code></td>
                          <td>32 KB (<code>0x8000</code>)</td>
                        </tr>
                        <tr>
                          <td><strong>Data Memory (DMEM)</strong></td>
                          <td><code>0x0000_8000</code></td>
                          <td><code>0x0000_FFFF</code></td>
                          <td>32 KB (<code>0x8000</code>)</td>
                        </tr>
                        <tr>
                          <td><strong>UART</strong></td>
                          <td><code>0x0010_0000</code></td>
                          <td><code>0x0010_000F</code></td>
                          <td>16 Bytes (<code>0x10</code>)</td>
                        </tr>
                        <tr>
                          <td><strong>SPI</strong></td>
                          <td><code>0x0010_0000</code></td>
                          <td><code>0x0010_00A3</code></td>
                          <td>164 Bytes (<code>0xA4</code>)</td>
                        </tr>
                      </tbody>
                    </table>
                </section>
                
                <!-- <p>All major components communicate via the **AXI-Lite Interconnect**. This streamlined version of the AMBA AXI protocol ensures reliable, low-latency communication between the core, memory, and peripherals, maintaining system coherence and data integrity.</p> -->
            </div>
        </li>
        <li>
            <div class="highlight-item">
                <h4>Memory Subsystem: IMEM & DMEM</h4>
                <p class="instruction-text">To maximize on-chip storage efficiency, the SoC integrates 64KB of SRAM, symmetrically divided into 32KB for Instruction Memory (IMEM) and 32KB for Data Memory (DMEM). We utilized the ARM Artisan Memory Compiler to generate these high-density, single-port memory macros. To ensure seamless connectivity, custom wrappers were developed to bridge the memory interface with the processor core. Furthermore, these wrappers facilitate system initialization, allowing instructions and data to be pre-loaded directly through the scan chain.</p>
                <!-- <p>The design utilizes a Harvard-like architecture with separate memories for instructions and data. It includes a dedicated **32kB Instruction Memory (IMEM)** and a **32kB Data Memory (DMEM)**. This separation minimizes contention and allows simultaneous instruction fetches and data access, boosting performance.</p> -->
            </div>
        </li>
        <li>
            <div class="highlight-item">
                <h4>I/O Peripherals: UART & SPI</h4>
                <!-- <p>External communication and interfacing are managed through standard peripherals: **UART (Universal Asynchronous Receiver/Transmitter)** provides a serial port for debugging and console access, while **SPI (Serial Peripheral Interface)** supports high-speed communication with external devices like flash memory or sensors.</p> -->
            </div>
        </li>
        <li>
            <div class="highlight-item">
                <h4>DFT Module: Scan Chain, Clock Generator, Testing FSM</h4>
    <p class="instruction-text">Our chip uses a custom, academic-level DFT infrastructure whose central element is a scan chain, together with the on-chip clock generator and the mode-control FSM. These modules are used for post-silicon functional testing, it provides the way to load data into the on-chip memories and configuration registers and to read internal state back out of the fabricated chip.</p>
    <h5>Scan Chain</h5>
    <p class="instruction-text">The scan chain contains 252 scan cells connected between the external pins scan_in and scan_out. A simplified diagram illustration as shown in Figure below, each cell corresponds to one bit of an internal signal: instruction/data memory address and data buses, as well as the configuration registers of the clock generator and the testing FSM. In normal operation the memories are driven directly by the core, but in test mode the scan chain can temporarily take over, driving or sampling these ports and even reading back the contents of the instruction and data memories to verify that the chip is operating correctly.</p>
    <img src="../images/soc/dft.png">
    <p class="instruction-text">The below Figure illustrate the internal structure of the scan cells and their connection in the chain. Regarding the scan chain operation, a control signal scan_i0o1 selects the operating mode. Internally, both the scan-in and scan-out cells contain a small input-select MUX plus two back-to-back transparent latches clocked by non-overlapping scan clocks; this two-latch structure avoids hold-time issues that are common in long shift registers. In scan-in mode, the MUX in a scan-in cell chooses between the serial input from the previous cell (to shift new data through the chain) and a feedback path that simply preserves the current value during normal execution. In scan-out mode, the corresponding MUX in a scan-out cell selects either the previous cell's serial data for shifting, or the design signal that we want to observe, such as a bit of instruction or data memory.</p>
        <div class="side-by-side-images">
        <img src="../images/soc/si.png" alt="Description of P1">
        <img src="../images/soc/so.png" alt="Description of P2">
    </div>
    <p class="instruction-text">During testing, we stream a serial bit pattern into scan_in while toggling the scan clock. After 252 shift cycles, the pattern has propagated to all cells in the chain. When scan_i0o1 is configured for scan-in and the load signal is pulsed, the contents of the scan cells are written into the connected memories and control registers: for example, a 32-bit instruction address together with its 32-bit instruction word, or new settings for the clock generator (div, fc, en_int,) and the FSM (mode and cycle count). Also, some of the scan cells provides the “virtual” memory clock imem_clk/dmem_clk, we create a memory write by first loading the desired pattern, then re-loading the same pattern with that particular bit toggled from low to high to emulate a rising edge on the memory clock.
    <br><br>
    The process of reading internal state back is symmetric. With scan_i0o1 set to scan-out mode, the memory wrappers and selected registers feed their data into the scan-out cells. After latching these values, we generate the required number of scan clock cycles to shift the 252-bit vector to the scan_out pin, where the tester observes it as a serial data stream. In this way we can verify program execution by dumping results from data memory or checking configuration registers, all using the same unified scan interface.</p>

    <h5>Clock Generator</h5>
    <p class="instruction-text">To support flexible post-silicon testing, normal operation, and control over low, high, and custom operating frequencies, our SoC includes a programmable on-chip clock generator.
    <br>
    All of its frequency control signals are loaded through the scan chain, where it can be controlled by: fc[0:4] as fine-tune to adjust the oscillator length for fine frequency steps. div[0:3] sets the digital divider ratio for coarse frequency scaling. In addition to frequency control signals, it also has a control signal from chip I/O en_int that allows it to choose between the internal generated clock path and an external clock clk_ext.
    <br>
    These controls work together to generate the system clock clk with a selectable frequency and source, giving us both a tunable internal clock and a safe external-clock fallback.</p>
    <img src="../images/soc/clk.png">

    <h5>Testing FSM</h5>
    <p class="instruction-text">For controlled post-silicon debugging we also added a small finite-state machine (FSM) that drives the clock-gating logic of the chip. The FSM supports three operating modes, all of its mode control signals are loaded through the scan chain. When the scan chain is being used to shift data in or out, the FSM sits in an idle state and completely blocks the system clock so that no internal state changes. For normal run mode, the FSM simply lets the selected clock source (internal or external) propagate to the rest of the SoC. In countdown mode, the FSM enables the clock for a programmable number of cycles and then turns it off again, allowing cycle-accurate inspection of the design.</p>

              
                <!-- <p>Essential support infrastructure ensures correct operation and testability. This includes the **Clock Generator** for timing control, a **Finite State Machine (FSM)** for managing power-on-reset and system states, and a **Scan Chain** implementation for comprehensive in-field and factory testing (Design-for-Testability).</p> -->
            </div>
        </li>
    </ul>
    
  </section>

  
  
  <section id="design-flow">
    <h2>Design Flow</h2>
    <p class="instruction-text">The following diagram outlines the complete RTL-to-GDSII design flow implemented for this project. It highlights the transition from behavioral Verilog RTL through Synthesis and Place & Route, utilizing industry-standard tools for verification at every stage.</p>
    <img src="../images/soc/Design Flow.png">
    


    <h3>RTL Design</h3>
        <p class="instruction-text">The RTL (Register Transfer Level) design serves as the core of our digital implementation, bridging the gap between high-level algorithms and physical hardware.</p>


    <h4>Hierarchical Design & Verification</h4>
    <p>
        We adopted a rigorous <strong>Bottom-Up Implementation</strong> strategy. Design work starts with coding individual, low-level <strong>submodules</strong>. Once these leaf blocks are completed, they are integrated into larger parent modules, eventually culminating in the <strong>Top-Level</strong> SoC.
    </p><p>
        Verification follows a corresponding layered approach:
    </p>
    <ul style="margin-left: 20px; margin-bottom: 20px; color: #4a5568;">
        <li><strong>Unit-Level Verification:</strong> Submodules are first verified in isolation using dedicated testbenches to ensure local correctness.</li>
        <li><strong>Integration Verification:</strong> As blocks are assembled, verification focuses on interface protocols and data flow between modules.</li>
        <li><strong>Full-Chip Verification:</strong> The complete design is simulated (using tools like <strong>ModelSim, VCS, and Verdi</strong>) and cross-compared against the C reference model to validate system-wide functionality.</li>
    </ul>

            <table class="specs-table">
          <thead>
            <tr>
              <th>Version</th>
              <th>Feature</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>0.0</strong></td>
              <td>Basic Model from PicoRV32 RISCV Core</td>
            </tr>
            <tr>
              <td><strong>0.1</strong></td>
              <td>Integrated Instruction SRAM with memory wrappers</td>
            </tr>
            <tr>
              <td><strong>0.2</strong></td>
              <td>Integrated AXI-Lite Interconnect</td>
            </tr>
            <tr>
              <td><strong>0.3</strong></td>
              <td>Integrated Data SRAM with memory wrappers</td>
            </tr>
            <tr>
              <td><strong>0.4</strong></td>
              <td>Integrated Scan Chain</td>
            </tr>
            <tr>
              <td><strong>0.5</strong></td>
              <td>Integrated UART and SPI</td>
            </tr>
            <tr>
              <td><strong>0.6</strong></td>
              <td>Integrated Vector Processing Unit</td>
            </tr>
            <tr>
              <td><strong>0.7</strong></td>
              <td>Integrated Clock Generator, Scan Chain and FSM</td>
            </tr>
            <tr>
              <td><strong>0.8</strong></td>
              <td>Modified Vector Processing Unit for Smaller Size</td>
            </tr>
            <tr>
              <td><strong>0.9</strong></td>
              <td>Integrated Pad Frame and IO Cells</td>
            </tr>
            <tr>
              <td><strong>1.0</strong></td>
              <td>Verified Functionality from Chip Level and RTL Freeze</td>
            </tr>
          </tbody>
        </table>
    <h3>Synthesis</h3>
    <p class="instruction-text">We used Synopsys Design Compiler for logic synthesis. Before running synthesis, we prepared a complete SDC file that defined all necessary constraints, including clock definitions, clock constraints, drive and load constraints, operating conditions, and wire-load models. Specifically, the SDC file included parameters such as clock name, clock period, clock uncertainty, clock transition, as well as input and output delay constraints.

Our chosen synthesis strategy followed a bottom-to-top approach. We first synthesized several major submodules independently, such as the CPU core and the VPU module. The remaining modules were synthesized together within the top-level design, while the pre-synthesized blocks were marked as don't touch to preserve their optimized structures. This process allowed us to generate the complete set of netlist files for the entire chip..</p>
    <h3>Physical Design</h3>
    <h4>Auto P&R</h4>
    <p class="instruction-text">We used Cadence Innovus for our physical design. In our place-and-route flow, the major steps included: loading design files, floorplanning, power routing, cell placement, pre-CTS optimization, clock tree synthesis (CTS), signal routing, RC parasitic extraction, filler cell insertion, design verification, and final GDS files output.

The physical hierarchy of the chip consists of submodules, the top module, the chip-level module, and the IO pads. Our place-and-route strategy followed the same bottom-up approach used during synthesis. The Dmem and Imem blocks used existing layout macros, while modules such as the SPI block, scan chain, test FSM, coprocessor, and CPU core were placed and routed independently. The remaining modules were integrated and routed within the top-level design.</p>
    <img src="../images/soc/PhysicalFlow.png">

    <p class="instruction-text">The final result is the complete chip-level layout, as shown in the figure. The two memory blocks are placed on opposite ends of the layout, while the central region contains key macros such as the CPU core and the VPU. The scan chain and clock generator are positioned toward the outer region but kept as close as possible to the center to minimize clock skew. Surrounding the entire design are the required IO pads that interface the chip with the external system..</p>
    <img src="../images/soc/chip_labelled.jpg">


    <h4>IO Pad</h4>
    <p class="instruction-text">Below shows the IO Pad integration based on LQFP64L: We have 11 + 16 + 1 = 28 IOs. And these IOs includes Input/Output Signals(SPI, UART, Scan_Chain, rst_n, clk), POC, CVDD, DVDD, VDD, VDD_TEST, GND. We tried to minimize our IO number because we need a bigger area for logic circuits.</p>
    <img src="../images/soc/IO.png">

    <h4>Package</h4>
    <p class="instruction-text">Below is the picture of our taped out chip with bonding wires and packages.</p>
    <div class="side-by-side-images">
        <img src="../images/soc/P1.png" alt="Description of P1">
        <img src="../images/soc/P2.png" alt="Description of P2">
    </div>

    <h4>STA & Sign-off</h4>
    <p class="instruction-text">During the STA phase, we used PrimeTime with a target operating frequency of 100 MHz. After place-and-route, the clock uncertainty was controlled within approximately 50 ns. According to the timing reports, all critical paths within the top module met their setup and hold time requirements, and no setup or hold violations were observed. In addition, the asynchronous reset signals passed all recovery and removal checks without violations.
    
      <img src="../images/soc/SF.png">    <br>
    
    After completing the physical design, we performed full signoff verification on each submodule and the top-level design. Using Mentor Calibre, we conducted DRC, LVS, ESD, and antenna rule checks to ensure that all results were clean. Only after passing all signoff criteria did we proceed with the final GDS files export of our chip.</p>
    <h4>PPA optimization</h4>

    <p class="instruction-text">In our chip design, we placed strong emphasis on PPA (Power, Performance, Area) optimization. Several low-power techniques were applied throughout the design stages:</p>

    <ul>
        <li>
            <strong>Fixed Voltage Domains:</strong> The chip uses fixed voltage domains, with 2.5V for IO pads and 1.0V for the core logic, ensuring stable and efficient power distribution.
        </li>
        <li>
            <strong>Clock Division:</strong> We applied clock division techniques. For example, the SPI module operates on a divided clock derived from the main clock, reducing switching activity and lowering dynamic power consumption.
        </li>
        <li>
            <strong>RTL Resource Sharing:</strong> At the RTL level, we adopted resource sharing, reusing registers and functional units whenever possible to reduce redundant hardware.
        </li>
        <li>
            <strong>State Encoding Optimizations:</strong> State encoding optimizations were applied, such as using Gray code instead of conventional binary encoding to minimize bit toggles and reduce dynamic power.
        </li>
        <li>
            <strong>Automatic Clock Gating:</strong> During synthesis, automatic clock gating was enabled to shut off clocks when modules are idle. Although this increases area slightly, it significantly reduces dynamic power consumption.
        </li>
        <li>
            <strong>High-Vth Cell Insertion:</strong> In the physical design stage, we selectively replaced LVT (Low-Vth) cells with HVT (High-Vth) cells, which reduces leakage power at the cost of some performance and area overhead.
        </li>
    </ul>

    <p class="instruction-text">These combined strategies allowed us to effectively manage power while maintaining overall performance and design efficiency.</p>
  </section>
  
<section id="software">
  <h2>Software & Testing Flow</h2>

  <p class="instruction-text">
    The software and testing flow converts C-level test programs into memory-mapped
    initialization data, generates scan sequences, and loads them onto silicon through an
    FPGA-based scan controller. This unified environment supports both pre-silicon
    verification and post-silicon validation of the CPU, memory system, and VPU.
  </p>

  <!-- Flow Diagram -->
  <div class="image-container">
    <img src="../images/soc/software_testing_flow.png"
     alt="Software Testing Flow Diagram"
     class="diagram-image">
  </div>


  <h3>Software Development</h3>
  <p>
    Test applications are written in C and compiled using a customized RISC-V GCC toolchain
    aligned with the chip's IMEM/DMEM memory map. The linker output is automatically
    converted into <code>test.h</code>, which contains the initialization arrays for
    instruction and data memory. These files form the common interface between software
    and the scan-based testing environment.
  </p>
  <p>
    The software framework allows different test programs to be executed on silicon,
    including routines that stress the CPU pipeline, memory system, or vector/AI units.
    Inline RISC-V assembly is supported for low-level testing of microarchitectural
    features.
  </p>


  <h3>Testing Methodology</h3>
  <p>
    MATLAB scripts serialize the IMEM/DMEM initialization arrays into cycle-accurate
    scan-in command sequences. These command streams are transferred to an FPGA board
    over USB, where a Vitis-based scan controller shifts data into the chip’s scan chain.
    After execution, the FPGA retrieves <code>scan_out</code> data for functional
    comparison and validation.
  </p>

</section>

    
  
  <section id="pcb">
    <h2>PCB Design</h2>
    <p class="instruction-text">We used a PCB board for our final demonstration. The PCB will help with providing power, voltage stabilization and decoupling.</p>
    
    <h3>Schematic</h3>
    <p class="instruction-text">The schematic of the PCB layouts mainly includes 3 parts: main circuits, power supply circuit and decoupling circuits.</p>
    <img src="../images/soc/schematic.png">
    <p>In the main circuits, we created the symbol for out chip. The footprint of our chip is LQPF-64 10*10mm_pin 0.5mm. Some of the pins are not used. Reset IO pins are connected to the switches, so we can control the reset signals to be VDD/GND by hand, which implement asynchronous resetting. DVDD is used for powering IO pads, and VDD is used for powering chip. The footprints of all the res and cap are 1206.The PCB support 2 modes of power supplying, which are batteries or FPGA, and can selected by a switch.</p>
    <img src="../images/soc/power.png">
    <p class="instruction-text">In the power supply circuit, the LDO is used for transferring 5V to 2.5V and 1V. The resistance and the capacitance of input/output capacitors is referred to the TI's official manual of TPS71710CDR.</p>
    <img src="../images/soc/power.png">
    <p>Decoupling circuit is designed for decoupling when supplying power. The number of the capacitors is determined by the circuit in each nets. </p>
    <p>Main circuit connects chip and other circuits. We used jumpers for debugging and left pins to connect with FPGA. After that, we used JLCPCB for manufacturing PCB board. Finally, the welding was performed manually by us.</p>
    <h3>PCB Layout</h3>
    <p class="instruction-text">Below shows the PCB Layout and PCB</p> 
        <div class="side-by-side-images">
        <img src="../images/soc/PCB_Layout.png" alt="Description of P1">
        <img src="../images/soc/PCB.png" alt="Description of P2">
    </div>


  </section>
  
  <section id="demo">
    <h2>Demonstration</h2>

  <p class="instruction-text">
    <strong>Demonstration Overview</strong><br>
  We demonstrate a <strong>silicon-proven CPU–VPU heterogeneous RISC-V SoC</strong> on fabricated silicon.
  The <strong>CPU</strong> orchestrates program control and system flow, while a custom <strong>Vector Processing Unit (VPU)</strong>
  accelerates data-parallel kernels. This platform enables <strong>direct, reproducible</strong> comparisons between
  scalar execution and vector offload under the same memory map, I/O path, and workload code structure.
</p>

  <p class="instruction-text">
    <strong>Demo Setup: PCB + FPGA Scan + MATLAB Control</strong><br>
  The chip is mounted on a custom PCB and connected to an FPGA through a level shifter.
  The FPGA handles low-level scan-in/scan-out pin toggling and basic control signals.
  A MATLAB-based host script orchestrates the full loop: it streams the program and input data into on-chip memories,
  triggers execution, then retrieves scan-out data to <strong>visualize outputs</strong> and <strong>compute performance metrics</strong>.
</p>

  <div class="instruction-text">
  <strong>Measurement Method: CPU-only vs. CPU+VPU</strong><br>
  Each workload is executed in two modes using the <strong>same inputs</strong>, <strong>same memory map</strong>, and
  <strong>identical output locations</strong>:

  <ul style="margin-left: 20px; margin-bottom: 20px; color: #4a5568;">
    <li><strong>CPU-only:</strong> scalar inner loops on PicoRV32 (no vector offload).</li>
    <li><strong>CPU+VPU:</strong> inner loops offloaded through custom PCPI vector instructions.</li>
  </ul>

  Speedup is defined as:
  <br>
  <strong>Speedup = Cycles(CPU-only) / Cycles(CPU+VPU)</strong>.
</div>

    
    <p class="instruction-text">
    <strong>Demo Flow</strong><br>
    We prepared three workloads that cover high, medium, and low VPU utilization.
    The goal is to show very clearly how VPU utilization translates into end-to-end speedup on our chip.
  </p>

  <h3>Demo 1 — CNN-style 4-Channel 3×3 Convolution</h3>
  <p class="instruction-text">
    Demo 1 is a CNN-style 4-channel 3×3 convolution. Here almost every pixel goes through two 3×3 convolutions on four feature maps,
    so the code is very MAC-heavy. In this case, the VPU is active for around <strong>80%</strong> of the total cycles,
    and we see a large speedup compared to the CPU-only baseline.
  </p>

<div class="side-by-side-images">
  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/conv_onlyCPU.png" alt="Demo1:onlyCPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo1:'CPU-only' Mode
    </figcaption>
  </figure>

  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/conv_withVPU.png" alt="Demo1:CPU+VPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo1:'CPU + VPU' Mode
    </figcaption>
  </figure>
</div>
    
<figure style="margin: 0; text-align: center;">
  <img src="../images/soc/conv_Speedup.png" alt="Demo1:Speedup">
  <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
    Demo1:End-to-end Speedup (CPU-only vs. CPU+VPU)
  </figcaption>
</figure>


    
  <h3>Demo 2 — Sobel Edge Detection (Full-frame vs. ROI-Sobel)</h3>
  <p class="instruction-text">
    Demo 2 is edge detection with Sobel filters. We show two versions: full-frame Sobel, where we run VPU convolution on every pixel,
    and ROI-Sobel, where we first do a cheap scalar pre-check and only call the VPU on high-gradient regions.
    So full-frame Sobel uses the VPU for about <strong>60%</strong> of the time, while ROI-Sobel is lower, around <strong>45%</strong>.
    This demo highlights how even with the same algorithm family, changing the amount of VPU work shifts the speedup.
  </p>

    <div class="side-by-side-images">
  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/ROISobel_onlyCPU.png" alt="Demo2 ROI:onlyCPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo2 ROI:'onlyCPU' Mode
    </figcaption>
  </figure>

  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/ROISobel_withVPU.png" alt="Demo2 ROI:CPU+VPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo2 ROI:'CPU+VPU' Mode
    </figcaption>
  </figure>
</div>
    
<figure style="margin: 0; text-align: center;">
  <img src="../images/soc/ROISobel_Speedup.png" alt="Demo2 ROI:Speedup">
  <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
    Demo2 ROI:End to end speedup (CPU-only vs. CPU+VPU)
  </figcaption>
</figure>

    <div class="side-by-side-images">
  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/Sobel_onlyCPU.png" alt="Demo2 Full-frame:onlyCPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo2 Full-frame:'onlyCPU' Mode
    </figcaption>
  </figure>

  <figure style="margin: 0; text-align: center;">
    <img src="../images/soc/Sobel_withVPU.png" alt="Demo2 Full-frame:CPU+VPU Mode">
    <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
      Demo2 Full-frame:'CPU+VPU' Mode
    </figcaption>
  </figure>
</div>
    
<figure style="margin: 0; text-align: center;">
  <img src="../images/soc/Sobel_Speedup.png" alt="Demo2 Full-frame:Speedup">
  <figcaption style="margin-top: 8px; color: #4a5568; font-size: 0.95em;">
    Demo2 Full-frame:End to end speedup (CPU-only vs. CPU+VPU)
  </figcaption>
</figure>
    
  <h3>Demo 3 — 4-Level Posterize Filter</h3>
  <p class="instruction-text">
    Demo 3 is a 4-level posterize filter. This is mostly simple per-pixel quantization with almost no vector multiply or convolution.
    Here the VPU utilization is only about <strong>5%</strong>, and as a result we see very little acceleration — sometimes even slower —
    because the PCPI and memory overhead dominate when the vector work is too light.
  </p>

  <p class="instruction-text">
    So, across these three workloads, we sweep from VPU-heavy to light, and you can directly see how higher VPU utilization gives better speedup on our architecture.
  </p>

  <h3>Results Summary</h3>
  <p class="instruction-text">
    Below summarizes our results. For the CNN-style 4-channel 3×3 convolution, the VPU is busy about <strong>80%</strong> of the time (high utilization)
    and we see roughly <strong>6×</strong> speedup. For full-frame Sobel, VPU utilization drops to about <strong>60%</strong> (medium utilization)
    and the speedup is around <strong>3×</strong>; with ROI Sobel, utilization is around <strong>45%</strong> and the speedup is about <strong>2×</strong>.
    Finally, the 4-level posterize workload only uses the VPU about <strong>5%</strong> of the time (low utilization), so the speedup is basically <strong>1×</strong> — overhead dominates.
    <br><br>
    Overall, speedup clearly scales with vector intensity: the more time we spend in VPU-friendly vector math, the more benefit we get from our custom VPU.
    This conclusion was also reached after processing a large amount of images and data.
  </p>

  <table class="specs-table">
    <thead>
      <tr>
        <th>Workload</th>
        <th>VPU Utilization</th>
        <th>Speedup</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>CNN-style 4ch 3×3 Conv</strong></td>
        <td>~80% (High)</td>
        <td>~6×</td>
      </tr>
      <tr>
        <td><strong>Sobel (Full-frame)</strong></td>
        <td>~60% (Medium)</td>
        <td>~3×</td>
      </tr>
      <tr>
        <td><strong>Sobel (ROI)</strong></td>
        <td>~45% (Medium–Low)</td>
        <td>~2×</td>
      </tr>
      <tr>
        <td><strong>Posterize (4-level)</strong></td>
        <td>~5% (Low)</td>
        <td>~1×</td>
      </tr>
    </tbody>
  </table>
    
    <div class="image-placeholder">Insert demonstration photo or screenshot</div>
    
    <h3>Video Demonstration</h3>
    <div class="video-container">
      <iframe src="https://www.youtube.com/embed/qUw_6i0oMUs" title="Project demonstration video" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
  </section>
  
  <section id="specs">
    <h2>Chip Specifications</h2>
    <p class="instruction-text">[Chip specifications and performance metrics.]</p>
    
    <table class="specs-table">
      <tr>
        <th>Parameter</th>
        <th>Specification</th>
      </tr>
      <tr>
        <td>Technology</td>
        <td>[TSMC 65nm LP]</td>
      </tr>
      <tr>
        <td>Supporting ISAs</td>
        <td>[RISCV32I and Custom Vector ISAs]</td>
      </tr>
      <tr>
        <td>Memory(SRAM)</td>
        <td>[32KB Data and 32KB Instruction]</td>
      </tr>
      <tr>
        <td>Peripherals</td>
        <td>[SPI and Uart]</td>
      </tr>
      <tr>
        <td>Programming Interface</td>
        <td>[Scan Chain]</td>
      </tr>
      <tr>
        <td>Die Size</td>
        <td>[2.0mm × 1.1mm]</td>
      </tr>
      <tr>
        <td>Gate Count</td>
        <td>[~766,000 gates]</td>
      </tr>
      <tr>
        <td>Maxinum Operating Frequency</td>
        <td>[252.52 MHz]</td>
      </tr>
      <tr>
        <td>Supply Voltage</td>
        <td>[1.0V core, 2.5V I/O]</td>
      </tr>
      <tr>
        <td>Power Consumption</td>
        <td>[13 mW typical]</td>
      </tr>
      <tr>
        <td>Performance Metric</td>
        <td>[e.g., throughput, latency]</td>
      </tr>
      <tr>
        <td>Package</td>
        <td>[QFN-64]</td>
      </tr>
    </table>
  </section>

<section id="clock-gen-table">
    <h3>Internal Clock Frequency Table</h3>
    <p class="instruction-text">[Table: Measured output frequencies corresponding to specific div and fc register configurations.]</p>
    
    <table class="specs-table">
      <thead>
        <tr>
          <th>div[0:3]</th>
          <th>fc[0:4]</th>
          <th>Frequency (Hz)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1111</td>
          <td>11111</td>
          <td>9.77k</td>
        </tr>
        <tr>
          <td>1111</td>
          <td>01010</td>
          <td>21.12k</td>
        </tr>
        <tr>
          <td>1111</td>
          <td>00101</td>
          <td>30.21k</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>01010</td>
          <td>42.33k</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>00101</td>
          <td>59.89k</td>
        </tr>
        <tr>
          <td>1101</td>
          <td>01010</td>
          <td>83.92k</td>
        </tr>
        <tr>
          <td>1101</td>
          <td>00101</td>
          <td>119.22k</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>01010</td>
          <td>167.63k</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>00101</td>
          <td>237.11k</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>01010</td>
          <td>333.46k</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>00101</td>
          <td>471.12k</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>01010</td>
          <td>665.49k</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>00101</td>
          <td>943.08k</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>01010</td>
          <td>1.32M</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>00101</td>
          <td>1.89M</td>
        </tr>
        <tr>
          <td>1000</td>
          <td>01010</td>
          <td>2.64M</td>
        </tr>
        <tr>
          <td>1000</td>
          <td>00101</td>
          <td>3.80M</td>
        </tr>
        <tr>
          <td>0111</td>
          <td>01010</td>
          <td>5.29M</td>
        </tr>
        <tr>
          <td>0111</td>
          <td>00101</td>
          <td>7.55M</td>
        </tr>
        <tr>
          <td>0110</td>
          <td>01010</td>
          <td>10.64M</td>
        </tr>
        <tr>
          <td>0110</td>
          <td>00101</td>
          <td>15.09M</td>
        </tr>
        <tr>
          <td>0101</td>
          <td>01010</td>
          <td>21.67M</td>
        </tr>
        <tr>
          <td>0101</td>
          <td>00101</td>
          <td>31.21M</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>01010</td>
          <td>44.50M</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>00101</td>
          <td>64.12M</td>
        </tr>
        <tr>
          <td>0011</td>
          <td>01010</td>
          <td>90.78M</td>
        </tr>
        <tr>
          <td>0011</td>
          <td>00101</td>
          <td>118.57M</td>
        </tr>
        <tr>
          <td>0010</td>
          <td>01010</td>
          <td>178.23M</td>
        </tr>
        <tr>
          <td>0010</td>
          <td>00101</td>
          <td>252.52M</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>01010</td>
          <td>349.75M</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>00101</td>
          <td>493.33M</td>
        </tr>
        <tr>
          <td>0000</td>
          <td>01010</td>
          <td>680.21M</td>
        </tr>
        <tr>
          <td>0000</td>
          <td>00101</td>
          <td>950.88M</td>
        </tr>
        <tr>
          <td>0000</td>
          <td>00000</td>
          <td>1.52G</td>
        </tr>
      </tbody>
    </table>
</section>
  
  
  <section id="conclusions">
    <h2>Conclusions</h2>
    <p class="instruction-text">[Replace with conclusions: Summarize achievements, lessons learned, challenges overcome, and potential future improvements.]</p>
    
    <h3>Key Achievements</h3>
    <p class="instruction-text">[List major accomplishments and successful design outcomes.]</p>
    
    <h3>Lessons Learned</h3>
    <p class="instruction-text">[Discuss important insights gained during the design process.]</p>
    
    <h3>Future Work</h3>
    <p class="instruction-text">[Describe potential enhancements and next-generation features.]</p>
  </section>
  
  <section id="references">
    <h2>References</h2>
    <p class="instruction-text">[Replace with references: List academic papers, technical manuals, and other resources cited in your project.]</p>
    <ol style="margin-left: 25px; color: var(--text-gray);">
      <li style="margin-bottom: 12px;">[Reference 1: Author, Title, Publication, Year]</li>
      <li style="margin-bottom: 12px;">[Reference 2: Author, Title, Publication, Year]</li>
      <li style="margin-bottom: 12px;">[Reference 3: Author, Title, Publication, Year]</li>
    </ol>
  </section>
  
  <section id="acknowledgments">
    <h2>Acknowledgments</h2>
    <p class="instruction-text">[Replace with acknowledgments: Thank advisors, sponsors, lab staff, and others who contributed to the project.]</p>
    
    <h3>Team Members</h3>
    <div class="team-grid">
      <div class="team-member">
        <strong>Jiajun Jiang</strong>
        <span>VPU Development, Frontend Design, Software Testing, Post-silicon Testing</span>
      </div>
      <div class="team-member">
        <strong>Zhenning Yang</strong>
        <span>Frontend Design, Backend Design, Soldering</span>
      </div>
      <div class="team-member">
        <strong>Yicheng Huang</strong>
        <span>Frontend Design, Backend Design, PCB Design</span>
      </div>
      <div class="team-member">
        <strong>Zhuohao Chang</strong>
        <span>Frontend Design, DFT</span>
      </div>
      <div class="team-member">
        <strong>Yu Jia</strong>
        <span>Frontend Design, Software Testing</span>
      </div>
    </div>
  </section>
  
  <a class="back" href="../index.html">Back to all projects</a>
</div>

<footer>
  <p>EE6350 VLSI Design Lab · Department of Electrical Engineering · Columbia University</p>
  <p style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;">Spring 2025</p>
</footer>
</body>
</html>
