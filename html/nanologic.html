<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NanoLogic - EE6350 Spring 2025</title>
  <style>
    * {margin: 0; padding: 0; box-sizing: border-box;}
    
    :root {
      --primary: #1e3a5f;
      --primary-light: #2c5282;
      --accent: #5d9cec;
      --accent-light: #8ebaf5;
      --columbia-blue: #b3d9ff;
      --bg-light: #f8fafc;
      --text-dark: #1a202c;
      --text-gray: #4a5568;
      --border: #e2e8f0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background: #f7f9fc;
      color: var(--text-dark);
      line-height: 1.7;
    }
    
    /* Header with gradient and modern design */
    header {
      background: linear-gradient(135deg, #5d9cec 0%, #7db3f5 50%, #9ec9f8 100%);
      color: #ffffff;
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    /* Decorative background pattern */
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .header-content {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 40px 30px;
      text-align: center;
      z-index: 1;
    }
    
    /* Project type badge */
    .project-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.25);
      color: #ffffff;
      padding: 6px 18px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    header h1 {
      font-size: 3.2em;
      font-weight: 600;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
      color: #ffffff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    

    
    .header-meta {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .header-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .header-meta-item::before {
      content: '●';
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Author Info */
    .author-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .authors-list {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .author-name {
      font-size: 1em;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.95);
      text-decoration: none;
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
    }
    
    .author-name:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }
    
    /* Navigation - sleek and modern */
    .nav-buttons {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      padding: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      border-bottom: 1px solid var(--border);
    }
    
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 40px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .nav-buttons a {
      display: inline-block;
      color: var(--text-dark);
      padding: 8px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .nav-buttons a:hover {
      color: var(--accent);
      background: var(--bg-light);
    }
    
    /* Container */
    .container {
      max-width: 1000px;
      margin: 50px auto;
      padding: 60px 50px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.06);
    }
    
    /* Back Link */
    .back {
      display: inline-flex;
      align-items: center;
      margin-bottom: 40px;
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95em;
      padding: 10px 18px;
      border-radius: 8px;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }
    
    .back:hover {
      background: var(--bg-light);
      border-color: var(--accent);
      transform: translateX(-4px);
    }
    
    .back::before {
      content: '←';
      margin-right: 8px;
      font-size: 1.3em;
      transition: transform 0.3s ease;
    }
    
    .back:hover::before {
      transform: translateX(-4px);
    }
    
    /* Sections */
    section {
      scroll-margin-top: 100px;
      margin-bottom: 70px;
      padding-bottom: 50px;
      border-bottom: 2px solid var(--bg-light);
    }
    
    section:last-of-type {
      border-bottom: none;
    }
    
    h2 {
      color: var(--primary);
      font-size: 2.2em;
      font-weight: 600;
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }
    
    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 50px;
      height: 3px;
      background: var(--accent);
      border-radius: 2px;
    }
    
    h3 {
      color: var(--primary-light);
      font-size: 1.5em;
      font-weight: 600;
      margin-top: 36px;
      margin-bottom: 16px;
    }
    
    .instruction-text {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-left: 4px solid #5d9cec;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 8px;
      color: #1e3a5f;
      font-size: 0.95em;
      font-style: italic;
    }
    
    p {
      color: #4a5568;
      font-size: 1.05em;
      line-height: 1.8;
      margin-bottom: 16px;
    }
    
    /* Images */
    .image-placeholder {
      width: 100%;
      height: 400px;
      background: linear-gradient(135deg, var(--bg-light) 0%, #e2e8f0 100%);
      border-radius: 12px;
      margin: 24px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed var(--border);
      color: var(--text-light);
      font-size: 1.1em;
      font-weight: 500;
    }
    
    img {
      max-width: 100%;
      max-height: 100%;
      height: auto;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }

    .caption {
      text-align: center;
      font-size: 0.9em;
      color: var(--text-gray);
      margin-top: -10px;
    }



h4 {
  font-size: 1.3em;
  font-weight: 600;
  color: var(--primary-light);
  margin-top: 32px;
  margin-bottom: 20px;
  padding-left: 12px;
  border-left: 4px solid var(--primary-light);
  position: relative;
  letter-spacing: 0.3px;
}





    
    /* Video */
    .video-container {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      border: 1px solid var(--border);
    }
    
    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Specs Table */
    .specs-table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      background: #ffffff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    
    .specs-table th,
    .specs-table td {
      padding: 18px 24px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .specs-table th {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      font-weight: 600;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .specs-table tr:last-child td {
      border-bottom: none;
    }
    
    .specs-table tr:hover {
      background: var(--bg-light);
    }
    
    .specs-table td:first-child {
      font-weight: 600;
      color: var(--text-dark);
    }
      /* Collapsible code blocks */
    details.code-block {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #0b1220;
      color: #e2e8f0;
      margin: 20px 0;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      overflow: hidden;
    }

    details.code-block summary {
      cursor: pointer;
      padding: 14px 16px;
      font-weight: 600;
      color: var(--primary);
      background: linear-gradient(135deg, #eef2ff 0%, #e2e8f0 100%);
      border-bottom: 1px solid var(--border);
      list-style: none;
    }

    details.code-block summary::-webkit-details-marker {
      display: none;
    }

    details.code-block .code-content {
      background: #0b1220;
      color: #e2e8f0;
      padding: 16px;
      overflow-x: auto;
    }

    .code-content pre {
      margin: 0;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.9em;
      line-height: 1.6;
      white-space: pre;
    }


    /*bullet points*/
    ul {
    margin: 2px 0 2px 0;
    padding-left: 24px;
    color: #4a5568;
    line-height: 1.8;
    font-size: 1.05em;
    }



    /* Team Grid */
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 24px;
      margin: 30px 0;
    }
    
    .team-member {
      background: linear-gradient(135deg, var(--bg-light) 0%, #edf2f7 100%);
      padding: 28px 24px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .team-member:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 28px rgba(0,0,0,0.12);
      border-color: var(--accent);
    }
    
    .team-member strong {
      color: var(--primary);
      font-size: 1.15em;
      display: block;
      margin-bottom: 8px;
    }
    
    .team-member span {
      color: var(--text-gray);
      font-size: 0.9em;
      display: block;
    }

    /* Team member link styling */
    .team-member a {
      color: var(--primary); 
      text-decoration: none; 
      font-weight: 600;
    }

    .team-member a:visited {
      color: var(--primary);
    }

    .team-member a:hover {
      text-decoration: underline;
    }
    
    /* Footer */
    footer {
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
      color: rgba(255,255,255,0.95);
      padding: 40px 20px;
      text-align: center;
      margin-top: 80px;
    }
    
    footer p {
      color: rgba(255,255,255,0.95);
      margin-bottom: 8px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .header-content {padding: 70px 30px 50px;}
      header h1 {font-size: 2.2em;}
      .header-subtitle {font-size: 1.1em;}
      .container {padding: 40px 30px; margin: 30px 20px;}
      h2 {font-size: 1.8em;}
      .nav-container {padding: 12px 20px;}
      .nav-buttons a {font-size: 0.85em; padding: 8px 16px;}
      .image-placeholder {height: 250px; font-size: 0.95em;}
    }
  </style>
</head>
<body>
<header>
  <div class="header-content">
    <h1>NanoLogic</h1>
    <div class="header-meta">
      <span class="header-meta-item">EE6350 Spring 2025</span>
      <span class="header-meta-item">Columbia University</span>
      <span class="header-meta-item">TSMC 65nm</span>
    </div>
    
    <div class="author-info">
      <div class="authors-list">
        <a href="https://www.linkedin.com/in/qianxufu/" class="author-name">Qianxu Fu (Tiffany Fu)</a>
        <a href="https://linkedin.com/in/username" target="_blank" class="author-name">[Author Name 2]</a>
        <a href="mailto:email@columbia.edu" class="author-name">[Author Name 3]</a>
      </div>
    </div>
  </div>
</header>

<nav class="nav-buttons">
  <div class="nav-container">
    <a href="#introduction">Introduction</a>
    <a href="#architecture">Architecture</a>
    <a href="#design-flow">Design Flow</a>
    <a href="#software">Software & Testing</a>
    <a href="#pcb">PCB Design</a>
    <a href="#demo">Demonstration</a>
    <a href="#specs">Specifications</a>
    <a href="#conclusions">Conclusions</a>
    <a href="#references">References</a>
    <a href="#acknowledgments">Acknowledgments</a>
  </div>
</nav>

<div class="container">
  <a class="back" href="../index.html">Back to all projects</a>
  
  <section id="introduction">
    <h2>Introduction</h2>
    <p class="instruction-text">Our project is a fully integrated RISC-V based SoC chip fabricated in TSMC 65 nm CMOS technology. The system is built around the OpenHW Group’s CORE-V CV32E40P RISC-V CPU core, connected through an AHB-based system bus with AHB-to-APB bridges to access a rich set of on-chip peripherals.
</p>
    <p>The SoC integrates Instruction Memory, Data Memory, SPI, UART, 8 GPIOs, and two programmable timers, along with an on-chip clock generator, a debug finite-state machine, and a scan chain for DFT. The complete flow, from project proposal, architecture design, RTL implementation, verification, synthesis, physical design, signoff, and STA, all the way to PCB design, bring-up, and system-level validation, was carried out by our team. The final chip successfully runs on hardware and passes our functional demo.
</p>
      <img src="../images/nanologic/overview.HEIC" alt="System block diagram">
      <p class="caption">Figure 1. Whole System on PCB</p>

  </section>
  
  <section id="architecture">
    <h2>System Architecture</h2>
    <p class="instruction-text">The SoC adopts a modular architecture organized around a RISC-V CPU core, an AMBA-based interconnect, and a set of memory-mapped peripherals, memory and infrastructure blocks. All components are integrated within a compact 2 mm² die implemented in TSMC 65 nm CMOS technology.
</p>


<img src="../images/nanologic/block_diagram.png" alt="System block diagram">
      <p class="caption">Figure 2. SoC Chip Block Diagram</p>

    
    <h3>Main Components</h3>
     <p class="instruction-text">[Describe each major component: processing cores, memory subsystems, I/O interfaces, control logic, etc.]</p>
 
     <h4>CPU</h4>
     <p>At the heart of the chip is our RISC-V CPU core, which executes all application and control software and serves as the sole bus master in the system. The core interfaces with the on-chip interconnect through a lightweight AHB master port, giving it unified access to data storage and all memory-mapped peripherals.
    Importantly, instruction memory (IMEM) is not accessed through the AHB bus. Instead, it is directly connected to the CPU core, enabling a dedicated and deterministic instruction fetch path that simplifies timing and reduces bus traffic.
  </p>
  <p>
The CPU used in this project is version 1.8.3 of the OpenHW Group's RISC-V Core CV32E40P [1]. This core has been previously taped out as part of OpenHW's CORE-V MCU Development Kit; version 1.8.3 has undergone both formal verification and synthesis-based verification across multiple configurations, making it a mature and reliable open-source processor choice.
  <p>
The CV32E40P is a 32-bit, in-order, 4-stage pipeline processor implementing RV32I, RV32M, RV32C, and either RV32F or RV32Zfinx instruction sets. It also supports the PULP custom extensions for enhanced performance.
  </p>
  <p>
For our project, we selected the RV32Zfinx variant, which reuses the general-purpose register file for floating-point operations instead of requiring a dedicated floating-point register file, making it significantly more area-efficient than RV32F.
During the early front-end architecture planning, we initially enabled floating-point support and intended to include the FPU. However, during the physical design phase, we identified significant challenges with timing closure and area overhead introduced by the FPU. Since floating-point computation was not essential to our intended functionality or demo, we ultimately disabled floating-point hardware support to ensure a more robust, compact, and timing-clean implementation.
  </p>

   <p>
      <em>CV32E40P Core</em><br>
The CPU shown in the diagram is based on the CV32E40P core, a 4-stage, in-order RISC-V processor optimized for embedded and low-power applications. Its microarchitecture consists of the classic IF, ID, EX, and WB pipeline stages, with tightly integrated control logic to manage instruction flow, hazard resolution, and power-saving modes. The front end includes a prefetch buffer, instruction aligner, and compressed instruction decoder to improve instruction delivery efficiency. The register file and decoder feed multiple execution units, including an ALU, multiplier/divider, CSR unit, and an optional floating-point unit, enabling a wide range of integer and arithmetic operations. A dedicated Load-Store Unit (LSU) handles memory accesses and interacts with the external data interface. The core also integrates specialized units such as hardware loop registers, debug interface, interrupt controller, and a sleep unit for fine-grained power management. Overall, the design delivers a compact, configurable, and energy-efficient RISC-V processing solution suitable for microcontroller-class systems.
   
  <img src="../images/nanologic/CV32E40P_Block_Diagram.png" alt="System block diagram">
        <p class="caption">Figure 3. CV32E40P CPU Core [1]</p>
</p>

   <p>
       <em>Clock Gating</em><br>
CV32E40P uses a clock-gating strategy at the top level to reduce dynamic power consumption. It is left up to the implementers to define the specifics of the clock gates for synthesis, and instead of implementing custom gating logic, we directly used the Clock Gating cells provided by TSMC.
   </p>
   <p>
    At the top level, the clock network is divided into several functional domains. Each domain receives a gated clock through an ICG cell, and the enable signal is generated based on the activity of the corresponding module. When a module is idle, its clock is disabled, effectively reducing unnecessary switching activity.
   </p>
   <p>
    ICG cell integrates a latch and gating logic to ensure glitch-free clock gating, and also includes a test-enable input for scan and DFT support. Using this standard, fully characterized cell guarantees safe operation and seamless integration with synthesis, CTS, and STA.
   </p>
   <img src="../images/nanologic/icg.png" alt="System block diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br>
          <p class="caption">Figure 4. Clock Gating Cell</p>
   <br><br>
      <p>
      <em>FPU</em><br>
We originally planned to integrate an FPU into the SoC and successfully completed the compiler and linker configuration required to support floating-point operations. The FPU passed our initial functional simulations and worked correctly at the RTL level. However, after synthesis, physical design, and timing analysis, the FPU ran into timing issues which were not easily solved. To maintain overall system stability and achieve a much higher operating frequency, we ultimately decided to remove the FPU. Without the FPU's long combinational paths, the SoC's maximum clock period improved from 15 ns to 5 ns, resulting in substantially better performance and a more reliable design.
  <img src="../images/nanologic/FPU.png" alt="FPU">
            <p class="caption">Figure 5. Floating Point Operations</p>
   </p>
   <h4>Memory</h4>
<p>
The SoC adopts a Harvard memory architecture, featuring fully separated instruction and data memories to maximize throughput and simplify timing. The memory subsystem consists of two on-chip SRAM blocks:<br>
  <br> 
  <strong>Instruction Memory (IMEM):</strong> Directly connected to CPU fetch interface.<br>
  <strong>Data Memory (DMEM):</strong> AHB slave accessed by CPU load/store instructions.<br>

  <br>
  The instruction memory provides a dedicated, point-to-point connection to the CPU's instruction fetch interface. By avoiding the system bus entirely, IMEM enables deterministic instruction delivery, lower latency, and reduced bus contention.
Originally, the design targeted 32 KB of instruction storage, but due to strict die-area constraints during physical design, the IMEM size was adjusted to 16 KB, which still meets the needs of our target workloads and demo applications.
  <br>
  <br>
  The data memory is implemented as an AHB slave and connected to the CPU via the shared bus. All load/store instructions are routed through this bus interface, maintaining a clean separation between instruction fetch and data access. Similar to IMEM, DMEM was initially planned as 32 KB, but was downsized to 16 KB to fit within the allowable silicon footprint.
  <br>
  <br>
  <strong>Addressing and byte enables</strong><br>
  An important thing to note about both IMEM and DMEM is that at the memory level, each address corresponds to a 32-bit data cell, which means for 16KiB of capacity, we have a 12-bit wide address bus. However, the RISC-V ISA expects to be able to access the memory byte-wise, so we have a 4-bit wide BEN (or WEN as the generated memory calls it) bus which controls which bytes of the 32-bit word at a given memory address are actually written to.
  <br><br>
  This system is easy to integrate with the CPU, since it natively expects this sort of setup and so outputs the size of the data it is writing in bytes, which can be fed into the BEN bus. It still, however, treats each address as a single byte, and so does our AHB bus, so to deal with this, we do two things. For the scan chain, in the memory wrappers, we simply shift the incoming address right by 2 to forcibly word-align it. For the data coming from the AHB bus, for IMEM, the wrapper also shifts that incoming address right by 2; for DMEM, that shift is instead done in the DMEM AHB slave.
  <br><br>
  Our peripherals, with the exception of UART, also treat memory addresses as byte-aligned and do the shifting internally to treat it as word-aligned for their internal registers. For UART, which does not do this internal shifting and expects world-aligned addresses, we simply shift the address going into the UART peripheral right by two.
  <br><br>
  The key takeaway from all this is that from the perspective of the CPU, the AHB bus, and the software, the memory addresses are byte-wise, and we enforce a 32-bit word alignment in the compiler. From the perspective of the memory cells, memory addresses are word-wise, and the CPU can specify which bytes in the word to write to.
  <br><br>

  <strong>SRAM Implementation and Memory Wrapper</strong><br>
  Both IMEM and DMEM are implemented as SRAM hard macros generated with the ARM memory compiler. Since these macros are technology-specific and lack native support for system-level protocols or scan operations, we designed custom memory wrapper modules to ensure clean integration into the SoC.<br>
  <br>
  The memory wrappers provide several key functions:<br>
<ul>
  <li>Adapt the SRAM macro interfaces to the CPU and AHB protocol requirements. Manage functional control signals including read/write enables, chip-select, and byte enables.</li>
  <li>Implement a dedicated mode-switching mechanism that supports both normal run mode and DFT scan mode.</li>
  <li>Adding delay cells to avoid hold violation.Provide a clean, synthesizable interface for RTL simulation while isolating technology-specific macro details.</li>
</ul>
</p>
<p>
  <strong>Run Mode</strong><br>
In run mode, the wrapper exposes the memory as part of the functional SoC:
<ul>
<li>IMEM connects directly to the CPU's instruction-fetch interface.</li>
<li>DMEM operates as an AHB slave, servicing all CPU load/store requests via the system bus.</li>
<li>All functional address, control, and data signals drive the SRAM in this mode.</li>
</ul>
</p>

<p>
  <strong>Scan Mode</strong><br>
To enable complete chip-level scan coverage, the wrappers include logic that reconfigures the memory into scan mode during DFT operation:
<ul>
<li>The memory wrapper becomes part of the SoC's continuous scan chain, enabling scan vector to scan-in / scan-out. </li>
</ul>
</p>
   <img src="../images/nanologic/sram_wrapper.png" alt="System block diagram" style="display:block; margin:0 auto; width:80%; height:auto;"><br>
          <p class="caption">Figure 4. DMEM wrapper</p>


    
    <details class="code-block">
      <summary>IMEM wrapper (imem_wrapper.sv)</summary>
      <div class="code-content"><pre><code>//`include &quot;sram00.v&quot;
`timescale 1 ns/1 ps

module imem_wrapper (
    // Clocks &amp; Reset
    input logic        clk_i,          // System clock
    input logic        sc2imem_clk,    // Scan chain clock
    input logic        rst_ni,         // Active-low reset

    // Power Management
    input logic        RETN,           // Retention mode control
    input logic [2:0]  EMA,            // Energy Management Adjustment (power optimization)

    // CPU Interface (Core to IMEM)
    input logic        core2imem_req,   // CPU memory request (active high)
    input logic [31:0] core2imem_addr,  // 32-bit memory address from CPU

    // Scan Chain Interface
    input logic        sc2imem_ctrl,    // Selects between Scan Chain &amp; CPU control
    input logic        sc2imem_req,     // Scan Chain memory request (active low)
    input logic [31:0] sc2imem_addr,    // Scan Chain memory address
    input logic        sc2imem_wen,     // Scan Chain Write Enable (active low)
    input logic [31:0] sc2imem_wdata,   // Scan Chain Write Data

    // IMEM Outputs
    output logic       imem_rvalid_o,   // Read valid flag
    output logic [31:0] imem_rdata_o    // Read Data from IMEM
);

    // Address Width for 8192 Words (log2(8192) = 13-bit)
    localparam int Aw = $clog2(4096);  

    // Internal Signals
    logic clk_imem;               // IMEM clock (either system clock or scan chain clock)
    logic imem_req, imem_req_delay; // Memory request
    logic [Aw-1:0] imem_addr, imem_addr_delay; // Memory address (word-aligned)
    logic imem_wen, imem_wen_delay; // Write enable
    logic [3:0] imem_ben, imem_ben_delay; // Byte enable mask
    logic [31:0] imem_wdata, imem_wdata_delay; // Write Data

    // Clock Selection (Use either CPU clock or Scan Chain clock)
    assign clk_imem = clk_i | sc2imem_clk;

    // Multiplex between CPU and Scan Chain for IMEM access
    assign imem_req   = sc2imem_ctrl ? sc2imem_req            : ~core2imem_req;
    assign imem_addr  = sc2imem_ctrl ? sc2imem_addr[Aw-1+2:2] : core2imem_addr[Aw-1+2:2]; // Convert byte address to word address
    assign imem_wen   = sc2imem_ctrl ? sc2imem_wen            : 1&#x27;b1; // Default to no write in CPU mode
    assign imem_ben   = sc2imem_ctrl ? {4{sc2imem_wen}}       : 4&#x27;b1111; // Default to full-word access in CPU mode
    assign imem_wdata = sc2imem_ctrl ? sc2imem_wdata          : 32&#x27;b0; // Default to 0 when CPU accesses

    // Introduce Delays to Synchronize Signals
	// DEL1 del01( .I(imem_req), .Z(imem_req_delay));
	// DEL1 del02( .I(imem_addr[0]), .Z(imem_addr_delay[0]));
	// DEL1 del03( .I(imem_addr[1]), .Z(imem_addr_delay[1]));
	// DEL1 del04( .I(imem_addr[2]), .Z(imem_addr_delay[2]));
	// DEL1 del05( .I(imem_addr[3]), .Z(imem_addr_delay[3]));
	// DEL1 del06( .I(imem_addr[4]), .Z(imem_addr_delay[4]));
	// DEL1 del07( .I(imem_addr[5]), .Z(imem_addr_delay[5]));
	// DEL1 del08( .I(imem_addr[6]), .Z(imem_addr_delay[6]));
	// DEL1 del09( .I(imem_addr[7]), .Z(imem_addr_delay[7]));
	// DEL1 del10( .I(imem_addr[8]), .Z(imem_addr_delay[8]));
	// DEL1 del11( .I(imem_addr[9]), .Z(imem_addr_delay[9]));
	// DEL1 del12( .I(imem_addr[10]), .Z(imem_addr_delay[10]));
	// DEL1 del13( .I(imem_addr[11]), .Z(imem_addr_delay[11]));
	// DEL1 del14( .I(imem_addr[12]), .Z(imem_addr_delay[12]));
    always @(imem_req) #5 imem_req_delay = imem_req;

    always @(imem_addr[0]) #5 imem_addr_delay[0] = imem_addr[0];
    always @(imem_addr[1]) #5 imem_addr_delay[1] = imem_addr[1];
    always @(imem_addr[2]) #5 imem_addr_delay[2] = imem_addr[2];
    always @(imem_addr[3]) #5 imem_addr_delay[3] = imem_addr[3];
    always @(imem_addr[4]) #5 imem_addr_delay[4] = imem_addr[4];
    always @(imem_addr[5]) #5 imem_addr_delay[5] = imem_addr[5];
    always @(imem_addr[6]) #5 imem_addr_delay[6] = imem_addr[6];
    always @(imem_addr[7]) #5 imem_addr_delay[7] = imem_addr[7];
    always @(imem_addr[8]) #5 imem_addr_delay[8] = imem_addr[8];
    always @(imem_addr[9]) #5 imem_addr_delay[9] = imem_addr[9];
    always @(imem_addr[10]) #5 imem_addr_delay[10] = imem_addr[10];
    always @(imem_addr[11]) #5 imem_addr_delay[11] = imem_addr[11];


    // genvar i;
    // generate
    //     for (i = 0; i &lt; 13; i = i + 1) begin : addr_delay_gen
    //         DEL1 del_addr(.clk(clk_imem), .I(imem_addr[i]), .Z(imem_addr_delay[i]));
    //     end
    // endgenerate

    always @(imem_wdata) #50 imem_wdata_delay = imem_wdata;
    always @(imem_wen)   #50 imem_wen_delay   = imem_wen;
    always @(imem_ben)   #50 imem_ben_delay   = imem_ben;

    // IMEM Instance (Pre-Synthesis Simulation)
    sram00 imem (
        .CLK(clk_imem), 
        .CEN(imem_req_delay), 
        .WEN(imem_ben_delay), 
        .GWEN(imem_wen_delay), 
        .A(imem_addr_delay), 
        .D(imem_wdata_delay), 
        .Q(imem_rdata_o), 
        .EMA(3&#x27;b001), 
        .RETN(RETN)
    );

    // Read Valid Signal (Output delayed by 1 cycle)
    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (!rst_ni) 
            imem_rvalid_o &lt;= 1&#x27;b0;
        else 
            imem_rvalid_o &lt;= core2imem_req;
    end

endmodule


</code></pre></div>
    </details>


    <details class="code-block">
      <summary>DMEM wrapper (dmem_wrapper.sv)</summary>
      <div class="code-content"><pre><code>`timescale 1ns/1ps

module dmem_wrapper (
    // Clocks &amp; Reset
    input logic         clk_i,          // System clock
    input logic         sc2dmem_clk,    // Scan Chain clock
    input logic         rst_ni,         // Active-low reset

    // Power Management
    input logic         RETN,           // Retention mode control
    input logic [2:0]   EMA,            // Energy Management Adjustment (power optimization)

    // CPU Interface (Core to DMEM)
    input logic         core2dmem_req,   // CPU request to access DMEM
    input logic [31:0]  core2dmem_addr,  // 32-bit byte address from CPU
    input logic         core2dmem_wen,   // Write enable (active low)
    input logic [3:0]   core2dmem_ben,   // Byte enable (active low per byte)
    input logic [31:0]  core2dmem_wdata, // Write data

    // Scan Chain Interface (Test/Debug Access)
    input logic         sc2dmem_ctrl,    // Selects between Scan Chain &amp; CPU control
    input logic         sc2dmem_req,     // Scan Chain request (active low)
    input logic [31:0]  sc2dmem_addr,    // Scan Chain memory address
    input logic         sc2dmem_wen,     // Scan Chain Write Enable (active low)
    input logic [3:0]   sc2dmem_ben,     // Scan Chain Byte Enable (active low)
    input logic [31:0]  sc2dmem_wdata,   // Scan Chain Write Data

    // DMEM Outputs
    output logic        dmem_rvalid_o,   // Read valid flag
    output logic [31:0] dmem_rdata_o     // Read Data from DMEM
);

    // Address Width for 8192 Words (log2(8192) = 13-bit)
    localparam int Aw = $clog2(4096);

    // Internal Signals
    logic clk_dmem;                // DMEM clock (either system clock or scan chain clock)
    logic dmem_req, dmem_req_delay; // Memory request
    logic [Aw-1:0] dmem_addr, dmem_addr_delay; // Word-aligned memory address
    logic dmem_wen, dmem_wen_delay; // Write enable signal
    logic [3:0] dmem_ben, dmem_ben_delay; // Byte enable mask
    logic [31:0] dmem_wdata, dmem_wdata_delay; // Write Data

    // Clock Selection (Use either CPU clock or Scan Chain clock)
    assign clk_dmem = clk_i | sc2dmem_clk;

    // Multiplex between CPU and Scan Chain for DMEM access
    assign dmem_req   = sc2dmem_ctrl ? sc2dmem_req             : core2dmem_req;
    assign dmem_addr  = sc2dmem_ctrl ? sc2dmem_addr[Aw-1+2:2]  : core2dmem_addr; // Convert byte address to word address
    assign dmem_wen   = sc2dmem_ctrl ? sc2dmem_wen             : core2dmem_wen;
    assign dmem_ben   = sc2dmem_ctrl ? sc2dmem_ben             : ~core2dmem_ben;  // Convert active-high to active-low
    assign dmem_wdata = sc2dmem_ctrl ? sc2dmem_wdata           : core2dmem_wdata;

    // Introduce Delays to Synchronize Signals
 // DEL4 del01( .I(dmem_req), .Z(dmem_req_delay));
    always @(dmem_req) #5 dmem_req_delay = dmem_req;

/*	DEL4 del02( .I(dmem_addr[0]), .Z(dmem_addr_delay[0]));
	DEL4 del03( .I(dmem_addr[1]), .Z(dmem_addr_delay[1]));
	DEL4 del04( .I(dmem_addr[2]), .Z(dmem_addr_delay[2]));
	DEL4 del05( .I(dmem_addr[3]), .Z(dmem_addr_delay[3]));
	DEL4 del06( .I(dmem_addr[4]), .Z(dmem_addr_delay[4]));
	DEL4 del07( .I(dmem_addr[5]), .Z(dmem_addr_delay[5]));
	DEL4 del08( .I(dmem_addr[6]), .Z(dmem_addr_delay[6]));
	DEL4 del09( .I(dmem_addr[7]), .Z(dmem_addr_delay[7]));
	DEL4 del10( .I(dmem_addr[8]), .Z(dmem_addr_delay[8]));
	DEL4 del11( .I(dmem_addr[9]), .Z(dmem_addr_delay[9]));
	DEL4 del11a( .I(dmem_addr[10]), .Z(dmem_addr_delay[10]));
	DEL4 del11b( .I(dmem_addr[11]), .Z(dmem_addr_delay[11]));
	DEL4 del11c( .I(dmem_addr[12]), .Z(dmem_addr_delay[12]));*/
    always @(dmem_addr[0]) #5 dmem_addr_delay[0] = dmem_addr[0];
    always @(dmem_addr[1]) #5 dmem_addr_delay[1] = dmem_addr[1];
    always @(dmem_addr[2]) #5 dmem_addr_delay[2] = dmem_addr[2];
    always @(dmem_addr[3]) #5 dmem_addr_delay[3] = dmem_addr[3];
    always @(dmem_addr[4]) #5 dmem_addr_delay[4] = dmem_addr[4];
    always @(dmem_addr[5]) #5 dmem_addr_delay[5] = dmem_addr[5];
    always @(dmem_addr[6]) #5 dmem_addr_delay[6] = dmem_addr[6];
    always @(dmem_addr[7]) #5 dmem_addr_delay[7] = dmem_addr[7];
    always @(dmem_addr[8]) #5 dmem_addr_delay[8] = dmem_addr[8];
    always @(dmem_addr[9]) #5 dmem_addr_delay[9] = dmem_addr[9];
    always @(dmem_addr[10]) #5 dmem_addr_delay[10] = dmem_addr[10];
    always @(dmem_addr[11]) #5 dmem_addr_delay[11] = dmem_addr[11];


//	DEL4 del12( .I(dmem_wen), .Z(dmem_wen_delay));
    always @(dmem_wen)   #5 dmem_wen_delay   = dmem_wen;

    always @(dmem_ben[0]) #5 dmem_ben_delay[0] = dmem_ben[0];
    always @(dmem_ben[1]) #5 dmem_ben_delay[1] = dmem_ben[1];
    always @(dmem_ben[2]) #5 dmem_ben_delay[2] = dmem_ben[2];
    always @(dmem_ben[3]) #5 dmem_ben_delay[3] = dmem_ben[3];
/*
	DEL4 del13( .I(dmem_ben[0]), .Z(dmem_ben_delay[0]));
	DEL4 del14( .I(dmem_ben[1]), .Z(dmem_ben_delay[1]));
	DEL4 del15( .I(dmem_ben[2]), .Z(dmem_ben_delay[2]));
	DEL4 del16( .I(dmem_ben[3]), .Z(dmem_ben_delay[3]));


	DEL4 del17( .I(dmem_wdata[0]), .Z(dmem_wdata_delay[0]));
	DEL4 del18( .I(dmem_wdata[1]), .Z(dmem_wdata_delay[1]));
	DEL4 del19( .I(dmem_wdata[2]), .Z(dmem_wdata_delay[2]));
	DEL4 del20( .I(dmem_wdata[3]), .Z(dmem_wdata_delay[3]));
	DEL4 del21( .I(dmem_wdata[4]), .Z(dmem_wdata_delay[4]));
	DEL4 del22( .I(dmem_wdata[5]), .Z(dmem_wdata_delay[5]));
	DEL4 del23( .I(dmem_wdata[6]), .Z(dmem_wdata_delay[6]));
	DEL4 del24( .I(dmem_wdata[7]), .Z(dmem_wdata_delay[7]));
	DEL4 del25( .I(dmem_wdata[8]), .Z(dmem_wdata_delay[8]));
	DEL4 del26( .I(dmem_wdata[9]), .Z(dmem_wdata_delay[9]));
	DEL4 del27( .I(dmem_wdata[10]), .Z(dmem_wdata_delay[10]));
	DEL4 del28( .I(dmem_wdata[11]), .Z(dmem_wdata_delay[11]));
	DEL4 del29( .I(dmem_wdata[12]), .Z(dmem_wdata_delay[12]));
	DEL4 del30( .I(dmem_wdata[13]), .Z(dmem_wdata_delay[13]));
	DEL4 del31( .I(dmem_wdata[14]), .Z(dmem_wdata_delay[14]));
	DEL4 del32( .I(dmem_wdata[15]), .Z(dmem_wdata_delay[15]));
	DEL4 del33( .I(dmem_wdata[16]), .Z(dmem_wdata_delay[16]));
	DEL4 del34( .I(dmem_wdata[17]), .Z(dmem_wdata_delay[17]));
	DEL4 del35( .I(dmem_wdata[18]), .Z(dmem_wdata_delay[18]));
	DEL4 del36( .I(dmem_wdata[19]), .Z(dmem_wdata_delay[19]));
	DEL4 del37( .I(dmem_wdata[20]), .Z(dmem_wdata_delay[20]));
	DEL4 del38( .I(dmem_wdata[21]), .Z(dmem_wdata_delay[21]));
	DEL4 del39( .I(dmem_wdata[22]), .Z(dmem_wdata_delay[22]));
	DEL4 del40( .I(dmem_wdata[23]), .Z(dmem_wdata_delay[23]));
	DEL4 del41( .I(dmem_wdata[24]), .Z(dmem_wdata_delay[24]));
	DEL4 del42( .I(dmem_wdata[25]), .Z(dmem_wdata_delay[25]));
	DEL4 del43( .I(dmem_wdata[26]), .Z(dmem_wdata_delay[26]));
	DEL4 del44( .I(dmem_wdata[27]), .Z(dmem_wdata_delay[27]));
	DEL4 del45( .I(dmem_wdata[28]), .Z(dmem_wdata_delay[28]));
	DEL4 del46( .I(dmem_wdata[29]), .Z(dmem_wdata_delay[29]));
	DEL4 del47( .I(dmem_wdata[30]), .Z(dmem_wdata_delay[30]));
	DEL4 del48( .I(dmem_wdata[31]), .Z(dmem_wdata_delay[31]));*/
    always @(dmem_wdata[0])  #5 dmem_wdata_delay[0]  = dmem_wdata[0];
    always @(dmem_wdata[1])  #5 dmem_wdata_delay[1]  = dmem_wdata[1];
    always @(dmem_wdata[2])  #5 dmem_wdata_delay[2]  = dmem_wdata[2];
    always @(dmem_wdata[3])  #5 dmem_wdata_delay[3]  = dmem_wdata[3];
    always @(dmem_wdata[4])  #5 dmem_wdata_delay[4]  = dmem_wdata[4];
    always @(dmem_wdata[5])  #5 dmem_wdata_delay[5]  = dmem_wdata[5];
    always @(dmem_wdata[6])  #5 dmem_wdata_delay[6]  = dmem_wdata[6];
    always @(dmem_wdata[7])  #5 dmem_wdata_delay[7]  = dmem_wdata[7];
    always @(dmem_wdata[8])  #5 dmem_wdata_delay[8]  = dmem_wdata[8];
    always @(dmem_wdata[9])  #5 dmem_wdata_delay[9]  = dmem_wdata[9];
    always @(dmem_wdata[10]) #5 dmem_wdata_delay[10] = dmem_wdata[10];
    always @(dmem_wdata[11]) #5 dmem_wdata_delay[11] = dmem_wdata[11];
    always @(dmem_wdata[12]) #5 dmem_wdata_delay[12] = dmem_wdata[12];
    always @(dmem_wdata[13]) #5 dmem_wdata_delay[13] = dmem_wdata[13];
    always @(dmem_wdata[14]) #5 dmem_wdata_delay[14] = dmem_wdata[14];
    always @(dmem_wdata[15]) #5 dmem_wdata_delay[15] = dmem_wdata[15];
    always @(dmem_wdata[16]) #5 dmem_wdata_delay[16] = dmem_wdata[16];
    always @(dmem_wdata[17]) #5 dmem_wdata_delay[17] = dmem_wdata[17];
    always @(dmem_wdata[18]) #5 dmem_wdata_delay[18] = dmem_wdata[18];
    always @(dmem_wdata[19]) #5 dmem_wdata_delay[19] = dmem_wdata[19];
    always @(dmem_wdata[20]) #5 dmem_wdata_delay[20] = dmem_wdata[20];
    always @(dmem_wdata[21]) #5 dmem_wdata_delay[21] = dmem_wdata[21];
    always @(dmem_wdata[22]) #5 dmem_wdata_delay[22] = dmem_wdata[22];
    always @(dmem_wdata[23]) #5 dmem_wdata_delay[23] = dmem_wdata[23];
    always @(dmem_wdata[24]) #5 dmem_wdata_delay[24] = dmem_wdata[24];
    always @(dmem_wdata[25]) #5 dmem_wdata_delay[25] = dmem_wdata[25];
    always @(dmem_wdata[26]) #5 dmem_wdata_delay[26] = dmem_wdata[26];
    always @(dmem_wdata[27]) #5 dmem_wdata_delay[27] = dmem_wdata[27];
    always @(dmem_wdata[28]) #5 dmem_wdata_delay[28] = dmem_wdata[28];
    always @(dmem_wdata[29]) #5 dmem_wdata_delay[29] = dmem_wdata[29];
    always @(dmem_wdata[30]) #5 dmem_wdata_delay[30] = dmem_wdata[30];
    always @(dmem_wdata[31]) #5 dmem_wdata_delay[31] = dmem_wdata[31];


    // Pre-Synthesis Simulation
    sram00 dmem (
        .CLK(clk_dmem),
        .CEN(dmem_req_delay),
        .WEN(dmem_ben_delay),
        .GWEN(dmem_wen_delay),
        .A(dmem_addr_delay),
        .D(dmem_wdata_delay),
        .Q(dmem_rdata_o),
        .EMA(3&#x27;b001), // EMA fixed to 001 clears setup errors
        .RETN(RETN)
    );

    // Post-Synthesis Simulation (Uncomment if needed)
    // sram00 dmem(
    //     .CLK(clk_dmem),
    //     .CEN(dmem_req),
    //     .WEN(dmem_ben),
    //     .GWEN(dmem_wen),
    //     .A(dmem_addr),
    //     .D(dmem_wdata),
    //     .Q(dmem_rdata_o),
    //     .EMA(EMA),
    //     .RETN(RETN)
    // );

    // Read Valid Signal (Output delayed by 1 cycle)
    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (!rst_ni)
            dmem_rvalid_o &lt;= 1&#x27;b0;
        else
            dmem_rvalid_o &lt;= ~dmem_req;
    end

endmodule
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>DMEM AHB slave (dmem_slave.v)</summary>
      <div class="code-content"><pre><code>`define ARM_UD_MODEL
module dmem_slave  #(
    parameter AW = 16
) (
    input              HCLK,
    input              HRESETn,
    input              HSEL,
    input       [31:0] HADDR,
    input       [ 1:0] HTRANS,
    input              HWRITE,
    input       [ 3:0] HSIZE,
    input       [ 2:0] HBURST,
    input       [ 3:0] HPROT, 

    output reg  [ 3:0] SIZE,


    input       [31:0] HWDATA,
    output      [31:0] HRDATA,
    output reg  [ 1:0] HRESP,
    input              HREADY,
    output reg         HREADYOUT,

    output reg  [AW-1:0] A,
    output      [31:0] D,
    output reg         CEN,
    output reg         WEN,
    input       [31:0] Q

);

    //----------------------------------------------------
    // The signals for SRAM
    //----------------------------------------------------
    parameter BITS = 32; //every word has 32 bits
    parameter WORD_WIDTH = AW; //using 10 bits represent row address
    
    assign D = HWDATA;
    assign HRDATA = Q;

    //----------------------------------------------------------------------
    // The definition for state machine
    //----------------------------------------------------------------------
    reg [1:0] state;
    reg [1:0] next_state;
    localparam idle = 2&#x27;b00, s1 = 2&#x27;b01, s2 = 2&#x27;b10, s3 = 2&#x27;b11;

    //----------------------------------------------------------------------
    // The state machine
    //----------------------------------------------------------------------
    always @(posedge HCLK, negedge HRESETn) begin
        if (!HRESETn) begin
            state &lt;= s1;
        end
        else begin
            state &lt;= next_state;
        end
    end
    
    always @(*) begin
        case(state)
            s1: begin
                if ((HSEL == 1&#x27;b1) &amp;&amp; (HWRITE == 1&#x27;b1) &amp;&amp; (HREADY == 1&#x27;b1)) begin
                    next_state = s2;
                end
                else if ((HSEL == 1&#x27;b1) &amp;&amp; (HWRITE == 1&#x27;b0) &amp;&amp; (HREADY == 1&#x27;b1)) begin
                    next_state = s3;
                end
                else begin
                    next_state = s1;
                end
            end
            s2: begin 
                next_state = s1;
            end
            s3: begin 
                next_state = s1;
            end
            default: begin
                next_state = s1;
            end
        endcase
    end

    always @(posedge HCLK, negedge HRESETn) begin
        if(!HRESETn) begin
            HREADYOUT &lt;= 1&#x27;b1;
            HRESP &lt;= 2&#x27;b00;
            A &lt;= 16&#x27;b0;
            CEN &lt;= 1&#x27;b1;
            WEN &lt;= 1&#x27;b1;
        end
        else begin

    	    SIZE  &lt;= HSIZE;

            case(next_state)
                s1: begin
                    HREADYOUT &lt;= 1&#x27;b1;
                    HRESP &lt;= 2&#x27;b00;
                    if ((HSEL == 1&#x27;b1) &amp;&amp; (HWRITE == 1&#x27;b1) &amp;&amp; (HREADY == 1&#x27;b1)) begin
                        CEN &lt;= 1&#x27;b0;
                        WEN &lt;= 1&#x27;b0;
                        A &lt;= HADDR[WORD_WIDTH-1+2:2];
                    end
                    else if ((HSEL == 1&#x27;b1) &amp;&amp; (HWRITE == 1&#x27;b0) &amp;&amp; (HREADY == 1&#x27;b1)) begin
                        CEN &lt;= 1&#x27;b0;
                        WEN &lt;= 1&#x27;b1;
                        A &lt;= HADDR[WORD_WIDTH-1+2:2];
                    end
                    else begin
                        CEN &lt;= 1&#x27;b1;
                        WEN &lt;= 1&#x27;b1;
                        A &lt;= A;
                    end
                end
                s2: begin
                    HREADYOUT &lt;= 1&#x27;b0;
                    HRESP &lt;= 2&#x27;b00;
                    CEN &lt;= 1&#x27;b0;
                    WEN &lt;= 1&#x27;b0;
                    A &lt;= HADDR[WORD_WIDTH-1+2:2];
                end
                s3: begin
                    HREADYOUT &lt;= 1&#x27;b0;
                    HRESP &lt;= 2&#x27;b00;
                    CEN &lt;= 1&#x27;b0;
                    WEN &lt;= 1&#x27;b1;
                    A &lt;= HADDR[WORD_WIDTH-1+2:2];
                end
                default: begin
                    HREADYOUT &lt;= 1&#x27;b1;
                    HRESP &lt;= 2&#x27;b00;
                    CEN &lt;= 1&#x27;b1;
                    WEN &lt;= 1&#x27;b1;
                    A &lt;= A;
                end
            endcase
        end
    end

endmodule
</code></pre></div>
    </details>

<h4>On-Chip Interconnect and Bus Architecture</h4>
<p>
A central AMBA AHB system bus forms the primary communication backbone of the SoC. The bus is organized in a 1-master / 6-slave (M16S) topology, with the RISC-V CPU core acting as the only AHB master. It helps keep the interconnect simple, low-latency, and area-efficient.
<br>
<br>
   <img src="../images/nanologic/ahb_picture.png" alt="System block diagram">
   <p class="caption">Figure 5. AHB Interconnection [3]</p>
Among the AHB slaves, the data memory (DMEM) is connected directly to the AHB bus as an AHB slave. All load/store instructions issued by the CPU are translated into AHB transactions through the LSU module, providing a straightforward path for data accesses.
<br>
<br>
All other low-bandwidth, register-mapped peripherals are accessed indirectly through an AHB-to-APB bridge, which itself appears as an AHB slave on the system bus. Behind this bridge, a set of APB peripherals is instantiated, including:
<ul>
<li>GPIO</li>
<li>SPI</li>
<li>UART</li>
<li>I²C</li>
<li>Two general-purpose Timers</li>
</ul>
</p>
<p>
The AHB-to-APB bridge decouples the higher-speed AHB domain from the simpler APB domain by:
<ul>
<li>Translating AHB read/write transactions into APB transfers</li>
<li>Generating APB select, enable, and write control signals for each peripheral</li>
<li>Isolating the timing and fan-out of the peripheral bus from the main system bus</li>
</ul>
</p>
<img src="../images/nanologic/apb.png" alt="System block diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br><br>
            <p class="caption">Figure 6. APB FSM Diagram [2]</p>
    
    <details class="code-block">
      <summary>AHB-to-APB bridge (AHB_APB_brig.v)</summary>
      <div class="code-content"><pre><code>//For UART address space
//
//Add byte enable signal: HSIZE

module AHB_APB_brig

(

	input	[31:0]	HADDR,
	input	[31:0]	HWDATA,
	input	[31:0]	PRDATA,
	
	input	[1:0]	HTRANS,
	input	HREADYin,
	input	HWRITE,
	input	HRESETn,
	input	HCLK,
	
	input	[2:0]	HSIZE,
	
	input           HSEL,
	input	[3:0]	H_BE,	//Added for byte addr enable

	output	[12:0]	PADDR,
	output	[31:0]	PWDATA,
	output	[31:0]	HRDATA,
	
	output	[1:0]	HRESP,
	
	output	PWRITE,
	output	PENABLE,
	output	HREADYout,
	
	output	[2:0]	PSEL

);


wire	[31:0]ADDR_1,ADDR_2,ADDR_3,
	      DATA_1,DATA_2,DATA_3;

wire	w_reg,vld;
wire [2:0]tmp_sel;

//Added for address mismatch 
wire [31:0] PADDR_fsm;
assign PADDR = PADDR_fsm[12:0];

reg	[31:0]	HADDR_BE;





always@(*) begin
	HADDR_BE = HADDR[12:0];
end


ahb_slave SLAVE(.HADDR(HADDR_BE),	  	.HWDATA(HWDATA),	.HTRANS(HTRANS),
		.HREADYin(HREADYin),	.HWRITE(HWRITE),	.HRESP(HRESP), 
		.HRDATA(HRDATA),	.HSIZE(HSIZE),		.HCLK(HCLK),
		.HRESETn(HRESETn),	.HSEL(HSEL),			.PRDATA(PRDATA),	.HADDR_1(ADDR_1),
		.HWDATA_1(DATA_1),	.HADDR_2(ADDR_2),	.HWDATA_2(DATA_2),
		.HADDR_3(ADDR_3),	.HWDATA_3(DATA_3),	.HWRITEreg(w_reg),
		.valid(vld),		.TEMP_SEL(tmp_sel));


fsm FSM(.HADDR_1(ADDR_1),		.HADDR_2(ADDR_2),	.HADDR_3(ADDR_3),
	.HWDATA_1(DATA_1),		.HWDATA_2(DATA_2),	.HWDATA_3(DATA_3),
	.HWRITE(HWRITE),		.HWRITEreg(w_reg),	.HSIZE(HSIZE),
        .TEMP_SEL(tmp_sel),		.valid(vld),		.PADDR(PADDR_fsm),
	.PWDATA(PWDATA),		.PSEL(PSEL),		.PWRITE(PWRITE),
	.PENABLE(PENABLE),		.HCLK(HCLK),		.HRESETn(HRESETn),
	.HTRANS(HTRANS),		.HREADYout(HREADYout));




endmodule







	

	
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>AHB interconnect (amba_ahb_m1s6.v)</summary>
      <div class="code-content"><pre><code>//---------------------------------------------------------------------------
// gen_amba_ahb.v generated by &quot;gen_amba_ahb (20210710)&quot;
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
module amba_ahb_m1s6
     #(parameter P_NUM=6 // num of slaves
               , P_HSEL0_START=32&#x27;h00000000, P_HSEL0_SIZE=32&#x27;h10000000 //DMEM
               , P_HSEL1_START=32&#x27;h10000000, P_HSEL1_SIZE=32&#x27;h10000000 //GPIO
               , P_HSEL2_START=32&#x27;h20000000, P_HSEL2_SIZE=32&#x27;h10000000 //UART
               , P_HSEL3_START=32&#x27;h30000000, P_HSEL3_SIZE=32&#x27;h10000000 //SPI
               , P_HSEL4_START=32&#x27;h40000000, P_HSEL4_SIZE=32&#x27;h10000000 //I2C
               , P_HSEL5_START=32&#x27;h50000000, P_HSEL5_SIZE=32&#x27;h10000000 //Timers
               )
(
        input   wire         HRESETn
      , input   wire         HCLK
      , input   wire  [31:0] M_HADDR
      , input   wire  [ 1:0] M_HTRANS
      , input   wire         M_HWRITE
      , input   wire  [ 3:0] M_HSIZE
      , input   wire  [ 2:0] M_HBURST
      , input   wire  [ 3:0] M_HPROT
      , input   wire  [31:0] M_HWDATA
      , output  wire  [31:0] M_HRDATA
      , output  wire  [ 1:0] M_HRESP
      , output  wire         M_HREADY
      , output  wire  [31:0] S_HADDR
      , output  wire  [ 1:0] S_HTRANS
      , output  wire  [ 3:0] S_HSIZE
      , output  wire  [ 2:0] S_HBURST
      , output  wire  [ 3:0] S_HPROT
      , output  wire         S_HWRITE
      , output  wire  [31:0] S_HWDATA
      , output  wire         S_HREADY
      , output  wire         S0_HSEL
      , input   wire         S0_HREADY
      , input   wire  [ 1:0] S0_HRESP
      , input   wire  [31:0] S0_HRDATA
      , output  wire         S1_HSEL
      , input   wire         S1_HREADY
      , input   wire  [ 1:0] S1_HRESP
      , input   wire  [31:0] S1_HRDATA
      , output  wire         S2_HSEL
      , input   wire         S2_HREADY
      , input   wire  [ 1:0] S2_HRESP
      , input   wire  [31:0] S2_HRDATA
      , output  wire         S3_HSEL
      , input   wire         S3_HREADY
      , input   wire  [ 1:0] S3_HRESP
      , input   wire  [31:0] S3_HRDATA
      , output  wire         S4_HSEL
      , input   wire         S4_HREADY
      , input   wire  [ 1:0] S4_HRESP
      , input   wire  [31:0] S4_HRDATA
      , output  wire         S5_HSEL
      , input   wire         S5_HREADY
      , input   wire  [ 1:0] S5_HRESP
      , input   wire  [31:0] S5_HRDATA
      , input   wire         REMAP
);
   wire        HSELd; // default slave
   wire [31:0] HRDATAd;
   wire [ 1:0] HRESPd;
   wire        HREADYd;
   assign S_HADDR  = M_HADDR;
   assign S_HTRANS = M_HTRANS;
   assign S_HSIZE  = M_HSIZE;
   assign S_HBURST = M_HBURST;
   assign S_HWRITE = M_HWRITE;
   assign S_HPROT  = M_HPROT;
   assign S_HWDATA = M_HWDATA;
   assign S_HREADY = M_HREADY;
   ahb_decoder_s6
      #(.P_NUM(6)
       ,.P_HSEL0_START(P_HSEL0_START),.P_HSEL0_SIZE(P_HSEL0_SIZE)
       ,.P_HSEL1_START(P_HSEL1_START),.P_HSEL1_SIZE(P_HSEL1_SIZE)
       ,.P_HSEL2_START(P_HSEL2_START),.P_HSEL2_SIZE(P_HSEL2_SIZE)
       ,.P_HSEL3_START(P_HSEL3_START),.P_HSEL3_SIZE(P_HSEL3_SIZE)
       ,.P_HSEL4_START(P_HSEL4_START),.P_HSEL4_SIZE(P_HSEL4_SIZE)
       ,.P_HSEL5_START(P_HSEL5_START),.P_HSEL5_SIZE(P_HSEL5_SIZE)
       )
   u_ahb_decoder (
                 .HADDR(M_HADDR)
                ,.HSELd(HSELd)
                ,.HSEL0(S0_HSEL)
                ,.HSEL1(S1_HSEL)
                ,.HSEL2(S2_HSEL)
                ,.HSEL3(S3_HSEL)
                ,.HSEL4(S4_HSEL)
                ,.HSEL5(S5_HSEL)
                ,.REMAP(REMAP));
   ahb_s2m_s6 u_ahb_s2m (
                 .HRESETn(HRESETn)
                ,.HCLK   (HCLK   )
                ,.HRDATA (M_HRDATA)
                ,.HRESP  (M_HRESP )
                ,.HREADY (M_HREADY)
                ,.HSEL0  (S0_HSEL)
                ,.HRDATA0(S0_HRDATA)
                ,.HRESP0 (S0_HRESP)
                ,.HREADY0(S0_HREADY)
                ,.HSEL1  (S1_HSEL)
                ,.HRDATA1(S1_HRDATA)
                ,.HRESP1 (S1_HRESP)
                ,.HREADY1(S1_HREADY)
                ,.HSEL2  (S2_HSEL)
                ,.HRDATA2(S2_HRDATA)
                ,.HRESP2 (S2_HRESP)
                ,.HREADY2(S2_HREADY)
                ,.HSEL3  (S3_HSEL)
                ,.HRDATA3(S3_HRDATA)
                ,.HRESP3 (S3_HRESP)
                ,.HREADY3(S3_HREADY)
                ,.HSEL4  (S4_HSEL)
                ,.HRDATA4(S4_HRDATA)
                ,.HRESP4 (S4_HRESP)
                ,.HREADY4(S4_HREADY)
                ,.HSEL5  (S5_HSEL)
                ,.HRDATA5(S5_HRDATA)
                ,.HRESP5 (S5_HRESP)
                ,.HREADY5(S5_HREADY)
                ,.HSELd  (HSELd  )
                ,.HRDATAd(HRDATAd)
                ,.HRESPd (HRESPd )
                ,.HREADYd(HREADYd));
   ahb_default_slave u_ahb_default_slave (
                 .HRESETn  (HRESETn  )
                ,.HCLK     (HCLK     )
                ,.HSEL     (HSELd    )
                ,.HADDR    (S_HADDR  )
                ,.HTRANS   (S_HTRANS )
                ,.HWRITE   (S_HWRITE )
                ,.HSIZE    (S_HSIZE  )
                ,.HBURST   (S_HBURST )
                ,.HWDATA   (S_HWDATA )
                ,.HRDATA   (HRDATAd  )
                ,.HRESP    (HRESPd   )
                ,.HREADYin (S_HREADY )
                ,.HREADYout(HREADYd  ));
endmodule
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
module ahb_decoder_s6
     #(parameter P_NUM        =6
               , P_HSEL0_START=32&#x27;h00000000, P_HSEL0_SIZE=32&#x27;h10000000
               , P_HSEL0_END  =P_HSEL0_START+P_HSEL0_SIZE
               , P_HSEL1_START=32&#x27;h10000000, P_HSEL1_SIZE=32&#x27;h10000000
               , P_HSEL1_END  =P_HSEL1_START+P_HSEL1_SIZE
               , P_HSEL2_START=32&#x27;h20000000, P_HSEL2_SIZE=32&#x27;h10000000
               , P_HSEL2_END  =P_HSEL2_START+P_HSEL2_SIZE
               , P_HSEL3_START=32&#x27;h30000000, P_HSEL3_SIZE=32&#x27;h10000000
               , P_HSEL3_END  =P_HSEL3_START+P_HSEL3_SIZE
               , P_HSEL4_START=32&#x27;h40000000, P_HSEL4_SIZE=32&#x27;h10000000
               , P_HSEL4_END  =P_HSEL4_START+P_HSEL4_SIZE
               , P_HSEL5_START=32&#x27;h50000000, P_HSEL5_SIZE=32&#x27;h10000000
               , P_HSEL5_END  =P_HSEL5_START+P_HSEL5_SIZE
               )
(
       input   wire [31:0] HADDR
     , output  wire        HSELd // default slave
     , output  wire        HSEL0
     , output  wire        HSEL1
     , output  wire        HSEL2
     , output  wire        HSEL3
     , output  wire        HSEL4
     , output  wire        HSEL5
     , input   wire        REMAP
);
   wire [5:0] ihsel;
   wire       ihseld = ~|ihsel;
   assign HSELd = ihseld;
   assign HSEL0 = (REMAP) ? ihsel[1] : ihsel[0];
   assign HSEL1 = (REMAP) ? ihsel[0] : ihsel[1];
   assign HSEL2 = ihsel[2];
   assign HSEL3 = ihsel[3];
   assign HSEL4 = ihsel[4];
   assign HSEL5 = ihsel[5];
   assign ihsel[0] = ((P_NUM&gt;0)&amp;&amp;(HADDR&gt;=P_HSEL0_START)&amp;&amp;(HADDR&lt;P_HSEL0_END)) ? 1&#x27;b1 : 1&#x27;b0;
   assign ihsel[1] = ((P_NUM&gt;1)&amp;&amp;(HADDR&gt;=P_HSEL1_START)&amp;&amp;(HADDR&lt;P_HSEL1_END)) ? 1&#x27;b1 : 1&#x27;b0;
   assign ihsel[2] = ((P_NUM&gt;2)&amp;&amp;(HADDR&gt;=P_HSEL2_START)&amp;&amp;(HADDR&lt;P_HSEL2_END)) ? 1&#x27;b1 : 1&#x27;b0;
   assign ihsel[3] = ((P_NUM&gt;3)&amp;&amp;(HADDR&gt;=P_HSEL3_START)&amp;&amp;(HADDR&lt;P_HSEL3_END)) ? 1&#x27;b1 : 1&#x27;b0;
   assign ihsel[4] = ((P_NUM&gt;4)&amp;&amp;(HADDR&gt;=P_HSEL4_START)&amp;&amp;(HADDR&lt;P_HSEL4_END)) ? 1&#x27;b1 : 1&#x27;b0;
   assign ihsel[5] = ((P_NUM&gt;5)&amp;&amp;(HADDR&gt;=P_HSEL5_START)&amp;&amp;(HADDR&lt;P_HSEL5_END)) ? 1&#x27;b1 : 1&#x27;b0;
   `ifdef RIGOR
   // synthesis translate_off
   initial begin
       if (P_HSEL0_SIZE==0) $display(&quot;%m ERROR P_HSEL0_SIZE should be positive 32-bit&quot;);
       if (P_HSEL1_SIZE==0) $display(&quot;%m ERROR P_HSEL1_SIZE should be positive 32-bit&quot;);
       if (P_HSEL2_SIZE==0) $display(&quot;%m ERROR P_HSEL2_SIZE should be positive 32-bit&quot;);
       if (P_HSEL3_SIZE==0) $display(&quot;%m ERROR P_HSEL3_SIZE should be positive 32-bit&quot;);
       if (P_HSEL4_SIZE==0) $display(&quot;%m ERROR P_HSEL4_SIZE should be positive 32-bit&quot;);
       if (P_HSEL5_SIZE==0) $display(&quot;%m ERROR P_HSEL5_SIZE should be positive 32-bit&quot;);
       if ((P_HSEL0_END&gt;P_HSEL1_START)&amp;&amp;
           (P_HSEL0_END&lt;=P_HSEL1_END)) $display(&quot;%m ERROR address range overlapped 0:1&quot;);
       if ((P_HSEL0_END&gt;P_HSEL2_START)&amp;&amp;
           (P_HSEL0_END&lt;=P_HSEL2_END)) $display(&quot;%m ERROR address range overlapped 0:2&quot;);
       if ((P_HSEL0_END&gt;P_HSEL3_START)&amp;&amp;
           (P_HSEL0_END&lt;=P_HSEL3_END)) $display(&quot;%m ERROR address range overlapped 0:3&quot;);
       if ((P_HSEL0_END&gt;P_HSEL4_START)&amp;&amp;
           (P_HSEL0_END&lt;=P_HSEL4_END)) $display(&quot;%m ERROR address range overlapped 0:4&quot;);
       if ((P_HSEL0_END&gt;P_HSEL5_START)&amp;&amp;
           (P_HSEL0_END&lt;=P_HSEL5_END)) $display(&quot;%m ERROR address range overlapped 0:5&quot;);
       if ((P_HSEL1_END&gt;P_HSEL0_START)&amp;&amp;
           (P_HSEL1_END&lt;=P_HSEL0_END)) $display(&quot;%m ERROR address range overlapped 1:0&quot;);
       if ((P_HSEL1_END&gt;P_HSEL2_START)&amp;&amp;
           (P_HSEL1_END&lt;=P_HSEL2_END)) $display(&quot;%m ERROR address range overlapped 1:2&quot;);
       if ((P_HSEL1_END&gt;P_HSEL3_START)&amp;&amp;
           (P_HSEL1_END&lt;=P_HSEL3_END)) $display(&quot;%m ERROR address range overlapped 1:3&quot;);
       if ((P_HSEL1_END&gt;P_HSEL4_START)&amp;&amp;
           (P_HSEL1_END&lt;=P_HSEL4_END)) $display(&quot;%m ERROR address range overlapped 1:4&quot;);
       if ((P_HSEL1_END&gt;P_HSEL5_START)&amp;&amp;
           (P_HSEL1_END&lt;=P_HSEL5_END)) $display(&quot;%m ERROR address range overlapped 1:5&quot;);
       if ((P_HSEL2_END&gt;P_HSEL0_START)&amp;&amp;
           (P_HSEL2_END&lt;=P_HSEL0_END)) $display(&quot;%m ERROR address range overlapped 2:0&quot;);
       if ((P_HSEL2_END&gt;P_HSEL1_START)&amp;&amp;
           (P_HSEL2_END&lt;=P_HSEL1_END)) $display(&quot;%m ERROR address range overlapped 2:1&quot;);
       if ((P_HSEL2_END&gt;P_HSEL3_START)&amp;&amp;
           (P_HSEL2_END&lt;=P_HSEL3_END)) $display(&quot;%m ERROR address range overlapped 2:3&quot;);
       if ((P_HSEL2_END&gt;P_HSEL4_START)&amp;&amp;
           (P_HSEL2_END&lt;=P_HSEL4_END)) $display(&quot;%m ERROR address range overlapped 2:4&quot;);
       if ((P_HSEL2_END&gt;P_HSEL5_START)&amp;&amp;
           (P_HSEL2_END&lt;=P_HSEL5_END)) $display(&quot;%m ERROR address range overlapped 2:5&quot;);
       if ((P_HSEL3_END&gt;P_HSEL0_START)&amp;&amp;
           (P_HSEL3_END&lt;=P_HSEL0_END)) $display(&quot;%m ERROR address range overlapped 3:0&quot;);
       if ((P_HSEL3_END&gt;P_HSEL1_START)&amp;&amp;
           (P_HSEL3_END&lt;=P_HSEL1_END)) $display(&quot;%m ERROR address range overlapped 3:1&quot;);
       if ((P_HSEL3_END&gt;P_HSEL2_START)&amp;&amp;
           (P_HSEL3_END&lt;=P_HSEL2_END)) $display(&quot;%m ERROR address range overlapped 3:2&quot;);
       if ((P_HSEL3_END&gt;P_HSEL4_START)&amp;&amp;
           (P_HSEL3_END&lt;=P_HSEL4_END)) $display(&quot;%m ERROR address range overlapped 3:4&quot;);
       if ((P_HSEL3_END&gt;P_HSEL5_START)&amp;&amp;
           (P_HSEL3_END&lt;=P_HSEL5_END)) $display(&quot;%m ERROR address range overlapped 3:5&quot;);
       if ((P_HSEL4_END&gt;P_HSEL0_START)&amp;&amp;
           (P_HSEL4_END&lt;=P_HSEL0_END)) $display(&quot;%m ERROR address range overlapped 4:0&quot;);
       if ((P_HSEL4_END&gt;P_HSEL1_START)&amp;&amp;
           (P_HSEL4_END&lt;=P_HSEL1_END)) $display(&quot;%m ERROR address range overlapped 4:1&quot;);
       if ((P_HSEL4_END&gt;P_HSEL2_START)&amp;&amp;
           (P_HSEL4_END&lt;=P_HSEL2_END)) $display(&quot;%m ERROR address range overlapped 4:2&quot;);
       if ((P_HSEL4_END&gt;P_HSEL3_START)&amp;&amp;
           (P_HSEL4_END&lt;=P_HSEL3_END)) $display(&quot;%m ERROR address range overlapped 4:3&quot;);
       if ((P_HSEL4_END&gt;P_HSEL5_START)&amp;&amp;
           (P_HSEL4_END&lt;=P_HSEL5_END)) $display(&quot;%m ERROR address range overlapped 4:5&quot;);
       if ((P_HSEL5_END&gt;P_HSEL0_START)&amp;&amp;
           (P_HSEL5_END&lt;=P_HSEL0_END)) $display(&quot;%m ERROR address range overlapped 5:0&quot;);
       if ((P_HSEL5_END&gt;P_HSEL1_START)&amp;&amp;
           (P_HSEL5_END&lt;=P_HSEL1_END)) $display(&quot;%m ERROR address range overlapped 5:1&quot;);
       if ((P_HSEL5_END&gt;P_HSEL2_START)&amp;&amp;
           (P_HSEL5_END&lt;=P_HSEL2_END)) $display(&quot;%m ERROR address range overlapped 5:2&quot;);
       if ((P_HSEL5_END&gt;P_HSEL3_START)&amp;&amp;
           (P_HSEL5_END&lt;=P_HSEL3_END)) $display(&quot;%m ERROR address range overlapped 5:3&quot;);
       if ((P_HSEL5_END&gt;P_HSEL4_START)&amp;&amp;
           (P_HSEL5_END&lt;=P_HSEL4_END)) $display(&quot;%m ERROR address range overlapped 5:4&quot;);
   end
   // synthesis translate_on
   `endif
endmodule
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
module ahb_s2m_s6
(
       input   wire         HRESETn
     , input   wire         HCLK
     , input   wire         HSELd
     , input   wire         HSEL0
     , input   wire         HSEL1
     , input   wire         HSEL2
     , input   wire         HSEL3
     , input   wire         HSEL4
     , input   wire         HSEL5
     , output  reg   [31:0] HRDATA
     , output  reg   [ 1:0] HRESP
     , output  reg          HREADY
     , input   wire  [31:0] HRDATA0
     , input   wire  [ 1:0] HRESP0
     , input   wire         HREADY0
     , input   wire  [31:0] HRDATA1
     , input   wire  [ 1:0] HRESP1
     , input   wire         HREADY1
     , input   wire  [31:0] HRDATA2
     , input   wire  [ 1:0] HRESP2
     , input   wire         HREADY2
     , input   wire  [31:0] HRDATA3
     , input   wire  [ 1:0] HRESP3
     , input   wire         HREADY3
     , input   wire  [31:0] HRDATA4
     , input   wire  [ 1:0] HRESP4
     , input   wire         HREADY4
     , input   wire  [31:0] HRDATA5
     , input   wire  [ 1:0] HRESP5
     , input   wire         HREADY5
     , input   wire  [31:0] HRDATAd
     , input   wire  [ 1:0] HRESPd
     , input   wire         HREADYd
);
  localparam D_HSEL0 = 7&#x27;h1;
  localparam D_HSEL1 = 7&#x27;h2;
  localparam D_HSEL2 = 7&#x27;h4;
  localparam D_HSEL3 = 7&#x27;h8;
  localparam D_HSEL4 = 7&#x27;h10;
  localparam D_HSEL5 = 7&#x27;h20;
  localparam D_HSELd = 7&#x27;h40;
  wire [6:0] _hsel = {HSELd,HSEL5,HSEL4,HSEL3,HSEL2,HSEL1,HSEL0};
  reg  [6:0] _hsel_reg;
  always @ (posedge HCLK or negedge HRESETn) begin
    if (HRESETn==1&#x27;b0)   _hsel_reg &lt;= 7&#x27;h0;
    else if(HREADY) _hsel_reg &lt;= _hsel; // default HREADY must be 1&#x27;b1
  end
  always @ (_hsel_reg or HREADYd or HREADY0 or HREADY1 or HREADY2 or HREADY3 or HREADY4 or HREADY5) begin
    case(_hsel_reg)
      D_HSEL0: HREADY = HREADY0;
      D_HSEL1: HREADY = HREADY1;
      D_HSEL2: HREADY = HREADY2;
      D_HSEL3: HREADY = HREADY3;
      D_HSEL4: HREADY = HREADY4;
      D_HSEL5: HREADY = HREADY5;
      D_HSELd: HREADY = HREADYd;
      default: HREADY = 1&#x27;b1;
    endcase
  end
  always @ (_hsel_reg or HRDATAd or HRDATA0 or HRDATA1 or HRDATA2 or HRDATA3 or HRDATA4 or HRDATA5) begin
    case(_hsel_reg)
      D_HSEL0: HRDATA = HRDATA0;
      D_HSEL1: HRDATA = HRDATA1;
      D_HSEL2: HRDATA = HRDATA2;
      D_HSEL3: HRDATA = HRDATA3;
      D_HSEL4: HRDATA = HRDATA4;
      D_HSEL5: HRDATA = HRDATA5;
      D_HSELd: HRDATA = HRDATAd;
      default: HRDATA = 32&#x27;b0;
    endcase
  end
  always @ (_hsel_reg or HRESPd or HRESP0 or HRESP1 or HRESP2 or HRESP3 or HRESP4 or HRESP5) begin
    case(_hsel_reg)
      D_HSEL0: HRESP = HRESP0;
      D_HSEL1: HRESP = HRESP1;
      D_HSEL2: HRESP = HRESP2;
      D_HSEL3: HRESP = HRESP3;
      D_HSEL4: HRESP = HRESP4;
      D_HSEL5: HRESP = HRESP5;
      D_HSELd: HRESP = HRESPd;
      default: HRESP = 2&#x27;b01; //`HRESP_ERROR;
    endcase
  end
endmodule
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
`ifndef AHB_DEFAULT_SLAVE_V
`define AHB_DEFAULT_SLAVE_V
module ahb_default_slave
(
       input   wire         HRESETn
     , input   wire         HCLK
     , input   wire         HSEL
     , input   wire  [31:0] HADDR
     , input   wire  [ 1:0] HTRANS
     , input   wire         HWRITE
     , input   wire  [ 3:0] HSIZE
     , input   wire  [ 2:0] HBURST
     , input   wire  [31:0] HWDATA
     , output  wire  [31:0] HRDATA
     , output  reg   [ 1:0] HRESP
     , input   wire         HREADYin
     , output  reg          HREADYout
);
   assign HRDATA = 32&#x27;h0;
   localparam STH_IDLE   = 2&#x27;h0
            , STH_WRITE  = 2&#x27;h1
            , STH_READ0  = 2&#x27;h2;
   reg [1:0] state=STH_IDLE;
   always @ (posedge HCLK or negedge HRESETn) begin
       if (HRESETn==0) begin
           HRESP     &lt;= 2&#x27;b00; 
           HREADYout &lt;= 1&#x27;b1;
           state     &lt;= STH_IDLE;
       end else begin 
           case (state)
           STH_IDLE: begin
                if (HSEL &amp;&amp; HREADYin) begin
                   case (HTRANS)
                   2&#x27;b00, 2&#x27;b01: begin
                          HREADYout &lt;= 1&#x27;b1;
                          HRESP     &lt;= 2&#x27;b00; //`HRESP_OKAY;
                          state     &lt;= STH_IDLE;
                    end // HTRANS_IDLE or HTRANS_BUSY
                   2&#x27;b10, 2&#x27;b11: begin
                          HREADYout &lt;= 1&#x27;b0;
                          HRESP     &lt;= 2&#x27;b01; //`HRESP_ERROR;
                          if (HWRITE) begin
                              state &lt;= STH_WRITE;
                          end else begin
                              state &lt;= STH_READ0;
                          end
                    end // HTRANS_NONSEQ or HTRANS_SEQ
                   endcase // HTRANS
                end else begin// if (HSEL &amp;&amp; HREADYin)
                    HREADYout &lt;= 1&#x27;b1;
                    HRESP     &lt;= 2&#x27;b00; //`HRESP_OKAY;
                end
                end // STH_IDLE
           STH_WRITE: begin
                     HREADYout &lt;= 1&#x27;b1;
                     HRESP     &lt;= 2&#x27;b01; //`HRESP_ERROR;
                     state     &lt;= STH_IDLE;
                end // STH_WRITE
           STH_READ0: begin
                    HREADYout &lt;= 1&#x27;b1;
                    HRESP     &lt;= 2&#x27;b01; //`HRESP_ERROR;
                    state     &lt;= STH_IDLE;
                end // STH_READ0
           endcase // state
       end // if (HRESETn==0)
   end // always
endmodule
`endif
//---------------------------------------------------------------------------
/* Copyright 2018 Ando Ki (andoki@gmail.com)

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>AHB/APB bus top (arm_bus_top.sv)</summary>
      <div class="code-content"><pre><code>// apb_top.sv
// Top-level module for APB bus.

module arm_bus_top #(
    parameter AW = 16
) 
(
    input   wire        HRESETn,
    input   wire        HCLK,

    //CV32E40P
    input   wire [31:0] ADDR,
    input   wire        WE, // write enable
    input   wire        REQUST, // enable
    input   wire [31:0] WDATA, // write data
    input   wire [ 3:0] SIZE, // can be connected to byte enable signal

    output  reg  [31:0] RDATA, // read data
    output  reg         GRANT, // grant signal 
    output  reg         RVALID, // rvalid signal 
    output              ERROR,
    
    //dmem
    output       [3:0]  data_size,

    output       [AW-1:0] data_A,
    output       [31:0] data_D,
    output              data_CEN,
    output              data_WEN,
    input        [31:0] data_Q,

    //GPIO
    output	[12:0]	GPIO_PADDR,
    output	[31:0]	GPIO_PWDATA,
    output		GPIO_PWRITE,
    output		GPIO_PENABLE,
    output	[2:0]	GPIO_PSEL,
    input	[31:0]	GPIO_PRDATA,    

    //UART
    output	[12:0]	UART_PADDR,
    output	[31:0]	UART_PWDATA,
    output		UART_PWRITE,
    output		UART_PENABLE,
    output	[2:0]	UART_PSEL,
    input	[31:0]	UART_PRDATA,


    //SPI
    output      [12:0]  SPI_PADDR,
    output      [31:0]  SPI_PWDATA,
    output              SPI_PWRITE,
    output              SPI_PENABLE,
    output      [2:0]   SPI_PSEL,
    input       [31:0]  SPI_PRDATA,

    //I2C
    output      [12:0] I2C_PADDR,
    output	[31:0] I2C_PWDATA,
    output	       I2C_PWRITE,
    output             I2C_PENABLE,
    output	[2:0]  I2C_PSEL,
    input	[31:0] I2C_PRDATA,

    //timers
    output      [12:0] TIMER_PADDR,
    output      [31:0] TIMER_PWDATA,
    output             TIMER_PWRITE,
    output	       TIMER_PENABLE,
    output      [2:0]  TIMER_PSEL,
    input       [31:0] TIMER_PRDATA

);

    wire         M_HBUSREQ;

    wire         M_HGRANT;
    wire  [31:0] M_HADDR;
    wire  [ 1:0] M_HTRANS;
    wire         M_HWRITE;
    wire  [ 3:0] M_HSIZE;
    wire  [ 2:0] M_HBURST;
    wire  [ 3:0] M_HPROT;
    wire  [31:0] M_HWDATA;


    wire  [31:0] M_HRDATA;
    wire  [ 1:0] M_HRESP;
    wire         M_HREADY;

    wire  [31:0] S_HADDR;
    wire  [ 1:0] S_HTRANS;
    wire  [ 3:0] S_HSIZE;
    wire  [ 2:0] S_HBURST;
    wire  [ 3:0] S_HPROT;
    wire         S_HWRITE;
    wire  [31:0] S_HWDATA;
    wire         S_HREADY;

    wire         S0_HSEL;
    wire         S0_HREADY;
    wire  [ 1:0] S0_HRESP;
    wire  [31:0] S0_HRDATA;



    wire         S1_HSEL;
    wire         S1_HREADY;
    wire  [ 1:0] S1_HRESP;
    wire  [31:0] S1_HRDATA;


    wire         S2_HSEL;
    wire         S2_HREADY;
    wire  [ 1:0] S2_HRESP;
    wire  [31:0] S2_HRDATA;



    wire         S3_HSEL;
    wire         S3_HREADY;
    wire  [ 1:0] S3_HRESP;
    wire  [31:0] S3_HRDATA;

    wire         S4_HSEL;
    wire         S4_HREADY;
    wire  [ 1:0] S4_HRESP;
    wire  [31:0] S4_HRDATA;

    wire         S5_HSEL;
    wire         S5_HREADY;
    wire  [ 1:0] S5_HRESP;
    wire  [31:0] S5_HRDATA;


    wire         REMAP;


    amba_ahb_m1s6 u_amba_ahb_m1s6 (
       .HRESETn		(HRESETn	),	//input
       .HCLK		(HCLK   	),	//input
       .M_HADDR		(M_HADDR  	),	//input
       .M_HTRANS	(M_HTRANS 	),	//input
       .M_HSIZE		(M_HSIZE  	),	//input
       .M_HBURST	(M_HBURST 	),	//input
       .M_HPROT		(M_HPROT  	),	//input
       .M_HWRITE	(M_HWRITE 	),	//input
       .M_HWDATA	(M_HWDATA 	),	//input                               	                                  	
       .M_HRDATA	(M_HRDATA  	),
       .M_HRESP		(M_HRESP	),
       .M_HREADY	(M_HREADY  	),
                                   
       .S_HADDR		(S_HADDR	),
       .S_HWRITE	(S_HWRITE  	),
       .S_HTRANS	(S_HTRANS  	),
       .S_HSIZE		(S_HSIZE	),
       .S_HBURST	(S_HBURST  	),
       .S_HWDATA	(S_HWDATA  	),
       .S_HPROT		(S_HPROT	),
       .S_HREADY	(S_HREADY  	),


                                   
       .S0_HSEL		(S0_HSEL	),
       .S0_HREADY	(S0_HREADY 	),
       .S0_HRESP	(S0_HRESP  	),
       .S0_HRDATA	(S0_HRDATA 	),
     
                                   	
       .S1_HSEL		(S1_HSEL        ),
       .S1_HREADY	(S1_HREADY 	),
       .S1_HRESP	(S1_HRESP  	),
       .S1_HRDATA	(S1_HRDATA 	),
   
                                   	
       .S2_HSEL		(S2_HSEL        ),
       .S2_HREADY	(S2_HREADY 	),
       .S2_HRESP	(S2_HRESP  	),
       .S2_HRDATA	(S2_HRDATA 	),
 

       .S3_HSEL		(S3_HSEL        ),
       .S3_HREADY	(S3_HREADY 	),
       .S3_HRESP	(S3_HRESP  	),
       .S3_HRDATA	(S3_HRDATA 	),


       .S4_HSEL		(S4_HSEL        ),
       .S4_HREADY	(S4_HREADY 	),
       .S4_HRESP	(S4_HRESP  	),
       .S4_HRDATA	(S4_HRDATA 	),

       .S5_HSEL		(S5_HSEL        ),
       .S5_HREADY	(S5_HREADY 	),
       .S5_HRESP	(S5_HRESP  	),
       .S5_HRDATA	(S5_HRDATA 	),





       .REMAP		(1&#x27;b0	  	) // always 1&#x27;b0
);


    LSU_master u_LSU_master (
        .HRESETn    ( HRESETn   ),	//input
        .HCLK       ( HCLK      ),	//input	 

	//Connect to core 
        .ADDR       ( ADDR      ),	//input to core
        .WE         ( WE        ),	//input to core
        .REQUST     ( REQUST    ),	//input to core
        .WDATA      ( WDATA     ),	//input to core
        //.SIZE       ( 3&#x27;b010    ),            
        .SIZE       ( SIZE      ),	//input to core
        .RDATA      ( RDATA     ),	//output to core
        .GRANT      ( GRANT     ),	//output to core
        .RVALID     ( RVALID    ),	//output to core
        .ERROR      ( ERROR     ),	//output to core

	//Connect to AHB bus


        .HADDR      ( M_HADDR   ),	//output
        .HTRANS     ( M_HTRANS  ),	//output
        .HWRITE     ( M_HWRITE  ),	//output
        .HSIZE      ( M_HSIZE   ),	//output
        .HBURST     ( M_HBURST  ),	//output
        .HPROT      ( M_HPROT   ),	//output
        .HWDATA     ( M_HWDATA  ),	//output
        .HRDATA     ( M_HRDATA  ),	//input
        .HRESP      ( M_HRESP   ),	//input
        .HREADY     ( M_HREADY  ) 	//input
    );

   dmem_slave #(.AW(AW) ) u_dmem_slave (
        //Connect to AHB bus
        .HRESETn    ( HRESETn   ),
        .HCLK       ( HCLK      ),
        .HSEL       ( S0_HSEL   ),
        .HADDR      ( S_HADDR   ),
        .HTRANS     ( S_HTRANS  ),
        .HWRITE     ( S_HWRITE  ),
        .HSIZE      ( S_HSIZE   ),
        .HBURST     ( S_HBURST  ),
        .HPROT      ( S_HPROT   ),
        .HWDATA     ( S_HWDATA  ),
        .HRDATA     ( S0_HRDATA ),
        .HRESP      ( S0_HRESP  ),
        .HREADY     ( S_HREADY  ),
        .HREADYOUT  ( S0_HREADY ),

        //Connect to dmem
        .SIZE       ( data_size ),
        .A          ( data_A    ),
        .D          ( data_D    ),
        .CEN        ( data_CEN  ),
        .WEN        ( data_WEN  ),
        .Q          ( data_Q    )
    );


 AHB_APB_brig u_AHB_APB_2_GPIO (
	//Connect to AHB bus
	.HADDR		( S_HADDR ),
	.HWDATA		( S_HWDATA ),
	.HTRANS		( S_HTRANS ),
	.HREADYin	( S_HREADY ),
	.HWRITE		( S_HWRITE ),
	.HRESP		( S1_HRESP ),
	.HRDATA		( S1_HRDATA ),
	.HREADYout	( S1_HREADY ),
	.HSIZE		( S_HSIZE[2:0] ),
	.HRESETn	( HRESETn ),
	.HCLK		( HCLK ),
        
	.HSEL     	( S1_HSEL   ),
	.H_BE		( S_HSIZE	),
	
	//Connect to AHB_APB_brig  -&gt; GPIO
	.PADDR		( GPIO_PADDR ),
	.PWDATA		( GPIO_PWDATA ),
	.PSEL		( GPIO_PSEL ),
	.PWRITE		( GPIO_PWRITE ),
	.PENABLE	( GPIO_PENABLE ),
	.PRDATA		( GPIO_PRDATA )
    );


    AHB_APB_brig u_AHB_APB_2_UART (
	//Connect to AHB bus
	.HADDR		( S_HADDR ),
	.HWDATA		( S_HWDATA ),
	.HTRANS		( S_HTRANS ),
	.HREADYin	( S_HREADY ),
	.HWRITE		( S_HWRITE ),
	.HRESP		( S2_HRESP ),
	.HRDATA		( S2_HRDATA ),
	.HREADYout	( S2_HREADY ),
	.HSIZE		( S_HSIZE[2:0] ),
	.HRESETn	( HRESETn ),
	.HCLK		( HCLK ),
        
	.HSEL     	( S2_HSEL   ),
	.H_BE		( S_HSIZE	),
	
	//Connect to AHB_APB_brig  -&gt; UART
	.PADDR		( UART_PADDR ),
	.PWDATA		( UART_PWDATA ),
	.PSEL		( UART_PSEL ),
	.PWRITE		( UART_PWRITE ),
	.PENABLE	( UART_PENABLE ),
	.PRDATA		( UART_PRDATA )
    );


    AHB_APB_brig u_AHB_APB_2_SPI (
        //Connect to AHB bus
        .HADDR          ( S_HADDR ),
        .HWDATA         ( S_HWDATA ),
        .HTRANS         ( S_HTRANS ),
        .HREADYin       ( S_HREADY ),
        .HWRITE         ( S_HWRITE ),
        .HRESP          ( S3_HRESP ),
        .HRDATA         ( S3_HRDATA ),
        .HREADYout      ( S3_HREADY ),
        .HSIZE          ( S_HSIZE[2:0] ),
        .HRESETn        ( HRESETn ),
        .HCLK           ( HCLK ),

        .HSEL           ( S3_HSEL   ),
        .H_BE           ( S_HSIZE       ),

        //Connect to AHB_APB_brig  -&gt; SPI
        .PADDR          ( SPI_PADDR ),
        .PWDATA         ( SPI_PWDATA ),
        .PSEL           ( SPI_PSEL ),
        .PWRITE         ( SPI_PWRITE ),
        .PENABLE        ( SPI_PENABLE ),
	.PRDATA		( SPI_PRDATA  )
    );

 AHB_APB_brig u_AHB_APB_2_I2C (
        //Connect to AHB bus
        .HADDR          ( S_HADDR ),
        .HWDATA         ( S_HWDATA ),
        .HTRANS         ( S_HTRANS ),
        .HREADYin       ( S_HREADY ),
        .HWRITE         ( S_HWRITE ),
        .HRESP          ( S4_HRESP ),
        .HRDATA         ( S4_HRDATA ),
        .HREADYout      ( S4_HREADY ),
        .HSIZE          ( S_HSIZE[2:0] ),
        .HRESETn        ( HRESETn ),
        .HCLK           ( HCLK ),

        .HSEL           ( S4_HSEL   ),
        .H_BE           ( S_HSIZE       ),

        //Connect to AHB_APB_brig  -&gt;I2C
        .PADDR          ( I2C_PADDR ),
        .PWDATA         ( I2C_PWDATA ),
        .PSEL           ( I2C_PSEL ),
        .PWRITE         ( I2C_PWRITE ),
        .PENABLE        ( I2C_PENABLE ),
	.PRDATA		( I2C_PRDATA  )
    );

 AHB_APB_brig u_AHB_APB_2_TIMER (
        //Connect to AHB bus
        .HADDR          ( S_HADDR ),
        .HWDATA         ( S_HWDATA ),
        .HTRANS         ( S_HTRANS ),
        .HREADYin       ( S_HREADY ),
        .HWRITE         ( S_HWRITE ),
        .HRESP          ( S5_HRESP ),
        .HRDATA         ( S5_HRDATA ),
        .HREADYout      ( S5_HREADY ),
        .HSIZE          ( S_HSIZE[2:0] ),
        .HRESETn        ( HRESETn ),
        .HCLK           ( HCLK ),

        .HSEL           ( S5_HSEL   ),
        .H_BE           ( S_HSIZE       ),

        //Connect to AHB_APB_brig  -&gt; TIMER
        .PADDR          ( TIMER_PADDR ),
        .PWDATA         ( TIMER_PWDATA ),
        .PSEL           ( TIMER_PSEL ),
        .PWRITE         ( TIMER_PWRITE ),
        .PENABLE        ( TIMER_PENABLE ),
	.PRDATA		( TIMER_PRDATA  )
    );

endmodule
</code></pre></div>
    </details>

<h4>Peripherals</h4>
<p>
<strong>SPI</strong><br>
The first of the peripherals is SPI (Serial Peripheral Interface). SPI is a high-speed, full-duplex, synchronous serial communication protocol commonly used for data transmission between microcontrollers and peripherals. In our design, we use the open-source SPI from Pulp-Platform Group to connect with the display.
</p>

<p>
<strong>UART</strong><br>
The second of the peripherals is UART (Universal Asynchronous Receiver/Transmitter). UART is an asynchronous serial communication protocol used for data transmission between devices. UART enables communication without a clock signal, where the transmitter and receiver synchronize data transmission based on a predefined baud rate. It uses separate transmit (TX) and receive (RX) signals, allowing simultaneous data transmission and reception. The data follows the Start bit - Data bits - Parity bit - Stop bit format.
</p>

<p>
<strong>GPIO</strong><br>
The third of the peripherals is GPIO (General-Purpose Input/Output). The GPIO module is designed to facilitate basic communication with external devices through 8 GPIO pins. On the output path, each pin is controlled by a simple register, which is updated whenever a write request is received from the bus. On the input path, a synchronizer composed of two back-to-back registers is implemented to prevent metastability. This ensures reliable input capture even under asynchronous conditions. When the processor issues a read request, the synchronizer's output value for the relevant pin is sent to the bus. This streamlined GPIO module balances simplicity and functionality, making it suitable for the proposed chip’s requirements.
</p>

<p>
  <strong>I2C</strong><br>
The fourth peripheral is I2C (Inter-Integrated Circuit). Our design integrates an open-source I2C master controller to enable communication between devices using just two lines: SDA (data) and SCL (clock). The master handles operations like start, stop, read, and write, while also monitoring the bus status and managing multi-master arbitration. I2C has efficient pin usage, ability to support multiple peripherals through unique addresses, and compatibility with a wide range of low-speed devices like sensors and EEPROMs.
</p>

<p>
  <strong>Timer</strong><br>
The last peripheral is a set of timers. The timer is a versatile module designed to manage timing operations, generate events, and control pulse-width modulation (PWM). It supports both count-up and count-down modes and can operate with sawtooth or triangle wave counting patterns. Timers synchronize events based on internal or external clock signals, making them suitable for various system control tasks such as delays, periodic interrupts, and signal generation. The timer configuration includes start and end counters, prescaler settings, and multiple compare channels. It generates interrupt or event signals upon matching the configured thresholds, enabling seamless integration into time-sensitive applications.
</p>

    <h4>DFT Components</h4>
<p>
  <strong>Scan Chain</strong><br>
  The chip integrates a unified scan chain consisting of 248 scan cells, enabling full controllability and observability of key internal signals during DFT (Design-for-Test) and silicon bring-up. The scan chain forms a single linear shift register that spans across modules including the instruction memory interface, data memory interface, clock generator, and the debug FSM.
  <br>
  <br>
  The 248 scan cells connect a wide range of internal signals, including:
  <ul>
<li>IMEM signals: IMEM control, address, write enable, read and write data.</li>
<li>DMEM signals: DMEM control, address, write enable, read and write data.</li>
<li>Clock generator control signals.</li>
<li>Debug FSM control and status signals.</li>
</ul>
</p>
<p>
These signals are flattened into a single contiguous scan path:<br>
   <img src="../images/nanologic/scanchain.png" alt="System block diagram" style="display:block; margin:0 auto; width:60%; height:auto;">
   <p class="caption">Figure 5. Scan Chain</p>
</p>

    <details class="code-block">
      <summary>Scan chain (scan_chain.v)</summary>
      <div class="code-content"><pre><code>//Scan chain module
module scan_chain(i_imem_rdata, i_dmem_rdata, sc_en_cnt, sc_clkgen_fc, sc_clkgen_div, sc_imem_ctrl, sc_imem_req, sc_imem_addr, sc_imem_wen, sc_imem_wdata, sc_imem_clk, sc_dmem_ctrl, sc_dmem_req, sc_dmem_addr, sc_dmem_wen, sc_dmem_ben, sc_dmem_wdata, sc_dmem_clk, sc_fsm_mode, sc_fsm_indef, sc_fsm_cycle, phi, phib, scan_i0o1, load, scan_in, scan_out, phi_out, phib_out, scan_i0o1_out, load_out, VDD, VSS );
input [31:0] i_imem_rdata;
input [31:0] i_dmem_rdata;
output sc_en_cnt;
output [4:0] sc_clkgen_fc;
output [3:0] sc_clkgen_div;
output sc_imem_ctrl;
output sc_imem_req;
output [31:0] sc_imem_addr;
output sc_imem_wen;
output [31:0] sc_imem_wdata;
output sc_imem_clk;
output sc_dmem_ctrl;
output sc_dmem_req;
output [31:0] sc_dmem_addr;
output sc_dmem_wen;
output [3:0] sc_dmem_ben;
output [31:0] sc_dmem_wdata;
output sc_dmem_clk;
output sc_fsm_mode;
output sc_fsm_indef;
output [31:0] sc_fsm_cycle;
wire [247:0] phi_int, phib_int, scan_i0o1_int, load_int, scan_int;
input phi, phib, scan_i0o1, load, scan_in;
output phi_out, phib_out, scan_i0o1_out, load_out;
output scan_out;
inout VDD, VSS;

so_bit scan_cell_0_0(.VDD(VDD),.VSS(VSS),.phi(phi),.phib(phib),
.scan_i0o1(scan_i0o1),.load(load),.scan_in(scan_in),
.chip_out(i_imem_rdata[0]),
.phi_out(phi_int[0]),.phib_out(phib_int[0]),.scan_i0o1_out(scan_i0o1_int[0]),
.load_out(load_int[0]),.scan_out(scan_int[0]));


so_bit scan_cell_0_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[0]),.phib(phib_int[0]),
.scan_i0o1(scan_i0o1_int[0]),.load(load_int[0]),.scan_in(scan_int[0]),
.chip_out(i_imem_rdata[1]),
.phi_out(phi_int[1]),.phib_out(phib_int[1]),.scan_i0o1_out(scan_i0o1_int[1]),
.load_out(load_int[1]),.scan_out(scan_int[1]));


so_bit scan_cell_0_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[1]),.phib(phib_int[1]),
.scan_i0o1(scan_i0o1_int[1]),.load(load_int[1]),.scan_in(scan_int[1]),
.chip_out(i_imem_rdata[2]),
.phi_out(phi_int[2]),.phib_out(phib_int[2]),.scan_i0o1_out(scan_i0o1_int[2]),
.load_out(load_int[2]),.scan_out(scan_int[2]));


so_bit scan_cell_0_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[2]),.phib(phib_int[2]),
.scan_i0o1(scan_i0o1_int[2]),.load(load_int[2]),.scan_in(scan_int[2]),
.chip_out(i_imem_rdata[3]),
.phi_out(phi_int[3]),.phib_out(phib_int[3]),.scan_i0o1_out(scan_i0o1_int[3]),
.load_out(load_int[3]),.scan_out(scan_int[3]));


so_bit scan_cell_0_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[3]),.phib(phib_int[3]),
.scan_i0o1(scan_i0o1_int[3]),.load(load_int[3]),.scan_in(scan_int[3]),
.chip_out(i_imem_rdata[4]),
.phi_out(phi_int[4]),.phib_out(phib_int[4]),.scan_i0o1_out(scan_i0o1_int[4]),
.load_out(load_int[4]),.scan_out(scan_int[4]));


so_bit scan_cell_0_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[4]),.phib(phib_int[4]),
.scan_i0o1(scan_i0o1_int[4]),.load(load_int[4]),.scan_in(scan_int[4]),
.chip_out(i_imem_rdata[5]),
.phi_out(phi_int[5]),.phib_out(phib_int[5]),.scan_i0o1_out(scan_i0o1_int[5]),
.load_out(load_int[5]),.scan_out(scan_int[5]));


so_bit scan_cell_0_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[5]),.phib(phib_int[5]),
.scan_i0o1(scan_i0o1_int[5]),.load(load_int[5]),.scan_in(scan_int[5]),
.chip_out(i_imem_rdata[6]),
.phi_out(phi_int[6]),.phib_out(phib_int[6]),.scan_i0o1_out(scan_i0o1_int[6]),
.load_out(load_int[6]),.scan_out(scan_int[6]));


so_bit scan_cell_0_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[6]),.phib(phib_int[6]),
.scan_i0o1(scan_i0o1_int[6]),.load(load_int[6]),.scan_in(scan_int[6]),
.chip_out(i_imem_rdata[7]),
.phi_out(phi_int[7]),.phib_out(phib_int[7]),.scan_i0o1_out(scan_i0o1_int[7]),
.load_out(load_int[7]),.scan_out(scan_int[7]));


so_bit scan_cell_0_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[7]),.phib(phib_int[7]),
.scan_i0o1(scan_i0o1_int[7]),.load(load_int[7]),.scan_in(scan_int[7]),
.chip_out(i_imem_rdata[8]),
.phi_out(phi_int[8]),.phib_out(phib_int[8]),.scan_i0o1_out(scan_i0o1_int[8]),
.load_out(load_int[8]),.scan_out(scan_int[8]));


so_bit scan_cell_0_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[8]),.phib(phib_int[8]),
.scan_i0o1(scan_i0o1_int[8]),.load(load_int[8]),.scan_in(scan_int[8]),
.chip_out(i_imem_rdata[9]),
.phi_out(phi_int[9]),.phib_out(phib_int[9]),.scan_i0o1_out(scan_i0o1_int[9]),
.load_out(load_int[9]),.scan_out(scan_int[9]));


so_bit scan_cell_0_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[9]),.phib(phib_int[9]),
.scan_i0o1(scan_i0o1_int[9]),.load(load_int[9]),.scan_in(scan_int[9]),
.chip_out(i_imem_rdata[10]),
.phi_out(phi_int[10]),.phib_out(phib_int[10]),.scan_i0o1_out(scan_i0o1_int[10]),
.load_out(load_int[10]),.scan_out(scan_int[10]));


so_bit scan_cell_0_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[10]),.phib(phib_int[10]),
.scan_i0o1(scan_i0o1_int[10]),.load(load_int[10]),.scan_in(scan_int[10]),
.chip_out(i_imem_rdata[11]),
.phi_out(phi_int[11]),.phib_out(phib_int[11]),.scan_i0o1_out(scan_i0o1_int[11]),
.load_out(load_int[11]),.scan_out(scan_int[11]));


so_bit scan_cell_0_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[11]),.phib(phib_int[11]),
.scan_i0o1(scan_i0o1_int[11]),.load(load_int[11]),.scan_in(scan_int[11]),
.chip_out(i_imem_rdata[12]),
.phi_out(phi_int[12]),.phib_out(phib_int[12]),.scan_i0o1_out(scan_i0o1_int[12]),
.load_out(load_int[12]),.scan_out(scan_int[12]));


so_bit scan_cell_0_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[12]),.phib(phib_int[12]),
.scan_i0o1(scan_i0o1_int[12]),.load(load_int[12]),.scan_in(scan_int[12]),
.chip_out(i_imem_rdata[13]),
.phi_out(phi_int[13]),.phib_out(phib_int[13]),.scan_i0o1_out(scan_i0o1_int[13]),
.load_out(load_int[13]),.scan_out(scan_int[13]));


so_bit scan_cell_0_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[13]),.phib(phib_int[13]),
.scan_i0o1(scan_i0o1_int[13]),.load(load_int[13]),.scan_in(scan_int[13]),
.chip_out(i_imem_rdata[14]),
.phi_out(phi_int[14]),.phib_out(phib_int[14]),.scan_i0o1_out(scan_i0o1_int[14]),
.load_out(load_int[14]),.scan_out(scan_int[14]));


so_bit scan_cell_0_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[14]),.phib(phib_int[14]),
.scan_i0o1(scan_i0o1_int[14]),.load(load_int[14]),.scan_in(scan_int[14]),
.chip_out(i_imem_rdata[15]),
.phi_out(phi_int[15]),.phib_out(phib_int[15]),.scan_i0o1_out(scan_i0o1_int[15]),
.load_out(load_int[15]),.scan_out(scan_int[15]));


so_bit scan_cell_0_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[15]),.phib(phib_int[15]),
.scan_i0o1(scan_i0o1_int[15]),.load(load_int[15]),.scan_in(scan_int[15]),
.chip_out(i_imem_rdata[16]),
.phi_out(phi_int[16]),.phib_out(phib_int[16]),.scan_i0o1_out(scan_i0o1_int[16]),
.load_out(load_int[16]),.scan_out(scan_int[16]));


so_bit scan_cell_0_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[16]),.phib(phib_int[16]),
.scan_i0o1(scan_i0o1_int[16]),.load(load_int[16]),.scan_in(scan_int[16]),
.chip_out(i_imem_rdata[17]),
.phi_out(phi_int[17]),.phib_out(phib_int[17]),.scan_i0o1_out(scan_i0o1_int[17]),
.load_out(load_int[17]),.scan_out(scan_int[17]));


so_bit scan_cell_0_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[17]),.phib(phib_int[17]),
.scan_i0o1(scan_i0o1_int[17]),.load(load_int[17]),.scan_in(scan_int[17]),
.chip_out(i_imem_rdata[18]),
.phi_out(phi_int[18]),.phib_out(phib_int[18]),.scan_i0o1_out(scan_i0o1_int[18]),
.load_out(load_int[18]),.scan_out(scan_int[18]));


so_bit scan_cell_0_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[18]),.phib(phib_int[18]),
.scan_i0o1(scan_i0o1_int[18]),.load(load_int[18]),.scan_in(scan_int[18]),
.chip_out(i_imem_rdata[19]),
.phi_out(phi_int[19]),.phib_out(phib_int[19]),.scan_i0o1_out(scan_i0o1_int[19]),
.load_out(load_int[19]),.scan_out(scan_int[19]));


so_bit scan_cell_0_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[19]),.phib(phib_int[19]),
.scan_i0o1(scan_i0o1_int[19]),.load(load_int[19]),.scan_in(scan_int[19]),
.chip_out(i_imem_rdata[20]),
.phi_out(phi_int[20]),.phib_out(phib_int[20]),.scan_i0o1_out(scan_i0o1_int[20]),
.load_out(load_int[20]),.scan_out(scan_int[20]));


so_bit scan_cell_0_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[20]),.phib(phib_int[20]),
.scan_i0o1(scan_i0o1_int[20]),.load(load_int[20]),.scan_in(scan_int[20]),
.chip_out(i_imem_rdata[21]),
.phi_out(phi_int[21]),.phib_out(phib_int[21]),.scan_i0o1_out(scan_i0o1_int[21]),
.load_out(load_int[21]),.scan_out(scan_int[21]));


so_bit scan_cell_0_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[21]),.phib(phib_int[21]),
.scan_i0o1(scan_i0o1_int[21]),.load(load_int[21]),.scan_in(scan_int[21]),
.chip_out(i_imem_rdata[22]),
.phi_out(phi_int[22]),.phib_out(phib_int[22]),.scan_i0o1_out(scan_i0o1_int[22]),
.load_out(load_int[22]),.scan_out(scan_int[22]));


so_bit scan_cell_0_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[22]),.phib(phib_int[22]),
.scan_i0o1(scan_i0o1_int[22]),.load(load_int[22]),.scan_in(scan_int[22]),
.chip_out(i_imem_rdata[23]),
.phi_out(phi_int[23]),.phib_out(phib_int[23]),.scan_i0o1_out(scan_i0o1_int[23]),
.load_out(load_int[23]),.scan_out(scan_int[23]));


so_bit scan_cell_0_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[23]),.phib(phib_int[23]),
.scan_i0o1(scan_i0o1_int[23]),.load(load_int[23]),.scan_in(scan_int[23]),
.chip_out(i_imem_rdata[24]),
.phi_out(phi_int[24]),.phib_out(phib_int[24]),.scan_i0o1_out(scan_i0o1_int[24]),
.load_out(load_int[24]),.scan_out(scan_int[24]));


so_bit scan_cell_0_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[24]),.phib(phib_int[24]),
.scan_i0o1(scan_i0o1_int[24]),.load(load_int[24]),.scan_in(scan_int[24]),
.chip_out(i_imem_rdata[25]),
.phi_out(phi_int[25]),.phib_out(phib_int[25]),.scan_i0o1_out(scan_i0o1_int[25]),
.load_out(load_int[25]),.scan_out(scan_int[25]));


so_bit scan_cell_0_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[25]),.phib(phib_int[25]),
.scan_i0o1(scan_i0o1_int[25]),.load(load_int[25]),.scan_in(scan_int[25]),
.chip_out(i_imem_rdata[26]),
.phi_out(phi_int[26]),.phib_out(phib_int[26]),.scan_i0o1_out(scan_i0o1_int[26]),
.load_out(load_int[26]),.scan_out(scan_int[26]));


so_bit scan_cell_0_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[26]),.phib(phib_int[26]),
.scan_i0o1(scan_i0o1_int[26]),.load(load_int[26]),.scan_in(scan_int[26]),
.chip_out(i_imem_rdata[27]),
.phi_out(phi_int[27]),.phib_out(phib_int[27]),.scan_i0o1_out(scan_i0o1_int[27]),
.load_out(load_int[27]),.scan_out(scan_int[27]));


so_bit scan_cell_0_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[27]),.phib(phib_int[27]),
.scan_i0o1(scan_i0o1_int[27]),.load(load_int[27]),.scan_in(scan_int[27]),
.chip_out(i_imem_rdata[28]),
.phi_out(phi_int[28]),.phib_out(phib_int[28]),.scan_i0o1_out(scan_i0o1_int[28]),
.load_out(load_int[28]),.scan_out(scan_int[28]));


so_bit scan_cell_0_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[28]),.phib(phib_int[28]),
.scan_i0o1(scan_i0o1_int[28]),.load(load_int[28]),.scan_in(scan_int[28]),
.chip_out(i_imem_rdata[29]),
.phi_out(phi_int[29]),.phib_out(phib_int[29]),.scan_i0o1_out(scan_i0o1_int[29]),
.load_out(load_int[29]),.scan_out(scan_int[29]));


so_bit scan_cell_0_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[29]),.phib(phib_int[29]),
.scan_i0o1(scan_i0o1_int[29]),.load(load_int[29]),.scan_in(scan_int[29]),
.chip_out(i_imem_rdata[30]),
.phi_out(phi_int[30]),.phib_out(phib_int[30]),.scan_i0o1_out(scan_i0o1_int[30]),
.load_out(load_int[30]),.scan_out(scan_int[30]));


so_bit scan_cell_0_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[30]),.phib(phib_int[30]),
.scan_i0o1(scan_i0o1_int[30]),.load(load_int[30]),.scan_in(scan_int[30]),
.chip_out(i_imem_rdata[31]),
.phi_out(phi_int[31]),.phib_out(phib_int[31]),.scan_i0o1_out(scan_i0o1_int[31]),
.load_out(load_int[31]),.scan_out(scan_int[31]));


so_bit scan_cell_1_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[31]),.phib(phib_int[31]),
.scan_i0o1(scan_i0o1_int[31]),.load(load_int[31]),.scan_in(scan_int[31]),
.chip_out(i_dmem_rdata[0]),
.phi_out(phi_int[32]),.phib_out(phib_int[32]),.scan_i0o1_out(scan_i0o1_int[32]),
.load_out(load_int[32]),.scan_out(scan_int[32]));


so_bit scan_cell_1_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[32]),.phib(phib_int[32]),
.scan_i0o1(scan_i0o1_int[32]),.load(load_int[32]),.scan_in(scan_int[32]),
.chip_out(i_dmem_rdata[1]),
.phi_out(phi_int[33]),.phib_out(phib_int[33]),.scan_i0o1_out(scan_i0o1_int[33]),
.load_out(load_int[33]),.scan_out(scan_int[33]));


so_bit scan_cell_1_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[33]),.phib(phib_int[33]),
.scan_i0o1(scan_i0o1_int[33]),.load(load_int[33]),.scan_in(scan_int[33]),
.chip_out(i_dmem_rdata[2]),
.phi_out(phi_int[34]),.phib_out(phib_int[34]),.scan_i0o1_out(scan_i0o1_int[34]),
.load_out(load_int[34]),.scan_out(scan_int[34]));


so_bit scan_cell_1_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[34]),.phib(phib_int[34]),
.scan_i0o1(scan_i0o1_int[34]),.load(load_int[34]),.scan_in(scan_int[34]),
.chip_out(i_dmem_rdata[3]),
.phi_out(phi_int[35]),.phib_out(phib_int[35]),.scan_i0o1_out(scan_i0o1_int[35]),
.load_out(load_int[35]),.scan_out(scan_int[35]));


so_bit scan_cell_1_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[35]),.phib(phib_int[35]),
.scan_i0o1(scan_i0o1_int[35]),.load(load_int[35]),.scan_in(scan_int[35]),
.chip_out(i_dmem_rdata[4]),
.phi_out(phi_int[36]),.phib_out(phib_int[36]),.scan_i0o1_out(scan_i0o1_int[36]),
.load_out(load_int[36]),.scan_out(scan_int[36]));


so_bit scan_cell_1_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[36]),.phib(phib_int[36]),
.scan_i0o1(scan_i0o1_int[36]),.load(load_int[36]),.scan_in(scan_int[36]),
.chip_out(i_dmem_rdata[5]),
.phi_out(phi_int[37]),.phib_out(phib_int[37]),.scan_i0o1_out(scan_i0o1_int[37]),
.load_out(load_int[37]),.scan_out(scan_int[37]));


so_bit scan_cell_1_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[37]),.phib(phib_int[37]),
.scan_i0o1(scan_i0o1_int[37]),.load(load_int[37]),.scan_in(scan_int[37]),
.chip_out(i_dmem_rdata[6]),
.phi_out(phi_int[38]),.phib_out(phib_int[38]),.scan_i0o1_out(scan_i0o1_int[38]),
.load_out(load_int[38]),.scan_out(scan_int[38]));


so_bit scan_cell_1_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[38]),.phib(phib_int[38]),
.scan_i0o1(scan_i0o1_int[38]),.load(load_int[38]),.scan_in(scan_int[38]),
.chip_out(i_dmem_rdata[7]),
.phi_out(phi_int[39]),.phib_out(phib_int[39]),.scan_i0o1_out(scan_i0o1_int[39]),
.load_out(load_int[39]),.scan_out(scan_int[39]));


so_bit scan_cell_1_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[39]),.phib(phib_int[39]),
.scan_i0o1(scan_i0o1_int[39]),.load(load_int[39]),.scan_in(scan_int[39]),
.chip_out(i_dmem_rdata[8]),
.phi_out(phi_int[40]),.phib_out(phib_int[40]),.scan_i0o1_out(scan_i0o1_int[40]),
.load_out(load_int[40]),.scan_out(scan_int[40]));


so_bit scan_cell_1_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[40]),.phib(phib_int[40]),
.scan_i0o1(scan_i0o1_int[40]),.load(load_int[40]),.scan_in(scan_int[40]),
.chip_out(i_dmem_rdata[9]),
.phi_out(phi_int[41]),.phib_out(phib_int[41]),.scan_i0o1_out(scan_i0o1_int[41]),
.load_out(load_int[41]),.scan_out(scan_int[41]));


so_bit scan_cell_1_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[41]),.phib(phib_int[41]),
.scan_i0o1(scan_i0o1_int[41]),.load(load_int[41]),.scan_in(scan_int[41]),
.chip_out(i_dmem_rdata[10]),
.phi_out(phi_int[42]),.phib_out(phib_int[42]),.scan_i0o1_out(scan_i0o1_int[42]),
.load_out(load_int[42]),.scan_out(scan_int[42]));


so_bit scan_cell_1_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[42]),.phib(phib_int[42]),
.scan_i0o1(scan_i0o1_int[42]),.load(load_int[42]),.scan_in(scan_int[42]),
.chip_out(i_dmem_rdata[11]),
.phi_out(phi_int[43]),.phib_out(phib_int[43]),.scan_i0o1_out(scan_i0o1_int[43]),
.load_out(load_int[43]),.scan_out(scan_int[43]));


so_bit scan_cell_1_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[43]),.phib(phib_int[43]),
.scan_i0o1(scan_i0o1_int[43]),.load(load_int[43]),.scan_in(scan_int[43]),
.chip_out(i_dmem_rdata[12]),
.phi_out(phi_int[44]),.phib_out(phib_int[44]),.scan_i0o1_out(scan_i0o1_int[44]),
.load_out(load_int[44]),.scan_out(scan_int[44]));


so_bit scan_cell_1_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[44]),.phib(phib_int[44]),
.scan_i0o1(scan_i0o1_int[44]),.load(load_int[44]),.scan_in(scan_int[44]),
.chip_out(i_dmem_rdata[13]),
.phi_out(phi_int[45]),.phib_out(phib_int[45]),.scan_i0o1_out(scan_i0o1_int[45]),
.load_out(load_int[45]),.scan_out(scan_int[45]));


so_bit scan_cell_1_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[45]),.phib(phib_int[45]),
.scan_i0o1(scan_i0o1_int[45]),.load(load_int[45]),.scan_in(scan_int[45]),
.chip_out(i_dmem_rdata[14]),
.phi_out(phi_int[46]),.phib_out(phib_int[46]),.scan_i0o1_out(scan_i0o1_int[46]),
.load_out(load_int[46]),.scan_out(scan_int[46]));


so_bit scan_cell_1_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[46]),.phib(phib_int[46]),
.scan_i0o1(scan_i0o1_int[46]),.load(load_int[46]),.scan_in(scan_int[46]),
.chip_out(i_dmem_rdata[15]),
.phi_out(phi_int[47]),.phib_out(phib_int[47]),.scan_i0o1_out(scan_i0o1_int[47]),
.load_out(load_int[47]),.scan_out(scan_int[47]));


so_bit scan_cell_1_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[47]),.phib(phib_int[47]),
.scan_i0o1(scan_i0o1_int[47]),.load(load_int[47]),.scan_in(scan_int[47]),
.chip_out(i_dmem_rdata[16]),
.phi_out(phi_int[48]),.phib_out(phib_int[48]),.scan_i0o1_out(scan_i0o1_int[48]),
.load_out(load_int[48]),.scan_out(scan_int[48]));


so_bit scan_cell_1_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[48]),.phib(phib_int[48]),
.scan_i0o1(scan_i0o1_int[48]),.load(load_int[48]),.scan_in(scan_int[48]),
.chip_out(i_dmem_rdata[17]),
.phi_out(phi_int[49]),.phib_out(phib_int[49]),.scan_i0o1_out(scan_i0o1_int[49]),
.load_out(load_int[49]),.scan_out(scan_int[49]));


so_bit scan_cell_1_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[49]),.phib(phib_int[49]),
.scan_i0o1(scan_i0o1_int[49]),.load(load_int[49]),.scan_in(scan_int[49]),
.chip_out(i_dmem_rdata[18]),
.phi_out(phi_int[50]),.phib_out(phib_int[50]),.scan_i0o1_out(scan_i0o1_int[50]),
.load_out(load_int[50]),.scan_out(scan_int[50]));


so_bit scan_cell_1_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[50]),.phib(phib_int[50]),
.scan_i0o1(scan_i0o1_int[50]),.load(load_int[50]),.scan_in(scan_int[50]),
.chip_out(i_dmem_rdata[19]),
.phi_out(phi_int[51]),.phib_out(phib_int[51]),.scan_i0o1_out(scan_i0o1_int[51]),
.load_out(load_int[51]),.scan_out(scan_int[51]));


so_bit scan_cell_1_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[51]),.phib(phib_int[51]),
.scan_i0o1(scan_i0o1_int[51]),.load(load_int[51]),.scan_in(scan_int[51]),
.chip_out(i_dmem_rdata[20]),
.phi_out(phi_int[52]),.phib_out(phib_int[52]),.scan_i0o1_out(scan_i0o1_int[52]),
.load_out(load_int[52]),.scan_out(scan_int[52]));


so_bit scan_cell_1_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[52]),.phib(phib_int[52]),
.scan_i0o1(scan_i0o1_int[52]),.load(load_int[52]),.scan_in(scan_int[52]),
.chip_out(i_dmem_rdata[21]),
.phi_out(phi_int[53]),.phib_out(phib_int[53]),.scan_i0o1_out(scan_i0o1_int[53]),
.load_out(load_int[53]),.scan_out(scan_int[53]));


so_bit scan_cell_1_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[53]),.phib(phib_int[53]),
.scan_i0o1(scan_i0o1_int[53]),.load(load_int[53]),.scan_in(scan_int[53]),
.chip_out(i_dmem_rdata[22]),
.phi_out(phi_int[54]),.phib_out(phib_int[54]),.scan_i0o1_out(scan_i0o1_int[54]),
.load_out(load_int[54]),.scan_out(scan_int[54]));


so_bit scan_cell_1_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[54]),.phib(phib_int[54]),
.scan_i0o1(scan_i0o1_int[54]),.load(load_int[54]),.scan_in(scan_int[54]),
.chip_out(i_dmem_rdata[23]),
.phi_out(phi_int[55]),.phib_out(phib_int[55]),.scan_i0o1_out(scan_i0o1_int[55]),
.load_out(load_int[55]),.scan_out(scan_int[55]));


so_bit scan_cell_1_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[55]),.phib(phib_int[55]),
.scan_i0o1(scan_i0o1_int[55]),.load(load_int[55]),.scan_in(scan_int[55]),
.chip_out(i_dmem_rdata[24]),
.phi_out(phi_int[56]),.phib_out(phib_int[56]),.scan_i0o1_out(scan_i0o1_int[56]),
.load_out(load_int[56]),.scan_out(scan_int[56]));


so_bit scan_cell_1_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[56]),.phib(phib_int[56]),
.scan_i0o1(scan_i0o1_int[56]),.load(load_int[56]),.scan_in(scan_int[56]),
.chip_out(i_dmem_rdata[25]),
.phi_out(phi_int[57]),.phib_out(phib_int[57]),.scan_i0o1_out(scan_i0o1_int[57]),
.load_out(load_int[57]),.scan_out(scan_int[57]));


so_bit scan_cell_1_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[57]),.phib(phib_int[57]),
.scan_i0o1(scan_i0o1_int[57]),.load(load_int[57]),.scan_in(scan_int[57]),
.chip_out(i_dmem_rdata[26]),
.phi_out(phi_int[58]),.phib_out(phib_int[58]),.scan_i0o1_out(scan_i0o1_int[58]),
.load_out(load_int[58]),.scan_out(scan_int[58]));


so_bit scan_cell_1_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[58]),.phib(phib_int[58]),
.scan_i0o1(scan_i0o1_int[58]),.load(load_int[58]),.scan_in(scan_int[58]),
.chip_out(i_dmem_rdata[27]),
.phi_out(phi_int[59]),.phib_out(phib_int[59]),.scan_i0o1_out(scan_i0o1_int[59]),
.load_out(load_int[59]),.scan_out(scan_int[59]));


so_bit scan_cell_1_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[59]),.phib(phib_int[59]),
.scan_i0o1(scan_i0o1_int[59]),.load(load_int[59]),.scan_in(scan_int[59]),
.chip_out(i_dmem_rdata[28]),
.phi_out(phi_int[60]),.phib_out(phib_int[60]),.scan_i0o1_out(scan_i0o1_int[60]),
.load_out(load_int[60]),.scan_out(scan_int[60]));


so_bit scan_cell_1_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[60]),.phib(phib_int[60]),
.scan_i0o1(scan_i0o1_int[60]),.load(load_int[60]),.scan_in(scan_int[60]),
.chip_out(i_dmem_rdata[29]),
.phi_out(phi_int[61]),.phib_out(phib_int[61]),.scan_i0o1_out(scan_i0o1_int[61]),
.load_out(load_int[61]),.scan_out(scan_int[61]));


so_bit scan_cell_1_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[61]),.phib(phib_int[61]),
.scan_i0o1(scan_i0o1_int[61]),.load(load_int[61]),.scan_in(scan_int[61]),
.chip_out(i_dmem_rdata[30]),
.phi_out(phi_int[62]),.phib_out(phib_int[62]),.scan_i0o1_out(scan_i0o1_int[62]),
.load_out(load_int[62]),.scan_out(scan_int[62]));


so_bit scan_cell_1_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[62]),.phib(phib_int[62]),
.scan_i0o1(scan_i0o1_int[62]),.load(load_int[62]),.scan_in(scan_int[62]),
.chip_out(i_dmem_rdata[31]),
.phi_out(phi_int[63]),.phib_out(phib_int[63]),.scan_i0o1_out(scan_i0o1_int[63]),
.load_out(load_int[63]),.scan_out(scan_int[63]));


si_bit scan_cell_2_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[63]),.phib(phib_int[63]),
.scan_i0o1(scan_i0o1_int[63]),.load(load_int[63]),.scan_in(scan_int[63]),
.phi_out(phi_int[64]),.phib_out(phib_int[64]),.scan_i0o1_out(scan_i0o1_int[64]),
.load_out(load_int[64]),.scan_out(scan_int[64]),.chip_in(sc_en_cnt));


si_bit scan_cell_3_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[64]),.phib(phib_int[64]),
.scan_i0o1(scan_i0o1_int[64]),.load(load_int[64]),.scan_in(scan_int[64]),
.phi_out(phi_int[65]),.phib_out(phib_int[65]),.scan_i0o1_out(scan_i0o1_int[65]),
.load_out(load_int[65]),.scan_out(scan_int[65]),.chip_in(sc_clkgen_fc[0]));


si_bit scan_cell_3_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[65]),.phib(phib_int[65]),
.scan_i0o1(scan_i0o1_int[65]),.load(load_int[65]),.scan_in(scan_int[65]),
.phi_out(phi_int[66]),.phib_out(phib_int[66]),.scan_i0o1_out(scan_i0o1_int[66]),
.load_out(load_int[66]),.scan_out(scan_int[66]),.chip_in(sc_clkgen_fc[1]));


si_bit scan_cell_3_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[66]),.phib(phib_int[66]),
.scan_i0o1(scan_i0o1_int[66]),.load(load_int[66]),.scan_in(scan_int[66]),
.phi_out(phi_int[67]),.phib_out(phib_int[67]),.scan_i0o1_out(scan_i0o1_int[67]),
.load_out(load_int[67]),.scan_out(scan_int[67]),.chip_in(sc_clkgen_fc[2]));


si_bit scan_cell_3_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[67]),.phib(phib_int[67]),
.scan_i0o1(scan_i0o1_int[67]),.load(load_int[67]),.scan_in(scan_int[67]),
.phi_out(phi_int[68]),.phib_out(phib_int[68]),.scan_i0o1_out(scan_i0o1_int[68]),
.load_out(load_int[68]),.scan_out(scan_int[68]),.chip_in(sc_clkgen_fc[3]));


si_bit scan_cell_3_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[68]),.phib(phib_int[68]),
.scan_i0o1(scan_i0o1_int[68]),.load(load_int[68]),.scan_in(scan_int[68]),
.phi_out(phi_int[69]),.phib_out(phib_int[69]),.scan_i0o1_out(scan_i0o1_int[69]),
.load_out(load_int[69]),.scan_out(scan_int[69]),.chip_in(sc_clkgen_fc[4]));


si_bit scan_cell_4_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[69]),.phib(phib_int[69]),
.scan_i0o1(scan_i0o1_int[69]),.load(load_int[69]),.scan_in(scan_int[69]),
.phi_out(phi_int[70]),.phib_out(phib_int[70]),.scan_i0o1_out(scan_i0o1_int[70]),
.load_out(load_int[70]),.scan_out(scan_int[70]),.chip_in(sc_clkgen_div[0]));


si_bit scan_cell_4_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[70]),.phib(phib_int[70]),
.scan_i0o1(scan_i0o1_int[70]),.load(load_int[70]),.scan_in(scan_int[70]),
.phi_out(phi_int[71]),.phib_out(phib_int[71]),.scan_i0o1_out(scan_i0o1_int[71]),
.load_out(load_int[71]),.scan_out(scan_int[71]),.chip_in(sc_clkgen_div[1]));


si_bit scan_cell_4_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[71]),.phib(phib_int[71]),
.scan_i0o1(scan_i0o1_int[71]),.load(load_int[71]),.scan_in(scan_int[71]),
.phi_out(phi_int[72]),.phib_out(phib_int[72]),.scan_i0o1_out(scan_i0o1_int[72]),
.load_out(load_int[72]),.scan_out(scan_int[72]),.chip_in(sc_clkgen_div[2]));


si_bit scan_cell_4_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[72]),.phib(phib_int[72]),
.scan_i0o1(scan_i0o1_int[72]),.load(load_int[72]),.scan_in(scan_int[72]),
.phi_out(phi_int[73]),.phib_out(phib_int[73]),.scan_i0o1_out(scan_i0o1_int[73]),
.load_out(load_int[73]),.scan_out(scan_int[73]),.chip_in(sc_clkgen_div[3]));


si_bit scan_cell_5_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[73]),.phib(phib_int[73]),
.scan_i0o1(scan_i0o1_int[73]),.load(load_int[73]),.scan_in(scan_int[73]),
.phi_out(phi_int[74]),.phib_out(phib_int[74]),.scan_i0o1_out(scan_i0o1_int[74]),
.load_out(load_int[74]),.scan_out(scan_int[74]),.chip_in(sc_imem_ctrl));


si_bit scan_cell_6_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[74]),.phib(phib_int[74]),
.scan_i0o1(scan_i0o1_int[74]),.load(load_int[74]),.scan_in(scan_int[74]),
.phi_out(phi_int[75]),.phib_out(phib_int[75]),.scan_i0o1_out(scan_i0o1_int[75]),
.load_out(load_int[75]),.scan_out(scan_int[75]),.chip_in(sc_imem_req));


si_bit scan_cell_7_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[75]),.phib(phib_int[75]),
.scan_i0o1(scan_i0o1_int[75]),.load(load_int[75]),.scan_in(scan_int[75]),
.phi_out(phi_int[76]),.phib_out(phib_int[76]),.scan_i0o1_out(scan_i0o1_int[76]),
.load_out(load_int[76]),.scan_out(scan_int[76]),.chip_in(sc_imem_addr[0]));


si_bit scan_cell_7_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[76]),.phib(phib_int[76]),
.scan_i0o1(scan_i0o1_int[76]),.load(load_int[76]),.scan_in(scan_int[76]),
.phi_out(phi_int[77]),.phib_out(phib_int[77]),.scan_i0o1_out(scan_i0o1_int[77]),
.load_out(load_int[77]),.scan_out(scan_int[77]),.chip_in(sc_imem_addr[1]));


si_bit scan_cell_7_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[77]),.phib(phib_int[77]),
.scan_i0o1(scan_i0o1_int[77]),.load(load_int[77]),.scan_in(scan_int[77]),
.phi_out(phi_int[78]),.phib_out(phib_int[78]),.scan_i0o1_out(scan_i0o1_int[78]),
.load_out(load_int[78]),.scan_out(scan_int[78]),.chip_in(sc_imem_addr[2]));


si_bit scan_cell_7_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[78]),.phib(phib_int[78]),
.scan_i0o1(scan_i0o1_int[78]),.load(load_int[78]),.scan_in(scan_int[78]),
.phi_out(phi_int[79]),.phib_out(phib_int[79]),.scan_i0o1_out(scan_i0o1_int[79]),
.load_out(load_int[79]),.scan_out(scan_int[79]),.chip_in(sc_imem_addr[3]));


si_bit scan_cell_7_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[79]),.phib(phib_int[79]),
.scan_i0o1(scan_i0o1_int[79]),.load(load_int[79]),.scan_in(scan_int[79]),
.phi_out(phi_int[80]),.phib_out(phib_int[80]),.scan_i0o1_out(scan_i0o1_int[80]),
.load_out(load_int[80]),.scan_out(scan_int[80]),.chip_in(sc_imem_addr[4]));


si_bit scan_cell_7_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[80]),.phib(phib_int[80]),
.scan_i0o1(scan_i0o1_int[80]),.load(load_int[80]),.scan_in(scan_int[80]),
.phi_out(phi_int[81]),.phib_out(phib_int[81]),.scan_i0o1_out(scan_i0o1_int[81]),
.load_out(load_int[81]),.scan_out(scan_int[81]),.chip_in(sc_imem_addr[5]));


si_bit scan_cell_7_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[81]),.phib(phib_int[81]),
.scan_i0o1(scan_i0o1_int[81]),.load(load_int[81]),.scan_in(scan_int[81]),
.phi_out(phi_int[82]),.phib_out(phib_int[82]),.scan_i0o1_out(scan_i0o1_int[82]),
.load_out(load_int[82]),.scan_out(scan_int[82]),.chip_in(sc_imem_addr[6]));


si_bit scan_cell_7_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[82]),.phib(phib_int[82]),
.scan_i0o1(scan_i0o1_int[82]),.load(load_int[82]),.scan_in(scan_int[82]),
.phi_out(phi_int[83]),.phib_out(phib_int[83]),.scan_i0o1_out(scan_i0o1_int[83]),
.load_out(load_int[83]),.scan_out(scan_int[83]),.chip_in(sc_imem_addr[7]));


si_bit scan_cell_7_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[83]),.phib(phib_int[83]),
.scan_i0o1(scan_i0o1_int[83]),.load(load_int[83]),.scan_in(scan_int[83]),
.phi_out(phi_int[84]),.phib_out(phib_int[84]),.scan_i0o1_out(scan_i0o1_int[84]),
.load_out(load_int[84]),.scan_out(scan_int[84]),.chip_in(sc_imem_addr[8]));


si_bit scan_cell_7_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[84]),.phib(phib_int[84]),
.scan_i0o1(scan_i0o1_int[84]),.load(load_int[84]),.scan_in(scan_int[84]),
.phi_out(phi_int[85]),.phib_out(phib_int[85]),.scan_i0o1_out(scan_i0o1_int[85]),
.load_out(load_int[85]),.scan_out(scan_int[85]),.chip_in(sc_imem_addr[9]));


si_bit scan_cell_7_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[85]),.phib(phib_int[85]),
.scan_i0o1(scan_i0o1_int[85]),.load(load_int[85]),.scan_in(scan_int[85]),
.phi_out(phi_int[86]),.phib_out(phib_int[86]),.scan_i0o1_out(scan_i0o1_int[86]),
.load_out(load_int[86]),.scan_out(scan_int[86]),.chip_in(sc_imem_addr[10]));


si_bit scan_cell_7_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[86]),.phib(phib_int[86]),
.scan_i0o1(scan_i0o1_int[86]),.load(load_int[86]),.scan_in(scan_int[86]),
.phi_out(phi_int[87]),.phib_out(phib_int[87]),.scan_i0o1_out(scan_i0o1_int[87]),
.load_out(load_int[87]),.scan_out(scan_int[87]),.chip_in(sc_imem_addr[11]));


si_bit scan_cell_7_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[87]),.phib(phib_int[87]),
.scan_i0o1(scan_i0o1_int[87]),.load(load_int[87]),.scan_in(scan_int[87]),
.phi_out(phi_int[88]),.phib_out(phib_int[88]),.scan_i0o1_out(scan_i0o1_int[88]),
.load_out(load_int[88]),.scan_out(scan_int[88]),.chip_in(sc_imem_addr[12]));


si_bit scan_cell_7_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[88]),.phib(phib_int[88]),
.scan_i0o1(scan_i0o1_int[88]),.load(load_int[88]),.scan_in(scan_int[88]),
.phi_out(phi_int[89]),.phib_out(phib_int[89]),.scan_i0o1_out(scan_i0o1_int[89]),
.load_out(load_int[89]),.scan_out(scan_int[89]),.chip_in(sc_imem_addr[13]));


si_bit scan_cell_7_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[89]),.phib(phib_int[89]),
.scan_i0o1(scan_i0o1_int[89]),.load(load_int[89]),.scan_in(scan_int[89]),
.phi_out(phi_int[90]),.phib_out(phib_int[90]),.scan_i0o1_out(scan_i0o1_int[90]),
.load_out(load_int[90]),.scan_out(scan_int[90]),.chip_in(sc_imem_addr[14]));


si_bit scan_cell_7_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[90]),.phib(phib_int[90]),
.scan_i0o1(scan_i0o1_int[90]),.load(load_int[90]),.scan_in(scan_int[90]),
.phi_out(phi_int[91]),.phib_out(phib_int[91]),.scan_i0o1_out(scan_i0o1_int[91]),
.load_out(load_int[91]),.scan_out(scan_int[91]),.chip_in(sc_imem_addr[15]));


si_bit scan_cell_7_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[91]),.phib(phib_int[91]),
.scan_i0o1(scan_i0o1_int[91]),.load(load_int[91]),.scan_in(scan_int[91]),
.phi_out(phi_int[92]),.phib_out(phib_int[92]),.scan_i0o1_out(scan_i0o1_int[92]),
.load_out(load_int[92]),.scan_out(scan_int[92]),.chip_in(sc_imem_addr[16]));


si_bit scan_cell_7_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[92]),.phib(phib_int[92]),
.scan_i0o1(scan_i0o1_int[92]),.load(load_int[92]),.scan_in(scan_int[92]),
.phi_out(phi_int[93]),.phib_out(phib_int[93]),.scan_i0o1_out(scan_i0o1_int[93]),
.load_out(load_int[93]),.scan_out(scan_int[93]),.chip_in(sc_imem_addr[17]));


si_bit scan_cell_7_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[93]),.phib(phib_int[93]),
.scan_i0o1(scan_i0o1_int[93]),.load(load_int[93]),.scan_in(scan_int[93]),
.phi_out(phi_int[94]),.phib_out(phib_int[94]),.scan_i0o1_out(scan_i0o1_int[94]),
.load_out(load_int[94]),.scan_out(scan_int[94]),.chip_in(sc_imem_addr[18]));


si_bit scan_cell_7_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[94]),.phib(phib_int[94]),
.scan_i0o1(scan_i0o1_int[94]),.load(load_int[94]),.scan_in(scan_int[94]),
.phi_out(phi_int[95]),.phib_out(phib_int[95]),.scan_i0o1_out(scan_i0o1_int[95]),
.load_out(load_int[95]),.scan_out(scan_int[95]),.chip_in(sc_imem_addr[19]));


si_bit scan_cell_7_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[95]),.phib(phib_int[95]),
.scan_i0o1(scan_i0o1_int[95]),.load(load_int[95]),.scan_in(scan_int[95]),
.phi_out(phi_int[96]),.phib_out(phib_int[96]),.scan_i0o1_out(scan_i0o1_int[96]),
.load_out(load_int[96]),.scan_out(scan_int[96]),.chip_in(sc_imem_addr[20]));


si_bit scan_cell_7_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[96]),.phib(phib_int[96]),
.scan_i0o1(scan_i0o1_int[96]),.load(load_int[96]),.scan_in(scan_int[96]),
.phi_out(phi_int[97]),.phib_out(phib_int[97]),.scan_i0o1_out(scan_i0o1_int[97]),
.load_out(load_int[97]),.scan_out(scan_int[97]),.chip_in(sc_imem_addr[21]));


si_bit scan_cell_7_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[97]),.phib(phib_int[97]),
.scan_i0o1(scan_i0o1_int[97]),.load(load_int[97]),.scan_in(scan_int[97]),
.phi_out(phi_int[98]),.phib_out(phib_int[98]),.scan_i0o1_out(scan_i0o1_int[98]),
.load_out(load_int[98]),.scan_out(scan_int[98]),.chip_in(sc_imem_addr[22]));


si_bit scan_cell_7_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[98]),.phib(phib_int[98]),
.scan_i0o1(scan_i0o1_int[98]),.load(load_int[98]),.scan_in(scan_int[98]),
.phi_out(phi_int[99]),.phib_out(phib_int[99]),.scan_i0o1_out(scan_i0o1_int[99]),
.load_out(load_int[99]),.scan_out(scan_int[99]),.chip_in(sc_imem_addr[23]));


si_bit scan_cell_7_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[99]),.phib(phib_int[99]),
.scan_i0o1(scan_i0o1_int[99]),.load(load_int[99]),.scan_in(scan_int[99]),
.phi_out(phi_int[100]),.phib_out(phib_int[100]),.scan_i0o1_out(scan_i0o1_int[100]),
.load_out(load_int[100]),.scan_out(scan_int[100]),.chip_in(sc_imem_addr[24]));


si_bit scan_cell_7_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[100]),.phib(phib_int[100]),
.scan_i0o1(scan_i0o1_int[100]),.load(load_int[100]),.scan_in(scan_int[100]),
.phi_out(phi_int[101]),.phib_out(phib_int[101]),.scan_i0o1_out(scan_i0o1_int[101]),
.load_out(load_int[101]),.scan_out(scan_int[101]),.chip_in(sc_imem_addr[25]));


si_bit scan_cell_7_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[101]),.phib(phib_int[101]),
.scan_i0o1(scan_i0o1_int[101]),.load(load_int[101]),.scan_in(scan_int[101]),
.phi_out(phi_int[102]),.phib_out(phib_int[102]),.scan_i0o1_out(scan_i0o1_int[102]),
.load_out(load_int[102]),.scan_out(scan_int[102]),.chip_in(sc_imem_addr[26]));


si_bit scan_cell_7_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[102]),.phib(phib_int[102]),
.scan_i0o1(scan_i0o1_int[102]),.load(load_int[102]),.scan_in(scan_int[102]),
.phi_out(phi_int[103]),.phib_out(phib_int[103]),.scan_i0o1_out(scan_i0o1_int[103]),
.load_out(load_int[103]),.scan_out(scan_int[103]),.chip_in(sc_imem_addr[27]));


si_bit scan_cell_7_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[103]),.phib(phib_int[103]),
.scan_i0o1(scan_i0o1_int[103]),.load(load_int[103]),.scan_in(scan_int[103]),
.phi_out(phi_int[104]),.phib_out(phib_int[104]),.scan_i0o1_out(scan_i0o1_int[104]),
.load_out(load_int[104]),.scan_out(scan_int[104]),.chip_in(sc_imem_addr[28]));


si_bit scan_cell_7_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[104]),.phib(phib_int[104]),
.scan_i0o1(scan_i0o1_int[104]),.load(load_int[104]),.scan_in(scan_int[104]),
.phi_out(phi_int[105]),.phib_out(phib_int[105]),.scan_i0o1_out(scan_i0o1_int[105]),
.load_out(load_int[105]),.scan_out(scan_int[105]),.chip_in(sc_imem_addr[29]));


si_bit scan_cell_7_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[105]),.phib(phib_int[105]),
.scan_i0o1(scan_i0o1_int[105]),.load(load_int[105]),.scan_in(scan_int[105]),
.phi_out(phi_int[106]),.phib_out(phib_int[106]),.scan_i0o1_out(scan_i0o1_int[106]),
.load_out(load_int[106]),.scan_out(scan_int[106]),.chip_in(sc_imem_addr[30]));


si_bit scan_cell_7_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[106]),.phib(phib_int[106]),
.scan_i0o1(scan_i0o1_int[106]),.load(load_int[106]),.scan_in(scan_int[106]),
.phi_out(phi_int[107]),.phib_out(phib_int[107]),.scan_i0o1_out(scan_i0o1_int[107]),
.load_out(load_int[107]),.scan_out(scan_int[107]),.chip_in(sc_imem_addr[31]));


si_bit scan_cell_8_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[107]),.phib(phib_int[107]),
.scan_i0o1(scan_i0o1_int[107]),.load(load_int[107]),.scan_in(scan_int[107]),
.phi_out(phi_int[108]),.phib_out(phib_int[108]),.scan_i0o1_out(scan_i0o1_int[108]),
.load_out(load_int[108]),.scan_out(scan_int[108]),.chip_in(sc_imem_wen));


si_bit scan_cell_9_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[108]),.phib(phib_int[108]),
.scan_i0o1(scan_i0o1_int[108]),.load(load_int[108]),.scan_in(scan_int[108]),
.phi_out(phi_int[109]),.phib_out(phib_int[109]),.scan_i0o1_out(scan_i0o1_int[109]),
.load_out(load_int[109]),.scan_out(scan_int[109]),.chip_in(sc_imem_wdata[0]));


si_bit scan_cell_9_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[109]),.phib(phib_int[109]),
.scan_i0o1(scan_i0o1_int[109]),.load(load_int[109]),.scan_in(scan_int[109]),
.phi_out(phi_int[110]),.phib_out(phib_int[110]),.scan_i0o1_out(scan_i0o1_int[110]),
.load_out(load_int[110]),.scan_out(scan_int[110]),.chip_in(sc_imem_wdata[1]));


si_bit scan_cell_9_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[110]),.phib(phib_int[110]),
.scan_i0o1(scan_i0o1_int[110]),.load(load_int[110]),.scan_in(scan_int[110]),
.phi_out(phi_int[111]),.phib_out(phib_int[111]),.scan_i0o1_out(scan_i0o1_int[111]),
.load_out(load_int[111]),.scan_out(scan_int[111]),.chip_in(sc_imem_wdata[2]));


si_bit scan_cell_9_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[111]),.phib(phib_int[111]),
.scan_i0o1(scan_i0o1_int[111]),.load(load_int[111]),.scan_in(scan_int[111]),
.phi_out(phi_int[112]),.phib_out(phib_int[112]),.scan_i0o1_out(scan_i0o1_int[112]),
.load_out(load_int[112]),.scan_out(scan_int[112]),.chip_in(sc_imem_wdata[3]));


si_bit scan_cell_9_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[112]),.phib(phib_int[112]),
.scan_i0o1(scan_i0o1_int[112]),.load(load_int[112]),.scan_in(scan_int[112]),
.phi_out(phi_int[113]),.phib_out(phib_int[113]),.scan_i0o1_out(scan_i0o1_int[113]),
.load_out(load_int[113]),.scan_out(scan_int[113]),.chip_in(sc_imem_wdata[4]));


si_bit scan_cell_9_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[113]),.phib(phib_int[113]),
.scan_i0o1(scan_i0o1_int[113]),.load(load_int[113]),.scan_in(scan_int[113]),
.phi_out(phi_int[114]),.phib_out(phib_int[114]),.scan_i0o1_out(scan_i0o1_int[114]),
.load_out(load_int[114]),.scan_out(scan_int[114]),.chip_in(sc_imem_wdata[5]));


si_bit scan_cell_9_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[114]),.phib(phib_int[114]),
.scan_i0o1(scan_i0o1_int[114]),.load(load_int[114]),.scan_in(scan_int[114]),
.phi_out(phi_int[115]),.phib_out(phib_int[115]),.scan_i0o1_out(scan_i0o1_int[115]),
.load_out(load_int[115]),.scan_out(scan_int[115]),.chip_in(sc_imem_wdata[6]));


si_bit scan_cell_9_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[115]),.phib(phib_int[115]),
.scan_i0o1(scan_i0o1_int[115]),.load(load_int[115]),.scan_in(scan_int[115]),
.phi_out(phi_int[116]),.phib_out(phib_int[116]),.scan_i0o1_out(scan_i0o1_int[116]),
.load_out(load_int[116]),.scan_out(scan_int[116]),.chip_in(sc_imem_wdata[7]));


si_bit scan_cell_9_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[116]),.phib(phib_int[116]),
.scan_i0o1(scan_i0o1_int[116]),.load(load_int[116]),.scan_in(scan_int[116]),
.phi_out(phi_int[117]),.phib_out(phib_int[117]),.scan_i0o1_out(scan_i0o1_int[117]),
.load_out(load_int[117]),.scan_out(scan_int[117]),.chip_in(sc_imem_wdata[8]));


si_bit scan_cell_9_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[117]),.phib(phib_int[117]),
.scan_i0o1(scan_i0o1_int[117]),.load(load_int[117]),.scan_in(scan_int[117]),
.phi_out(phi_int[118]),.phib_out(phib_int[118]),.scan_i0o1_out(scan_i0o1_int[118]),
.load_out(load_int[118]),.scan_out(scan_int[118]),.chip_in(sc_imem_wdata[9]));


si_bit scan_cell_9_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[118]),.phib(phib_int[118]),
.scan_i0o1(scan_i0o1_int[118]),.load(load_int[118]),.scan_in(scan_int[118]),
.phi_out(phi_int[119]),.phib_out(phib_int[119]),.scan_i0o1_out(scan_i0o1_int[119]),
.load_out(load_int[119]),.scan_out(scan_int[119]),.chip_in(sc_imem_wdata[10]));


si_bit scan_cell_9_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[119]),.phib(phib_int[119]),
.scan_i0o1(scan_i0o1_int[119]),.load(load_int[119]),.scan_in(scan_int[119]),
.phi_out(phi_int[120]),.phib_out(phib_int[120]),.scan_i0o1_out(scan_i0o1_int[120]),
.load_out(load_int[120]),.scan_out(scan_int[120]),.chip_in(sc_imem_wdata[11]));


si_bit scan_cell_9_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[120]),.phib(phib_int[120]),
.scan_i0o1(scan_i0o1_int[120]),.load(load_int[120]),.scan_in(scan_int[120]),
.phi_out(phi_int[121]),.phib_out(phib_int[121]),.scan_i0o1_out(scan_i0o1_int[121]),
.load_out(load_int[121]),.scan_out(scan_int[121]),.chip_in(sc_imem_wdata[12]));


si_bit scan_cell_9_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[121]),.phib(phib_int[121]),
.scan_i0o1(scan_i0o1_int[121]),.load(load_int[121]),.scan_in(scan_int[121]),
.phi_out(phi_int[122]),.phib_out(phib_int[122]),.scan_i0o1_out(scan_i0o1_int[122]),
.load_out(load_int[122]),.scan_out(scan_int[122]),.chip_in(sc_imem_wdata[13]));


si_bit scan_cell_9_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[122]),.phib(phib_int[122]),
.scan_i0o1(scan_i0o1_int[122]),.load(load_int[122]),.scan_in(scan_int[122]),
.phi_out(phi_int[123]),.phib_out(phib_int[123]),.scan_i0o1_out(scan_i0o1_int[123]),
.load_out(load_int[123]),.scan_out(scan_int[123]),.chip_in(sc_imem_wdata[14]));


si_bit scan_cell_9_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[123]),.phib(phib_int[123]),
.scan_i0o1(scan_i0o1_int[123]),.load(load_int[123]),.scan_in(scan_int[123]),
.phi_out(phi_int[124]),.phib_out(phib_int[124]),.scan_i0o1_out(scan_i0o1_int[124]),
.load_out(load_int[124]),.scan_out(scan_int[124]),.chip_in(sc_imem_wdata[15]));


si_bit scan_cell_9_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[124]),.phib(phib_int[124]),
.scan_i0o1(scan_i0o1_int[124]),.load(load_int[124]),.scan_in(scan_int[124]),
.phi_out(phi_int[125]),.phib_out(phib_int[125]),.scan_i0o1_out(scan_i0o1_int[125]),
.load_out(load_int[125]),.scan_out(scan_int[125]),.chip_in(sc_imem_wdata[16]));


si_bit scan_cell_9_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[125]),.phib(phib_int[125]),
.scan_i0o1(scan_i0o1_int[125]),.load(load_int[125]),.scan_in(scan_int[125]),
.phi_out(phi_int[126]),.phib_out(phib_int[126]),.scan_i0o1_out(scan_i0o1_int[126]),
.load_out(load_int[126]),.scan_out(scan_int[126]),.chip_in(sc_imem_wdata[17]));


si_bit scan_cell_9_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[126]),.phib(phib_int[126]),
.scan_i0o1(scan_i0o1_int[126]),.load(load_int[126]),.scan_in(scan_int[126]),
.phi_out(phi_int[127]),.phib_out(phib_int[127]),.scan_i0o1_out(scan_i0o1_int[127]),
.load_out(load_int[127]),.scan_out(scan_int[127]),.chip_in(sc_imem_wdata[18]));


si_bit scan_cell_9_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[127]),.phib(phib_int[127]),
.scan_i0o1(scan_i0o1_int[127]),.load(load_int[127]),.scan_in(scan_int[127]),
.phi_out(phi_int[128]),.phib_out(phib_int[128]),.scan_i0o1_out(scan_i0o1_int[128]),
.load_out(load_int[128]),.scan_out(scan_int[128]),.chip_in(sc_imem_wdata[19]));


si_bit scan_cell_9_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[128]),.phib(phib_int[128]),
.scan_i0o1(scan_i0o1_int[128]),.load(load_int[128]),.scan_in(scan_int[128]),
.phi_out(phi_int[129]),.phib_out(phib_int[129]),.scan_i0o1_out(scan_i0o1_int[129]),
.load_out(load_int[129]),.scan_out(scan_int[129]),.chip_in(sc_imem_wdata[20]));


si_bit scan_cell_9_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[129]),.phib(phib_int[129]),
.scan_i0o1(scan_i0o1_int[129]),.load(load_int[129]),.scan_in(scan_int[129]),
.phi_out(phi_int[130]),.phib_out(phib_int[130]),.scan_i0o1_out(scan_i0o1_int[130]),
.load_out(load_int[130]),.scan_out(scan_int[130]),.chip_in(sc_imem_wdata[21]));


si_bit scan_cell_9_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[130]),.phib(phib_int[130]),
.scan_i0o1(scan_i0o1_int[130]),.load(load_int[130]),.scan_in(scan_int[130]),
.phi_out(phi_int[131]),.phib_out(phib_int[131]),.scan_i0o1_out(scan_i0o1_int[131]),
.load_out(load_int[131]),.scan_out(scan_int[131]),.chip_in(sc_imem_wdata[22]));


si_bit scan_cell_9_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[131]),.phib(phib_int[131]),
.scan_i0o1(scan_i0o1_int[131]),.load(load_int[131]),.scan_in(scan_int[131]),
.phi_out(phi_int[132]),.phib_out(phib_int[132]),.scan_i0o1_out(scan_i0o1_int[132]),
.load_out(load_int[132]),.scan_out(scan_int[132]),.chip_in(sc_imem_wdata[23]));


si_bit scan_cell_9_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[132]),.phib(phib_int[132]),
.scan_i0o1(scan_i0o1_int[132]),.load(load_int[132]),.scan_in(scan_int[132]),
.phi_out(phi_int[133]),.phib_out(phib_int[133]),.scan_i0o1_out(scan_i0o1_int[133]),
.load_out(load_int[133]),.scan_out(scan_int[133]),.chip_in(sc_imem_wdata[24]));


si_bit scan_cell_9_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[133]),.phib(phib_int[133]),
.scan_i0o1(scan_i0o1_int[133]),.load(load_int[133]),.scan_in(scan_int[133]),
.phi_out(phi_int[134]),.phib_out(phib_int[134]),.scan_i0o1_out(scan_i0o1_int[134]),
.load_out(load_int[134]),.scan_out(scan_int[134]),.chip_in(sc_imem_wdata[25]));


si_bit scan_cell_9_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[134]),.phib(phib_int[134]),
.scan_i0o1(scan_i0o1_int[134]),.load(load_int[134]),.scan_in(scan_int[134]),
.phi_out(phi_int[135]),.phib_out(phib_int[135]),.scan_i0o1_out(scan_i0o1_int[135]),
.load_out(load_int[135]),.scan_out(scan_int[135]),.chip_in(sc_imem_wdata[26]));


si_bit scan_cell_9_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[135]),.phib(phib_int[135]),
.scan_i0o1(scan_i0o1_int[135]),.load(load_int[135]),.scan_in(scan_int[135]),
.phi_out(phi_int[136]),.phib_out(phib_int[136]),.scan_i0o1_out(scan_i0o1_int[136]),
.load_out(load_int[136]),.scan_out(scan_int[136]),.chip_in(sc_imem_wdata[27]));


si_bit scan_cell_9_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[136]),.phib(phib_int[136]),
.scan_i0o1(scan_i0o1_int[136]),.load(load_int[136]),.scan_in(scan_int[136]),
.phi_out(phi_int[137]),.phib_out(phib_int[137]),.scan_i0o1_out(scan_i0o1_int[137]),
.load_out(load_int[137]),.scan_out(scan_int[137]),.chip_in(sc_imem_wdata[28]));


si_bit scan_cell_9_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[137]),.phib(phib_int[137]),
.scan_i0o1(scan_i0o1_int[137]),.load(load_int[137]),.scan_in(scan_int[137]),
.phi_out(phi_int[138]),.phib_out(phib_int[138]),.scan_i0o1_out(scan_i0o1_int[138]),
.load_out(load_int[138]),.scan_out(scan_int[138]),.chip_in(sc_imem_wdata[29]));


si_bit scan_cell_9_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[138]),.phib(phib_int[138]),
.scan_i0o1(scan_i0o1_int[138]),.load(load_int[138]),.scan_in(scan_int[138]),
.phi_out(phi_int[139]),.phib_out(phib_int[139]),.scan_i0o1_out(scan_i0o1_int[139]),
.load_out(load_int[139]),.scan_out(scan_int[139]),.chip_in(sc_imem_wdata[30]));


si_bit scan_cell_9_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[139]),.phib(phib_int[139]),
.scan_i0o1(scan_i0o1_int[139]),.load(load_int[139]),.scan_in(scan_int[139]),
.phi_out(phi_int[140]),.phib_out(phib_int[140]),.scan_i0o1_out(scan_i0o1_int[140]),
.load_out(load_int[140]),.scan_out(scan_int[140]),.chip_in(sc_imem_wdata[31]));


si_bit scan_cell_10_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[140]),.phib(phib_int[140]),
.scan_i0o1(scan_i0o1_int[140]),.load(load_int[140]),.scan_in(scan_int[140]),
.phi_out(phi_int[141]),.phib_out(phib_int[141]),.scan_i0o1_out(scan_i0o1_int[141]),
.load_out(load_int[141]),.scan_out(scan_int[141]),.chip_in(sc_imem_clk));


si_bit scan_cell_11_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[141]),.phib(phib_int[141]),
.scan_i0o1(scan_i0o1_int[141]),.load(load_int[141]),.scan_in(scan_int[141]),
.phi_out(phi_int[142]),.phib_out(phib_int[142]),.scan_i0o1_out(scan_i0o1_int[142]),
.load_out(load_int[142]),.scan_out(scan_int[142]),.chip_in(sc_dmem_ctrl));


si_bit scan_cell_12_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[142]),.phib(phib_int[142]),
.scan_i0o1(scan_i0o1_int[142]),.load(load_int[142]),.scan_in(scan_int[142]),
.phi_out(phi_int[143]),.phib_out(phib_int[143]),.scan_i0o1_out(scan_i0o1_int[143]),
.load_out(load_int[143]),.scan_out(scan_int[143]),.chip_in(sc_dmem_req));


si_bit scan_cell_13_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[143]),.phib(phib_int[143]),
.scan_i0o1(scan_i0o1_int[143]),.load(load_int[143]),.scan_in(scan_int[143]),
.phi_out(phi_int[144]),.phib_out(phib_int[144]),.scan_i0o1_out(scan_i0o1_int[144]),
.load_out(load_int[144]),.scan_out(scan_int[144]),.chip_in(sc_dmem_addr[0]));


si_bit scan_cell_13_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[144]),.phib(phib_int[144]),
.scan_i0o1(scan_i0o1_int[144]),.load(load_int[144]),.scan_in(scan_int[144]),
.phi_out(phi_int[145]),.phib_out(phib_int[145]),.scan_i0o1_out(scan_i0o1_int[145]),
.load_out(load_int[145]),.scan_out(scan_int[145]),.chip_in(sc_dmem_addr[1]));


si_bit scan_cell_13_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[145]),.phib(phib_int[145]),
.scan_i0o1(scan_i0o1_int[145]),.load(load_int[145]),.scan_in(scan_int[145]),
.phi_out(phi_int[146]),.phib_out(phib_int[146]),.scan_i0o1_out(scan_i0o1_int[146]),
.load_out(load_int[146]),.scan_out(scan_int[146]),.chip_in(sc_dmem_addr[2]));


si_bit scan_cell_13_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[146]),.phib(phib_int[146]),
.scan_i0o1(scan_i0o1_int[146]),.load(load_int[146]),.scan_in(scan_int[146]),
.phi_out(phi_int[147]),.phib_out(phib_int[147]),.scan_i0o1_out(scan_i0o1_int[147]),
.load_out(load_int[147]),.scan_out(scan_int[147]),.chip_in(sc_dmem_addr[3]));


si_bit scan_cell_13_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[147]),.phib(phib_int[147]),
.scan_i0o1(scan_i0o1_int[147]),.load(load_int[147]),.scan_in(scan_int[147]),
.phi_out(phi_int[148]),.phib_out(phib_int[148]),.scan_i0o1_out(scan_i0o1_int[148]),
.load_out(load_int[148]),.scan_out(scan_int[148]),.chip_in(sc_dmem_addr[4]));


si_bit scan_cell_13_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[148]),.phib(phib_int[148]),
.scan_i0o1(scan_i0o1_int[148]),.load(load_int[148]),.scan_in(scan_int[148]),
.phi_out(phi_int[149]),.phib_out(phib_int[149]),.scan_i0o1_out(scan_i0o1_int[149]),
.load_out(load_int[149]),.scan_out(scan_int[149]),.chip_in(sc_dmem_addr[5]));


si_bit scan_cell_13_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[149]),.phib(phib_int[149]),
.scan_i0o1(scan_i0o1_int[149]),.load(load_int[149]),.scan_in(scan_int[149]),
.phi_out(phi_int[150]),.phib_out(phib_int[150]),.scan_i0o1_out(scan_i0o1_int[150]),
.load_out(load_int[150]),.scan_out(scan_int[150]),.chip_in(sc_dmem_addr[6]));


si_bit scan_cell_13_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[150]),.phib(phib_int[150]),
.scan_i0o1(scan_i0o1_int[150]),.load(load_int[150]),.scan_in(scan_int[150]),
.phi_out(phi_int[151]),.phib_out(phib_int[151]),.scan_i0o1_out(scan_i0o1_int[151]),
.load_out(load_int[151]),.scan_out(scan_int[151]),.chip_in(sc_dmem_addr[7]));


si_bit scan_cell_13_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[151]),.phib(phib_int[151]),
.scan_i0o1(scan_i0o1_int[151]),.load(load_int[151]),.scan_in(scan_int[151]),
.phi_out(phi_int[152]),.phib_out(phib_int[152]),.scan_i0o1_out(scan_i0o1_int[152]),
.load_out(load_int[152]),.scan_out(scan_int[152]),.chip_in(sc_dmem_addr[8]));


si_bit scan_cell_13_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[152]),.phib(phib_int[152]),
.scan_i0o1(scan_i0o1_int[152]),.load(load_int[152]),.scan_in(scan_int[152]),
.phi_out(phi_int[153]),.phib_out(phib_int[153]),.scan_i0o1_out(scan_i0o1_int[153]),
.load_out(load_int[153]),.scan_out(scan_int[153]),.chip_in(sc_dmem_addr[9]));


si_bit scan_cell_13_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[153]),.phib(phib_int[153]),
.scan_i0o1(scan_i0o1_int[153]),.load(load_int[153]),.scan_in(scan_int[153]),
.phi_out(phi_int[154]),.phib_out(phib_int[154]),.scan_i0o1_out(scan_i0o1_int[154]),
.load_out(load_int[154]),.scan_out(scan_int[154]),.chip_in(sc_dmem_addr[10]));


si_bit scan_cell_13_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[154]),.phib(phib_int[154]),
.scan_i0o1(scan_i0o1_int[154]),.load(load_int[154]),.scan_in(scan_int[154]),
.phi_out(phi_int[155]),.phib_out(phib_int[155]),.scan_i0o1_out(scan_i0o1_int[155]),
.load_out(load_int[155]),.scan_out(scan_int[155]),.chip_in(sc_dmem_addr[11]));


si_bit scan_cell_13_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[155]),.phib(phib_int[155]),
.scan_i0o1(scan_i0o1_int[155]),.load(load_int[155]),.scan_in(scan_int[155]),
.phi_out(phi_int[156]),.phib_out(phib_int[156]),.scan_i0o1_out(scan_i0o1_int[156]),
.load_out(load_int[156]),.scan_out(scan_int[156]),.chip_in(sc_dmem_addr[12]));


si_bit scan_cell_13_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[156]),.phib(phib_int[156]),
.scan_i0o1(scan_i0o1_int[156]),.load(load_int[156]),.scan_in(scan_int[156]),
.phi_out(phi_int[157]),.phib_out(phib_int[157]),.scan_i0o1_out(scan_i0o1_int[157]),
.load_out(load_int[157]),.scan_out(scan_int[157]),.chip_in(sc_dmem_addr[13]));


si_bit scan_cell_13_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[157]),.phib(phib_int[157]),
.scan_i0o1(scan_i0o1_int[157]),.load(load_int[157]),.scan_in(scan_int[157]),
.phi_out(phi_int[158]),.phib_out(phib_int[158]),.scan_i0o1_out(scan_i0o1_int[158]),
.load_out(load_int[158]),.scan_out(scan_int[158]),.chip_in(sc_dmem_addr[14]));


si_bit scan_cell_13_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[158]),.phib(phib_int[158]),
.scan_i0o1(scan_i0o1_int[158]),.load(load_int[158]),.scan_in(scan_int[158]),
.phi_out(phi_int[159]),.phib_out(phib_int[159]),.scan_i0o1_out(scan_i0o1_int[159]),
.load_out(load_int[159]),.scan_out(scan_int[159]),.chip_in(sc_dmem_addr[15]));


si_bit scan_cell_13_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[159]),.phib(phib_int[159]),
.scan_i0o1(scan_i0o1_int[159]),.load(load_int[159]),.scan_in(scan_int[159]),
.phi_out(phi_int[160]),.phib_out(phib_int[160]),.scan_i0o1_out(scan_i0o1_int[160]),
.load_out(load_int[160]),.scan_out(scan_int[160]),.chip_in(sc_dmem_addr[16]));


si_bit scan_cell_13_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[160]),.phib(phib_int[160]),
.scan_i0o1(scan_i0o1_int[160]),.load(load_int[160]),.scan_in(scan_int[160]),
.phi_out(phi_int[161]),.phib_out(phib_int[161]),.scan_i0o1_out(scan_i0o1_int[161]),
.load_out(load_int[161]),.scan_out(scan_int[161]),.chip_in(sc_dmem_addr[17]));


si_bit scan_cell_13_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[161]),.phib(phib_int[161]),
.scan_i0o1(scan_i0o1_int[161]),.load(load_int[161]),.scan_in(scan_int[161]),
.phi_out(phi_int[162]),.phib_out(phib_int[162]),.scan_i0o1_out(scan_i0o1_int[162]),
.load_out(load_int[162]),.scan_out(scan_int[162]),.chip_in(sc_dmem_addr[18]));


si_bit scan_cell_13_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[162]),.phib(phib_int[162]),
.scan_i0o1(scan_i0o1_int[162]),.load(load_int[162]),.scan_in(scan_int[162]),
.phi_out(phi_int[163]),.phib_out(phib_int[163]),.scan_i0o1_out(scan_i0o1_int[163]),
.load_out(load_int[163]),.scan_out(scan_int[163]),.chip_in(sc_dmem_addr[19]));


si_bit scan_cell_13_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[163]),.phib(phib_int[163]),
.scan_i0o1(scan_i0o1_int[163]),.load(load_int[163]),.scan_in(scan_int[163]),
.phi_out(phi_int[164]),.phib_out(phib_int[164]),.scan_i0o1_out(scan_i0o1_int[164]),
.load_out(load_int[164]),.scan_out(scan_int[164]),.chip_in(sc_dmem_addr[20]));


si_bit scan_cell_13_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[164]),.phib(phib_int[164]),
.scan_i0o1(scan_i0o1_int[164]),.load(load_int[164]),.scan_in(scan_int[164]),
.phi_out(phi_int[165]),.phib_out(phib_int[165]),.scan_i0o1_out(scan_i0o1_int[165]),
.load_out(load_int[165]),.scan_out(scan_int[165]),.chip_in(sc_dmem_addr[21]));


si_bit scan_cell_13_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[165]),.phib(phib_int[165]),
.scan_i0o1(scan_i0o1_int[165]),.load(load_int[165]),.scan_in(scan_int[165]),
.phi_out(phi_int[166]),.phib_out(phib_int[166]),.scan_i0o1_out(scan_i0o1_int[166]),
.load_out(load_int[166]),.scan_out(scan_int[166]),.chip_in(sc_dmem_addr[22]));


si_bit scan_cell_13_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[166]),.phib(phib_int[166]),
.scan_i0o1(scan_i0o1_int[166]),.load(load_int[166]),.scan_in(scan_int[166]),
.phi_out(phi_int[167]),.phib_out(phib_int[167]),.scan_i0o1_out(scan_i0o1_int[167]),
.load_out(load_int[167]),.scan_out(scan_int[167]),.chip_in(sc_dmem_addr[23]));


si_bit scan_cell_13_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[167]),.phib(phib_int[167]),
.scan_i0o1(scan_i0o1_int[167]),.load(load_int[167]),.scan_in(scan_int[167]),
.phi_out(phi_int[168]),.phib_out(phib_int[168]),.scan_i0o1_out(scan_i0o1_int[168]),
.load_out(load_int[168]),.scan_out(scan_int[168]),.chip_in(sc_dmem_addr[24]));


si_bit scan_cell_13_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[168]),.phib(phib_int[168]),
.scan_i0o1(scan_i0o1_int[168]),.load(load_int[168]),.scan_in(scan_int[168]),
.phi_out(phi_int[169]),.phib_out(phib_int[169]),.scan_i0o1_out(scan_i0o1_int[169]),
.load_out(load_int[169]),.scan_out(scan_int[169]),.chip_in(sc_dmem_addr[25]));


si_bit scan_cell_13_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[169]),.phib(phib_int[169]),
.scan_i0o1(scan_i0o1_int[169]),.load(load_int[169]),.scan_in(scan_int[169]),
.phi_out(phi_int[170]),.phib_out(phib_int[170]),.scan_i0o1_out(scan_i0o1_int[170]),
.load_out(load_int[170]),.scan_out(scan_int[170]),.chip_in(sc_dmem_addr[26]));


si_bit scan_cell_13_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[170]),.phib(phib_int[170]),
.scan_i0o1(scan_i0o1_int[170]),.load(load_int[170]),.scan_in(scan_int[170]),
.phi_out(phi_int[171]),.phib_out(phib_int[171]),.scan_i0o1_out(scan_i0o1_int[171]),
.load_out(load_int[171]),.scan_out(scan_int[171]),.chip_in(sc_dmem_addr[27]));


si_bit scan_cell_13_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[171]),.phib(phib_int[171]),
.scan_i0o1(scan_i0o1_int[171]),.load(load_int[171]),.scan_in(scan_int[171]),
.phi_out(phi_int[172]),.phib_out(phib_int[172]),.scan_i0o1_out(scan_i0o1_int[172]),
.load_out(load_int[172]),.scan_out(scan_int[172]),.chip_in(sc_dmem_addr[28]));


si_bit scan_cell_13_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[172]),.phib(phib_int[172]),
.scan_i0o1(scan_i0o1_int[172]),.load(load_int[172]),.scan_in(scan_int[172]),
.phi_out(phi_int[173]),.phib_out(phib_int[173]),.scan_i0o1_out(scan_i0o1_int[173]),
.load_out(load_int[173]),.scan_out(scan_int[173]),.chip_in(sc_dmem_addr[29]));


si_bit scan_cell_13_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[173]),.phib(phib_int[173]),
.scan_i0o1(scan_i0o1_int[173]),.load(load_int[173]),.scan_in(scan_int[173]),
.phi_out(phi_int[174]),.phib_out(phib_int[174]),.scan_i0o1_out(scan_i0o1_int[174]),
.load_out(load_int[174]),.scan_out(scan_int[174]),.chip_in(sc_dmem_addr[30]));


si_bit scan_cell_13_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[174]),.phib(phib_int[174]),
.scan_i0o1(scan_i0o1_int[174]),.load(load_int[174]),.scan_in(scan_int[174]),
.phi_out(phi_int[175]),.phib_out(phib_int[175]),.scan_i0o1_out(scan_i0o1_int[175]),
.load_out(load_int[175]),.scan_out(scan_int[175]),.chip_in(sc_dmem_addr[31]));


si_bit scan_cell_14_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[175]),.phib(phib_int[175]),
.scan_i0o1(scan_i0o1_int[175]),.load(load_int[175]),.scan_in(scan_int[175]),
.phi_out(phi_int[176]),.phib_out(phib_int[176]),.scan_i0o1_out(scan_i0o1_int[176]),
.load_out(load_int[176]),.scan_out(scan_int[176]),.chip_in(sc_dmem_wen));


si_bit scan_cell_15_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[176]),.phib(phib_int[176]),
.scan_i0o1(scan_i0o1_int[176]),.load(load_int[176]),.scan_in(scan_int[176]),
.phi_out(phi_int[177]),.phib_out(phib_int[177]),.scan_i0o1_out(scan_i0o1_int[177]),
.load_out(load_int[177]),.scan_out(scan_int[177]),.chip_in(sc_dmem_ben[0]));


si_bit scan_cell_15_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[177]),.phib(phib_int[177]),
.scan_i0o1(scan_i0o1_int[177]),.load(load_int[177]),.scan_in(scan_int[177]),
.phi_out(phi_int[178]),.phib_out(phib_int[178]),.scan_i0o1_out(scan_i0o1_int[178]),
.load_out(load_int[178]),.scan_out(scan_int[178]),.chip_in(sc_dmem_ben[1]));


si_bit scan_cell_15_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[178]),.phib(phib_int[178]),
.scan_i0o1(scan_i0o1_int[178]),.load(load_int[178]),.scan_in(scan_int[178]),
.phi_out(phi_int[179]),.phib_out(phib_int[179]),.scan_i0o1_out(scan_i0o1_int[179]),
.load_out(load_int[179]),.scan_out(scan_int[179]),.chip_in(sc_dmem_ben[2]));


si_bit scan_cell_15_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[179]),.phib(phib_int[179]),
.scan_i0o1(scan_i0o1_int[179]),.load(load_int[179]),.scan_in(scan_int[179]),
.phi_out(phi_int[180]),.phib_out(phib_int[180]),.scan_i0o1_out(scan_i0o1_int[180]),
.load_out(load_int[180]),.scan_out(scan_int[180]),.chip_in(sc_dmem_ben[3]));


si_bit scan_cell_16_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[180]),.phib(phib_int[180]),
.scan_i0o1(scan_i0o1_int[180]),.load(load_int[180]),.scan_in(scan_int[180]),
.phi_out(phi_int[181]),.phib_out(phib_int[181]),.scan_i0o1_out(scan_i0o1_int[181]),
.load_out(load_int[181]),.scan_out(scan_int[181]),.chip_in(sc_dmem_wdata[0]));


si_bit scan_cell_16_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[181]),.phib(phib_int[181]),
.scan_i0o1(scan_i0o1_int[181]),.load(load_int[181]),.scan_in(scan_int[181]),
.phi_out(phi_int[182]),.phib_out(phib_int[182]),.scan_i0o1_out(scan_i0o1_int[182]),
.load_out(load_int[182]),.scan_out(scan_int[182]),.chip_in(sc_dmem_wdata[1]));


si_bit scan_cell_16_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[182]),.phib(phib_int[182]),
.scan_i0o1(scan_i0o1_int[182]),.load(load_int[182]),.scan_in(scan_int[182]),
.phi_out(phi_int[183]),.phib_out(phib_int[183]),.scan_i0o1_out(scan_i0o1_int[183]),
.load_out(load_int[183]),.scan_out(scan_int[183]),.chip_in(sc_dmem_wdata[2]));


si_bit scan_cell_16_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[183]),.phib(phib_int[183]),
.scan_i0o1(scan_i0o1_int[183]),.load(load_int[183]),.scan_in(scan_int[183]),
.phi_out(phi_int[184]),.phib_out(phib_int[184]),.scan_i0o1_out(scan_i0o1_int[184]),
.load_out(load_int[184]),.scan_out(scan_int[184]),.chip_in(sc_dmem_wdata[3]));


si_bit scan_cell_16_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[184]),.phib(phib_int[184]),
.scan_i0o1(scan_i0o1_int[184]),.load(load_int[184]),.scan_in(scan_int[184]),
.phi_out(phi_int[185]),.phib_out(phib_int[185]),.scan_i0o1_out(scan_i0o1_int[185]),
.load_out(load_int[185]),.scan_out(scan_int[185]),.chip_in(sc_dmem_wdata[4]));


si_bit scan_cell_16_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[185]),.phib(phib_int[185]),
.scan_i0o1(scan_i0o1_int[185]),.load(load_int[185]),.scan_in(scan_int[185]),
.phi_out(phi_int[186]),.phib_out(phib_int[186]),.scan_i0o1_out(scan_i0o1_int[186]),
.load_out(load_int[186]),.scan_out(scan_int[186]),.chip_in(sc_dmem_wdata[5]));


si_bit scan_cell_16_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[186]),.phib(phib_int[186]),
.scan_i0o1(scan_i0o1_int[186]),.load(load_int[186]),.scan_in(scan_int[186]),
.phi_out(phi_int[187]),.phib_out(phib_int[187]),.scan_i0o1_out(scan_i0o1_int[187]),
.load_out(load_int[187]),.scan_out(scan_int[187]),.chip_in(sc_dmem_wdata[6]));


si_bit scan_cell_16_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[187]),.phib(phib_int[187]),
.scan_i0o1(scan_i0o1_int[187]),.load(load_int[187]),.scan_in(scan_int[187]),
.phi_out(phi_int[188]),.phib_out(phib_int[188]),.scan_i0o1_out(scan_i0o1_int[188]),
.load_out(load_int[188]),.scan_out(scan_int[188]),.chip_in(sc_dmem_wdata[7]));


si_bit scan_cell_16_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[188]),.phib(phib_int[188]),
.scan_i0o1(scan_i0o1_int[188]),.load(load_int[188]),.scan_in(scan_int[188]),
.phi_out(phi_int[189]),.phib_out(phib_int[189]),.scan_i0o1_out(scan_i0o1_int[189]),
.load_out(load_int[189]),.scan_out(scan_int[189]),.chip_in(sc_dmem_wdata[8]));


si_bit scan_cell_16_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[189]),.phib(phib_int[189]),
.scan_i0o1(scan_i0o1_int[189]),.load(load_int[189]),.scan_in(scan_int[189]),
.phi_out(phi_int[190]),.phib_out(phib_int[190]),.scan_i0o1_out(scan_i0o1_int[190]),
.load_out(load_int[190]),.scan_out(scan_int[190]),.chip_in(sc_dmem_wdata[9]));


si_bit scan_cell_16_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[190]),.phib(phib_int[190]),
.scan_i0o1(scan_i0o1_int[190]),.load(load_int[190]),.scan_in(scan_int[190]),
.phi_out(phi_int[191]),.phib_out(phib_int[191]),.scan_i0o1_out(scan_i0o1_int[191]),
.load_out(load_int[191]),.scan_out(scan_int[191]),.chip_in(sc_dmem_wdata[10]));


si_bit scan_cell_16_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[191]),.phib(phib_int[191]),
.scan_i0o1(scan_i0o1_int[191]),.load(load_int[191]),.scan_in(scan_int[191]),
.phi_out(phi_int[192]),.phib_out(phib_int[192]),.scan_i0o1_out(scan_i0o1_int[192]),
.load_out(load_int[192]),.scan_out(scan_int[192]),.chip_in(sc_dmem_wdata[11]));


si_bit scan_cell_16_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[192]),.phib(phib_int[192]),
.scan_i0o1(scan_i0o1_int[192]),.load(load_int[192]),.scan_in(scan_int[192]),
.phi_out(phi_int[193]),.phib_out(phib_int[193]),.scan_i0o1_out(scan_i0o1_int[193]),
.load_out(load_int[193]),.scan_out(scan_int[193]),.chip_in(sc_dmem_wdata[12]));


si_bit scan_cell_16_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[193]),.phib(phib_int[193]),
.scan_i0o1(scan_i0o1_int[193]),.load(load_int[193]),.scan_in(scan_int[193]),
.phi_out(phi_int[194]),.phib_out(phib_int[194]),.scan_i0o1_out(scan_i0o1_int[194]),
.load_out(load_int[194]),.scan_out(scan_int[194]),.chip_in(sc_dmem_wdata[13]));


si_bit scan_cell_16_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[194]),.phib(phib_int[194]),
.scan_i0o1(scan_i0o1_int[194]),.load(load_int[194]),.scan_in(scan_int[194]),
.phi_out(phi_int[195]),.phib_out(phib_int[195]),.scan_i0o1_out(scan_i0o1_int[195]),
.load_out(load_int[195]),.scan_out(scan_int[195]),.chip_in(sc_dmem_wdata[14]));


si_bit scan_cell_16_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[195]),.phib(phib_int[195]),
.scan_i0o1(scan_i0o1_int[195]),.load(load_int[195]),.scan_in(scan_int[195]),
.phi_out(phi_int[196]),.phib_out(phib_int[196]),.scan_i0o1_out(scan_i0o1_int[196]),
.load_out(load_int[196]),.scan_out(scan_int[196]),.chip_in(sc_dmem_wdata[15]));


si_bit scan_cell_16_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[196]),.phib(phib_int[196]),
.scan_i0o1(scan_i0o1_int[196]),.load(load_int[196]),.scan_in(scan_int[196]),
.phi_out(phi_int[197]),.phib_out(phib_int[197]),.scan_i0o1_out(scan_i0o1_int[197]),
.load_out(load_int[197]),.scan_out(scan_int[197]),.chip_in(sc_dmem_wdata[16]));


si_bit scan_cell_16_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[197]),.phib(phib_int[197]),
.scan_i0o1(scan_i0o1_int[197]),.load(load_int[197]),.scan_in(scan_int[197]),
.phi_out(phi_int[198]),.phib_out(phib_int[198]),.scan_i0o1_out(scan_i0o1_int[198]),
.load_out(load_int[198]),.scan_out(scan_int[198]),.chip_in(sc_dmem_wdata[17]));


si_bit scan_cell_16_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[198]),.phib(phib_int[198]),
.scan_i0o1(scan_i0o1_int[198]),.load(load_int[198]),.scan_in(scan_int[198]),
.phi_out(phi_int[199]),.phib_out(phib_int[199]),.scan_i0o1_out(scan_i0o1_int[199]),
.load_out(load_int[199]),.scan_out(scan_int[199]),.chip_in(sc_dmem_wdata[18]));


si_bit scan_cell_16_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[199]),.phib(phib_int[199]),
.scan_i0o1(scan_i0o1_int[199]),.load(load_int[199]),.scan_in(scan_int[199]),
.phi_out(phi_int[200]),.phib_out(phib_int[200]),.scan_i0o1_out(scan_i0o1_int[200]),
.load_out(load_int[200]),.scan_out(scan_int[200]),.chip_in(sc_dmem_wdata[19]));


si_bit scan_cell_16_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[200]),.phib(phib_int[200]),
.scan_i0o1(scan_i0o1_int[200]),.load(load_int[200]),.scan_in(scan_int[200]),
.phi_out(phi_int[201]),.phib_out(phib_int[201]),.scan_i0o1_out(scan_i0o1_int[201]),
.load_out(load_int[201]),.scan_out(scan_int[201]),.chip_in(sc_dmem_wdata[20]));


si_bit scan_cell_16_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[201]),.phib(phib_int[201]),
.scan_i0o1(scan_i0o1_int[201]),.load(load_int[201]),.scan_in(scan_int[201]),
.phi_out(phi_int[202]),.phib_out(phib_int[202]),.scan_i0o1_out(scan_i0o1_int[202]),
.load_out(load_int[202]),.scan_out(scan_int[202]),.chip_in(sc_dmem_wdata[21]));


si_bit scan_cell_16_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[202]),.phib(phib_int[202]),
.scan_i0o1(scan_i0o1_int[202]),.load(load_int[202]),.scan_in(scan_int[202]),
.phi_out(phi_int[203]),.phib_out(phib_int[203]),.scan_i0o1_out(scan_i0o1_int[203]),
.load_out(load_int[203]),.scan_out(scan_int[203]),.chip_in(sc_dmem_wdata[22]));


si_bit scan_cell_16_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[203]),.phib(phib_int[203]),
.scan_i0o1(scan_i0o1_int[203]),.load(load_int[203]),.scan_in(scan_int[203]),
.phi_out(phi_int[204]),.phib_out(phib_int[204]),.scan_i0o1_out(scan_i0o1_int[204]),
.load_out(load_int[204]),.scan_out(scan_int[204]),.chip_in(sc_dmem_wdata[23]));


si_bit scan_cell_16_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[204]),.phib(phib_int[204]),
.scan_i0o1(scan_i0o1_int[204]),.load(load_int[204]),.scan_in(scan_int[204]),
.phi_out(phi_int[205]),.phib_out(phib_int[205]),.scan_i0o1_out(scan_i0o1_int[205]),
.load_out(load_int[205]),.scan_out(scan_int[205]),.chip_in(sc_dmem_wdata[24]));


si_bit scan_cell_16_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[205]),.phib(phib_int[205]),
.scan_i0o1(scan_i0o1_int[205]),.load(load_int[205]),.scan_in(scan_int[205]),
.phi_out(phi_int[206]),.phib_out(phib_int[206]),.scan_i0o1_out(scan_i0o1_int[206]),
.load_out(load_int[206]),.scan_out(scan_int[206]),.chip_in(sc_dmem_wdata[25]));


si_bit scan_cell_16_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[206]),.phib(phib_int[206]),
.scan_i0o1(scan_i0o1_int[206]),.load(load_int[206]),.scan_in(scan_int[206]),
.phi_out(phi_int[207]),.phib_out(phib_int[207]),.scan_i0o1_out(scan_i0o1_int[207]),
.load_out(load_int[207]),.scan_out(scan_int[207]),.chip_in(sc_dmem_wdata[26]));


si_bit scan_cell_16_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[207]),.phib(phib_int[207]),
.scan_i0o1(scan_i0o1_int[207]),.load(load_int[207]),.scan_in(scan_int[207]),
.phi_out(phi_int[208]),.phib_out(phib_int[208]),.scan_i0o1_out(scan_i0o1_int[208]),
.load_out(load_int[208]),.scan_out(scan_int[208]),.chip_in(sc_dmem_wdata[27]));


si_bit scan_cell_16_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[208]),.phib(phib_int[208]),
.scan_i0o1(scan_i0o1_int[208]),.load(load_int[208]),.scan_in(scan_int[208]),
.phi_out(phi_int[209]),.phib_out(phib_int[209]),.scan_i0o1_out(scan_i0o1_int[209]),
.load_out(load_int[209]),.scan_out(scan_int[209]),.chip_in(sc_dmem_wdata[28]));


si_bit scan_cell_16_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[209]),.phib(phib_int[209]),
.scan_i0o1(scan_i0o1_int[209]),.load(load_int[209]),.scan_in(scan_int[209]),
.phi_out(phi_int[210]),.phib_out(phib_int[210]),.scan_i0o1_out(scan_i0o1_int[210]),
.load_out(load_int[210]),.scan_out(scan_int[210]),.chip_in(sc_dmem_wdata[29]));


si_bit scan_cell_16_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[210]),.phib(phib_int[210]),
.scan_i0o1(scan_i0o1_int[210]),.load(load_int[210]),.scan_in(scan_int[210]),
.phi_out(phi_int[211]),.phib_out(phib_int[211]),.scan_i0o1_out(scan_i0o1_int[211]),
.load_out(load_int[211]),.scan_out(scan_int[211]),.chip_in(sc_dmem_wdata[30]));


si_bit scan_cell_16_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[211]),.phib(phib_int[211]),
.scan_i0o1(scan_i0o1_int[211]),.load(load_int[211]),.scan_in(scan_int[211]),
.phi_out(phi_int[212]),.phib_out(phib_int[212]),.scan_i0o1_out(scan_i0o1_int[212]),
.load_out(load_int[212]),.scan_out(scan_int[212]),.chip_in(sc_dmem_wdata[31]));


si_bit scan_cell_17_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[212]),.phib(phib_int[212]),
.scan_i0o1(scan_i0o1_int[212]),.load(load_int[212]),.scan_in(scan_int[212]),
.phi_out(phi_int[213]),.phib_out(phib_int[213]),.scan_i0o1_out(scan_i0o1_int[213]),
.load_out(load_int[213]),.scan_out(scan_int[213]),.chip_in(sc_dmem_clk));


si_bit scan_cell_18_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[213]),.phib(phib_int[213]),
.scan_i0o1(scan_i0o1_int[213]),.load(load_int[213]),.scan_in(scan_int[213]),
.phi_out(phi_int[214]),.phib_out(phib_int[214]),.scan_i0o1_out(scan_i0o1_int[214]),
.load_out(load_int[214]),.scan_out(scan_int[214]),.chip_in(sc_fsm_mode));


si_bit scan_cell_19_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[214]),.phib(phib_int[214]),
.scan_i0o1(scan_i0o1_int[214]),.load(load_int[214]),.scan_in(scan_int[214]),
.phi_out(phi_int[215]),.phib_out(phib_int[215]),.scan_i0o1_out(scan_i0o1_int[215]),
.load_out(load_int[215]),.scan_out(scan_int[215]),.chip_in(sc_fsm_indef));


si_bit scan_cell_20_0(.VDD(VDD),.VSS(VSS),.phi(phi_int[215]),.phib(phib_int[215]),
.scan_i0o1(scan_i0o1_int[215]),.load(load_int[215]),.scan_in(scan_int[215]),
.phi_out(phi_int[216]),.phib_out(phib_int[216]),.scan_i0o1_out(scan_i0o1_int[216]),
.load_out(load_int[216]),.scan_out(scan_int[216]),.chip_in(sc_fsm_cycle[0]));


si_bit scan_cell_20_1(.VDD(VDD),.VSS(VSS),.phi(phi_int[216]),.phib(phib_int[216]),
.scan_i0o1(scan_i0o1_int[216]),.load(load_int[216]),.scan_in(scan_int[216]),
.phi_out(phi_int[217]),.phib_out(phib_int[217]),.scan_i0o1_out(scan_i0o1_int[217]),
.load_out(load_int[217]),.scan_out(scan_int[217]),.chip_in(sc_fsm_cycle[1]));


si_bit scan_cell_20_2(.VDD(VDD),.VSS(VSS),.phi(phi_int[217]),.phib(phib_int[217]),
.scan_i0o1(scan_i0o1_int[217]),.load(load_int[217]),.scan_in(scan_int[217]),
.phi_out(phi_int[218]),.phib_out(phib_int[218]),.scan_i0o1_out(scan_i0o1_int[218]),
.load_out(load_int[218]),.scan_out(scan_int[218]),.chip_in(sc_fsm_cycle[2]));


si_bit scan_cell_20_3(.VDD(VDD),.VSS(VSS),.phi(phi_int[218]),.phib(phib_int[218]),
.scan_i0o1(scan_i0o1_int[218]),.load(load_int[218]),.scan_in(scan_int[218]),
.phi_out(phi_int[219]),.phib_out(phib_int[219]),.scan_i0o1_out(scan_i0o1_int[219]),
.load_out(load_int[219]),.scan_out(scan_int[219]),.chip_in(sc_fsm_cycle[3]));


si_bit scan_cell_20_4(.VDD(VDD),.VSS(VSS),.phi(phi_int[219]),.phib(phib_int[219]),
.scan_i0o1(scan_i0o1_int[219]),.load(load_int[219]),.scan_in(scan_int[219]),
.phi_out(phi_int[220]),.phib_out(phib_int[220]),.scan_i0o1_out(scan_i0o1_int[220]),
.load_out(load_int[220]),.scan_out(scan_int[220]),.chip_in(sc_fsm_cycle[4]));


si_bit scan_cell_20_5(.VDD(VDD),.VSS(VSS),.phi(phi_int[220]),.phib(phib_int[220]),
.scan_i0o1(scan_i0o1_int[220]),.load(load_int[220]),.scan_in(scan_int[220]),
.phi_out(phi_int[221]),.phib_out(phib_int[221]),.scan_i0o1_out(scan_i0o1_int[221]),
.load_out(load_int[221]),.scan_out(scan_int[221]),.chip_in(sc_fsm_cycle[5]));


si_bit scan_cell_20_6(.VDD(VDD),.VSS(VSS),.phi(phi_int[221]),.phib(phib_int[221]),
.scan_i0o1(scan_i0o1_int[221]),.load(load_int[221]),.scan_in(scan_int[221]),
.phi_out(phi_int[222]),.phib_out(phib_int[222]),.scan_i0o1_out(scan_i0o1_int[222]),
.load_out(load_int[222]),.scan_out(scan_int[222]),.chip_in(sc_fsm_cycle[6]));


si_bit scan_cell_20_7(.VDD(VDD),.VSS(VSS),.phi(phi_int[222]),.phib(phib_int[222]),
.scan_i0o1(scan_i0o1_int[222]),.load(load_int[222]),.scan_in(scan_int[222]),
.phi_out(phi_int[223]),.phib_out(phib_int[223]),.scan_i0o1_out(scan_i0o1_int[223]),
.load_out(load_int[223]),.scan_out(scan_int[223]),.chip_in(sc_fsm_cycle[7]));


si_bit scan_cell_20_8(.VDD(VDD),.VSS(VSS),.phi(phi_int[223]),.phib(phib_int[223]),
.scan_i0o1(scan_i0o1_int[223]),.load(load_int[223]),.scan_in(scan_int[223]),
.phi_out(phi_int[224]),.phib_out(phib_int[224]),.scan_i0o1_out(scan_i0o1_int[224]),
.load_out(load_int[224]),.scan_out(scan_int[224]),.chip_in(sc_fsm_cycle[8]));


si_bit scan_cell_20_9(.VDD(VDD),.VSS(VSS),.phi(phi_int[224]),.phib(phib_int[224]),
.scan_i0o1(scan_i0o1_int[224]),.load(load_int[224]),.scan_in(scan_int[224]),
.phi_out(phi_int[225]),.phib_out(phib_int[225]),.scan_i0o1_out(scan_i0o1_int[225]),
.load_out(load_int[225]),.scan_out(scan_int[225]),.chip_in(sc_fsm_cycle[9]));


si_bit scan_cell_20_10(.VDD(VDD),.VSS(VSS),.phi(phi_int[225]),.phib(phib_int[225]),
.scan_i0o1(scan_i0o1_int[225]),.load(load_int[225]),.scan_in(scan_int[225]),
.phi_out(phi_int[226]),.phib_out(phib_int[226]),.scan_i0o1_out(scan_i0o1_int[226]),
.load_out(load_int[226]),.scan_out(scan_int[226]),.chip_in(sc_fsm_cycle[10]));


si_bit scan_cell_20_11(.VDD(VDD),.VSS(VSS),.phi(phi_int[226]),.phib(phib_int[226]),
.scan_i0o1(scan_i0o1_int[226]),.load(load_int[226]),.scan_in(scan_int[226]),
.phi_out(phi_int[227]),.phib_out(phib_int[227]),.scan_i0o1_out(scan_i0o1_int[227]),
.load_out(load_int[227]),.scan_out(scan_int[227]),.chip_in(sc_fsm_cycle[11]));


si_bit scan_cell_20_12(.VDD(VDD),.VSS(VSS),.phi(phi_int[227]),.phib(phib_int[227]),
.scan_i0o1(scan_i0o1_int[227]),.load(load_int[227]),.scan_in(scan_int[227]),
.phi_out(phi_int[228]),.phib_out(phib_int[228]),.scan_i0o1_out(scan_i0o1_int[228]),
.load_out(load_int[228]),.scan_out(scan_int[228]),.chip_in(sc_fsm_cycle[12]));


si_bit scan_cell_20_13(.VDD(VDD),.VSS(VSS),.phi(phi_int[228]),.phib(phib_int[228]),
.scan_i0o1(scan_i0o1_int[228]),.load(load_int[228]),.scan_in(scan_int[228]),
.phi_out(phi_int[229]),.phib_out(phib_int[229]),.scan_i0o1_out(scan_i0o1_int[229]),
.load_out(load_int[229]),.scan_out(scan_int[229]),.chip_in(sc_fsm_cycle[13]));


si_bit scan_cell_20_14(.VDD(VDD),.VSS(VSS),.phi(phi_int[229]),.phib(phib_int[229]),
.scan_i0o1(scan_i0o1_int[229]),.load(load_int[229]),.scan_in(scan_int[229]),
.phi_out(phi_int[230]),.phib_out(phib_int[230]),.scan_i0o1_out(scan_i0o1_int[230]),
.load_out(load_int[230]),.scan_out(scan_int[230]),.chip_in(sc_fsm_cycle[14]));


si_bit scan_cell_20_15(.VDD(VDD),.VSS(VSS),.phi(phi_int[230]),.phib(phib_int[230]),
.scan_i0o1(scan_i0o1_int[230]),.load(load_int[230]),.scan_in(scan_int[230]),
.phi_out(phi_int[231]),.phib_out(phib_int[231]),.scan_i0o1_out(scan_i0o1_int[231]),
.load_out(load_int[231]),.scan_out(scan_int[231]),.chip_in(sc_fsm_cycle[15]));


si_bit scan_cell_20_16(.VDD(VDD),.VSS(VSS),.phi(phi_int[231]),.phib(phib_int[231]),
.scan_i0o1(scan_i0o1_int[231]),.load(load_int[231]),.scan_in(scan_int[231]),
.phi_out(phi_int[232]),.phib_out(phib_int[232]),.scan_i0o1_out(scan_i0o1_int[232]),
.load_out(load_int[232]),.scan_out(scan_int[232]),.chip_in(sc_fsm_cycle[16]));


si_bit scan_cell_20_17(.VDD(VDD),.VSS(VSS),.phi(phi_int[232]),.phib(phib_int[232]),
.scan_i0o1(scan_i0o1_int[232]),.load(load_int[232]),.scan_in(scan_int[232]),
.phi_out(phi_int[233]),.phib_out(phib_int[233]),.scan_i0o1_out(scan_i0o1_int[233]),
.load_out(load_int[233]),.scan_out(scan_int[233]),.chip_in(sc_fsm_cycle[17]));


si_bit scan_cell_20_18(.VDD(VDD),.VSS(VSS),.phi(phi_int[233]),.phib(phib_int[233]),
.scan_i0o1(scan_i0o1_int[233]),.load(load_int[233]),.scan_in(scan_int[233]),
.phi_out(phi_int[234]),.phib_out(phib_int[234]),.scan_i0o1_out(scan_i0o1_int[234]),
.load_out(load_int[234]),.scan_out(scan_int[234]),.chip_in(sc_fsm_cycle[18]));


si_bit scan_cell_20_19(.VDD(VDD),.VSS(VSS),.phi(phi_int[234]),.phib(phib_int[234]),
.scan_i0o1(scan_i0o1_int[234]),.load(load_int[234]),.scan_in(scan_int[234]),
.phi_out(phi_int[235]),.phib_out(phib_int[235]),.scan_i0o1_out(scan_i0o1_int[235]),
.load_out(load_int[235]),.scan_out(scan_int[235]),.chip_in(sc_fsm_cycle[19]));


si_bit scan_cell_20_20(.VDD(VDD),.VSS(VSS),.phi(phi_int[235]),.phib(phib_int[235]),
.scan_i0o1(scan_i0o1_int[235]),.load(load_int[235]),.scan_in(scan_int[235]),
.phi_out(phi_int[236]),.phib_out(phib_int[236]),.scan_i0o1_out(scan_i0o1_int[236]),
.load_out(load_int[236]),.scan_out(scan_int[236]),.chip_in(sc_fsm_cycle[20]));


si_bit scan_cell_20_21(.VDD(VDD),.VSS(VSS),.phi(phi_int[236]),.phib(phib_int[236]),
.scan_i0o1(scan_i0o1_int[236]),.load(load_int[236]),.scan_in(scan_int[236]),
.phi_out(phi_int[237]),.phib_out(phib_int[237]),.scan_i0o1_out(scan_i0o1_int[237]),
.load_out(load_int[237]),.scan_out(scan_int[237]),.chip_in(sc_fsm_cycle[21]));


si_bit scan_cell_20_22(.VDD(VDD),.VSS(VSS),.phi(phi_int[237]),.phib(phib_int[237]),
.scan_i0o1(scan_i0o1_int[237]),.load(load_int[237]),.scan_in(scan_int[237]),
.phi_out(phi_int[238]),.phib_out(phib_int[238]),.scan_i0o1_out(scan_i0o1_int[238]),
.load_out(load_int[238]),.scan_out(scan_int[238]),.chip_in(sc_fsm_cycle[22]));


si_bit scan_cell_20_23(.VDD(VDD),.VSS(VSS),.phi(phi_int[238]),.phib(phib_int[238]),
.scan_i0o1(scan_i0o1_int[238]),.load(load_int[238]),.scan_in(scan_int[238]),
.phi_out(phi_int[239]),.phib_out(phib_int[239]),.scan_i0o1_out(scan_i0o1_int[239]),
.load_out(load_int[239]),.scan_out(scan_int[239]),.chip_in(sc_fsm_cycle[23]));


si_bit scan_cell_20_24(.VDD(VDD),.VSS(VSS),.phi(phi_int[239]),.phib(phib_int[239]),
.scan_i0o1(scan_i0o1_int[239]),.load(load_int[239]),.scan_in(scan_int[239]),
.phi_out(phi_int[240]),.phib_out(phib_int[240]),.scan_i0o1_out(scan_i0o1_int[240]),
.load_out(load_int[240]),.scan_out(scan_int[240]),.chip_in(sc_fsm_cycle[24]));


si_bit scan_cell_20_25(.VDD(VDD),.VSS(VSS),.phi(phi_int[240]),.phib(phib_int[240]),
.scan_i0o1(scan_i0o1_int[240]),.load(load_int[240]),.scan_in(scan_int[240]),
.phi_out(phi_int[241]),.phib_out(phib_int[241]),.scan_i0o1_out(scan_i0o1_int[241]),
.load_out(load_int[241]),.scan_out(scan_int[241]),.chip_in(sc_fsm_cycle[25]));


si_bit scan_cell_20_26(.VDD(VDD),.VSS(VSS),.phi(phi_int[241]),.phib(phib_int[241]),
.scan_i0o1(scan_i0o1_int[241]),.load(load_int[241]),.scan_in(scan_int[241]),
.phi_out(phi_int[242]),.phib_out(phib_int[242]),.scan_i0o1_out(scan_i0o1_int[242]),
.load_out(load_int[242]),.scan_out(scan_int[242]),.chip_in(sc_fsm_cycle[26]));


si_bit scan_cell_20_27(.VDD(VDD),.VSS(VSS),.phi(phi_int[242]),.phib(phib_int[242]),
.scan_i0o1(scan_i0o1_int[242]),.load(load_int[242]),.scan_in(scan_int[242]),
.phi_out(phi_int[243]),.phib_out(phib_int[243]),.scan_i0o1_out(scan_i0o1_int[243]),
.load_out(load_int[243]),.scan_out(scan_int[243]),.chip_in(sc_fsm_cycle[27]));


si_bit scan_cell_20_28(.VDD(VDD),.VSS(VSS),.phi(phi_int[243]),.phib(phib_int[243]),
.scan_i0o1(scan_i0o1_int[243]),.load(load_int[243]),.scan_in(scan_int[243]),
.phi_out(phi_int[244]),.phib_out(phib_int[244]),.scan_i0o1_out(scan_i0o1_int[244]),
.load_out(load_int[244]),.scan_out(scan_int[244]),.chip_in(sc_fsm_cycle[28]));


si_bit scan_cell_20_29(.VDD(VDD),.VSS(VSS),.phi(phi_int[244]),.phib(phib_int[244]),
.scan_i0o1(scan_i0o1_int[244]),.load(load_int[244]),.scan_in(scan_int[244]),
.phi_out(phi_int[245]),.phib_out(phib_int[245]),.scan_i0o1_out(scan_i0o1_int[245]),
.load_out(load_int[245]),.scan_out(scan_int[245]),.chip_in(sc_fsm_cycle[29]));


si_bit scan_cell_20_30(.VDD(VDD),.VSS(VSS),.phi(phi_int[245]),.phib(phib_int[245]),
.scan_i0o1(scan_i0o1_int[245]),.load(load_int[245]),.scan_in(scan_int[245]),
.phi_out(phi_int[246]),.phib_out(phib_int[246]),.scan_i0o1_out(scan_i0o1_int[246]),
.load_out(load_int[246]),.scan_out(scan_int[246]),.chip_in(sc_fsm_cycle[30]));


si_bit scan_cell_20_31(.VDD(VDD),.VSS(VSS),.phi(phi_int[246]),.phib(phib_int[246]),
.scan_i0o1(scan_i0o1_int[246]),.load(load_int[246]),.scan_in(scan_int[246]),
.phi_out(phi_out),.phib_out(phib_out),.scan_i0o1_out(scan_i0o1_out),
.load_out(load_out),.scan_out(scan_out),.chip_in(sc_fsm_cycle[31]));

endmodule
</code></pre></div>
    </details>




<p>
This structure allows external test equipment or debugging software to shift in arbitrary patterns and read out internal states at any point.<br>
<br>
<em>Scan Mode Operation</em><br>
In scan mode, the SoC suspends normal functional dataflow and all memory wrapper modules switch into test configuration:
<ul>
  <li>Functional read/write ports of IMEM and DMEM are disabled.</li>
  <li>Scan-in (SI) and scan-out (SO) signals propagate through the entire chain.</li>
  <li>All control signals connected to the scan chain are driven purely by the shifted scan data.</li>
  <li>The scan chain scan in instructions into IMEM and data into DMEM, for initialization.</li>
  <li>The scan chain can also read out the content of DMEM after program execution, enabling full post-silicon inspection of computation results.</li>
  </ul>
</p>
<p>
<em>Run Mode Operation</em><br>
When scan mode is deactivated, the memory wrappers and control signals reconnect to their functional sources:
<ul>
  <li>The CPU fetches instructions directly from IMEM.</li>
  <li>The CPU accesses DMEM via the AHB bus.</li>
  <li>Clock generator works under setting.</li>
  <li>No scan traffic influences the logic.</li>
  </ul>
</p>
<p>The transition between scan mode and run mode is cleanly controlled to ensure no metastability or unintended corruption of memory or control registers.</p>
  <img src="../images/nanologic/scan_in.png" alt="System block diagram" style="display:block; margin:0 auto; width:80%; height:auto;">
   <p class="caption">Figure 5. Scan In Cell</p>
   <br>
    <img src="../images/nanologic/scan_out.png" alt="System block diagram" style="display:block; margin:0 auto; width:80%; height:auto;"><br>
   <p class="caption">Figure 5. Scan Out Cell</p>
   <br>
<br>
<strong>Clock Generator</strong><br>
The clock generator is based on a ring oscillator whose output frequency can be configured at runtime through two control registers:
<ul>
  <li>fc (frequency control) - selects the effective length of the ring oscillator, thereby adjusting the base oscillation frequency. Different fc settings correspond to different numbers of delay stages in the ring.</li>
  <li>div (divider) - applies a programmable integer divide ratio to the ring oscillator output, generating a lower-frequency system clock when needed.</li>
</ul>
<p>By combining the fc and div settings, the SoC can trade off performance, power consumption, and timing margin. These control bits are loaded via the scan chain, allowing the clock configuration to be changed even when no firmware is running yet.
The final clock output of the generator is routed to the CPU core, AHB bus, memories, and peripherals, forming the primary system clock domain.</p>

<br>
<strong>Debug FSM</strong>
<p>A debug FSM orchestrates how the generated clock is delivered to the rest of the chip. The FSM supports three operating modes:<br>
<em>Scan Mode: </em>The system clock isn't launched, and no clock edges are propagated to the CPU or peripherals. In this mode the scan chain can working, as the IMEM and DEME's clock will be depend on outside scan-in clock signal.<br>
<em>Running Mode: </em>The clock generator output is continuously forwarded through the scan-controlled clock gating logic to the system clock tree. The SoC operates normally in this mode: the CPU executes instructions from IMEM, accesses DMEM over AHB, and interacts with APB peripherals.<br>
<em>Debug Mode: </em>The FSM enables the clock for a programmable number of cycles and then automatically returns to a paused state. It allows engineers to advance the system by a controlled number of clock edges, then inspect internal state or memory contents via the scan chain.<br>
<br>
Mode selection, as well as auxiliary control signals (such as step length in debug mode), are themselves loaded through the scan chain. This allows complete control of clock behavior from external test equipment without relying on software.
</p>
   <img src="../images/nanologic/fsm.png" alt="System block diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
   <p class="caption">Figure 6. Debug FSM</p>


    <details class="code-block">
      <summary>Scan cells (scan_cells.v)</summary>
      <div class="code-content"><pre><code>//SCAN CELLS FOR ST 65

module so_bit( phi, phib, scan_i0o1, load, scan_in, chip_out, phi_out, phib_out, scan_i0o1_out, load_out, scan_out, VDD, VSS );

   inout   VDD, VSS;
   input   phi;              // Latch positive phase
   input   phib;             // latch negative phase
   input   scan_i0o1;        // Select scan_in/chip_out 0:scan_in, 1:scan_out
   input   load;             // Load chip_in latch
   input   scan_in;          // Serial scan in
   input   chip_out;         // Data from chip to scan out
   
   output  phi_out;          // verification signal
   output  phib_out;         // verification signal
   output  scan_i0o1_out;    // verification signal
   output  load_out;         // verification signal
   output  scan_out;         // Serial scan out  
   
   wire    latch_in;
   wire    latch_out;
   wire    scan_out_int;
   
   BUFFD12  buf_phi  (.Z(phi_out),       .I(phi) );
   BUFFD12  buf_phib (.Z(phib_out),      .I(phib) );
   BUFFD12  buf_mode (.Z(scan_i0o1_out), .I(scan_i0o1) );
   BUFFD12  buf_load (.Z(load_out),      .I(load) );
   MUX2D1   mx       (.Z(latch_in),      .I0(scan_in),     .I1(chip_out),      .S(scan_i0o1) );
   LHQD1    flip     (.Q(latch_out),     .D(latch_in),     .E(phi) );
   LHQD1    flop     (.Q(scan_out_int),  .D(latch_out),    .E(phib) );
   BUFFD12  buf_sout (.Z(scan_out),      .I(scan_out_int) );
   
endmodule // scan_out_bit

// Scan in with output latch
module si_bit( phi, phib, scan_i0o1, load, scan_in, phi_out, phib_out, scan_i0o1_out, load_out, scan_out, chip_in, VDD, VSS );
   
   inout   VDD, VSS;
   input   phi;              // Latch positive phase
   input   phib;             // latch negative phase
   input   scan_i0o1;        // Select scan in/out
   input   load;             // Load chip_in latch
   input   scan_in;          // Serial scan in

   output  phi_out;          // verification signal
   output  phib_out;         // verification signal
   output  scan_i0o1_out;    // verification signal
   output  load_out;         // verification signal
   output  scan_out;         // Serial scan out  
   output  chip_in;          // Input to the chip
   
   wire    latch_in;
   wire    latch_out;
   wire    scan_out_int;
   wire    chip_in_int;
   
   BUFFD12  buf_phi     (.Z(phi_out),       .I(phi) );
   BUFFD12  buf_phib    (.Z(phib_out),      .I(phib) );
   BUFFD12  buf_mode    (.Z(scan_i0o1_out), .I(scan_i0o1) );
   BUFFD12  buf_load    (.Z(load_out),      .I(load) );
   MUX2D1   mx          (.Z(latch_in),      .I0(scan_in),       .I1(chip_in_int), .S(scan_i0o1) );
   LHQD1    flip        (.Q(latch_out),     .D(latch_in),       .E(phi) );
   LHQD1    flop        (.Q(scan_out_int),  .D(latch_out),      .E(phib) );
   BUFFD12  buf_sout    (.Z(scan_out),      .I(scan_out_int) );
   LHQD1    latch_chip  (.Q(chip_in_int),   .D(scan_out_int),   .E(load) );
   BUFFD12  buf_chip_in (.Z(chip_in),       .I(chip_in_int) );
   
endmodule
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>Debug FSM (debug_fsm.v)</summary>
      <div class="code-content"><pre><code>module debug_fsm(i_clk, i_rstn, i_mode, i_indef,  i_cycle, o_clk);
	input i_clk;
	input i_rstn;
	input i_mode;
	input i_indef;
	input[31:0] i_cycle;
	output o_clk;

	parameter MODE_SC = 1&#x27;b0;
	parameter MODE_RUN = 1&#x27;b1;

	parameter IDLE = 2&#x27;b00;
	parameter PAUSE = 2&#x27;b01;
	parameter LOOP = 2&#x27;b10;
	parameter CTDN = 2&#x27;b11;

	reg	clk_en;
	reg[1:0] state, state_next;
	reg[31:0] cycle, cycle_next;


	assign o_clk = (clk_en==1&#x27;b1) ? i_clk : 1&#x27;b0;

	always@(negedge i_clk or negedge i_rstn) begin
		if(~i_rstn)begin
			state &lt;= IDLE;
			cycle &lt;= 32&#x27;b00000000;
		end
		else begin
			state &lt;= state_next;
			cycle &lt;= cycle_next;
		end
	end

	always@(*)begin
		state_next&lt;=state;
		cycle_next&lt;=cycle;

		case(state)
			IDLE:begin
				cycle_next &lt;= 32&#x27;b0;
				if(i_mode==MODE_SC) begin
					state_next &lt;= IDLE;
					clk_en = 1&#x27;b0;
				end
				else if(i_indef) begin
					state_next &lt;= LOOP;
					clk_en = 1&#x27;b1;
				end
				else if(i_indef==1&#x27;b0 &amp; cycle &lt; i_cycle)begin
					state_next &lt;= CTDN;
					clk_en = 1&#x27;b1;
				end
				else begin
					state_next &lt;= IDLE;
                    clk_en = 1&#x27;b0;
				end
			end
			PAUSE: begin
				clk_en = 1&#x27;b0;
				if(i_indef == 1&#x27;b0 &amp; cycle &lt; i_cycle) begin
					state_next &lt;= CTDN;
				end
				else begin
					state_next &lt;= PAUSE;
				end
			end
			LOOP: begin
				cycle_next &lt;= cycle + 1;
				clk_en = 1&#x27;b1;
				state_next &lt;= LOOP;
			end
			CTDN: begin
				cycle_next &lt;= cycle + 1;
				if(i_mode == MODE_RUN &amp; cycle &lt; i_cycle) begin
					state_next &lt;= CTDN;
					clk_en = 1&#x27;b1;
				end
				else begin
					state_next &lt;= PAUSE;
					clk_en = 1&#x27;b0;
				end
			end
			default: begin
				state_next &lt;= IDLE;
				cycle_next &lt;= 32&#x27;b0;
			end
		endcase
				
	end
endmodule
</code></pre></div>
    </details>

  </section>
  
  <section id="design-flow">
    <h2>Design Flow</h2>
   <p>This tape-out project follows a complete ASIC development flow that spans front-end design, back-end physical implementation, and post-silicon validation. The process begins with the system specification and microarchitecture design, where the functional requirements and architectural structure of the chip are defined. Based on this specification, the RTL is implemented in Verilog/SystemVerilog.
    </p>
    <p>
    During the functional verification phase, both hardware testbenches and software programs are used. We developed a full RISC-V software toolchain and compiler to generate C-based testcases, allowing us to verify the CPU core using real workloads and instruction sequences. This hardware–software co-verification ensures correctness at both the microarchitectural and ISA levels before synthesis.
       </p><p>
    After verification, the RTL is synthesized into a gate-level netlist, followed by post-synthesis timing and functional checks. The design then enters the physical design flow, including floorplanning, power planning, placement, routing, and clock tree synthesis. I/O pad integration and layout optimization are performed prior to signoff verification, which includes STA, DRC, LVS, and ERC. Once the design passes all signoff checks, the final GDSII is generated and sent for tape-out.
    </p>
   <p>
    Following fabrication, the bare dies are packaged and undergo bring-up on both a breadboard environment and a dedicated PCB. The entire PCB, including power regulation, signal breakouts, connectors, and measurement points, was fully designed by our team, with all components hand-selected to support chip evaluation. Silicon validation verifies real-chip functionality, performance, and power consumption. After successful validation, the chip is used for demonstrations and system-level experiments.
  </p>

          <img src="../images/nanologic/designflow.png" alt="System block diagram">
          <p class="caption">Figure 7. Chip Design Flow</p>

    <h3>RTL Design</h3>
    <p>The RTL design of the SoC was developed and compiled using the ModelSim simulation environment. The codebase follows a clear hierarchical structure that separates chip-level integration, functional logic, and DFT infrastructure. At the highest level, the design begins with soc-pins, which connect the internal SoC signals to the padframe. Directly beneath it is soc-top, the actual top-level RTL of the chip. This module contains both the functional SoC and the DFT subsystem, which are designed as two independent power domains: the DFT logic operates under VDD_Test, while all functional logic is powered by VDD_Core. This separation ensures safe testing in scan mode without interfering with normal system behavior.
    </p>
    <p>
    The functional portion of the chip is encapsulated in soc_mem, which contains the CPU core, memory subsystem, bus fabric, and peripheral subsystem. The CV32E40P RISC-V core connects directly to IMEM for instruction fetch, while DMEM access is performed through the AHB bus. Both memories are instantiated through custom wrappers that interface the synthesized RTL with the SRAM macros and support both run mode and scan mode. The same module instantiates the AHB interconnect, the AHB-to-APB bridge, and all APB peripherals, including UART, SPI, GPIO, I²C, and timers. This organization places all processor-visible functionality inside a single coherent RTL subsystem.
    </p>

    <p>
    On the DFT side, soc-top integrates the full-chip scan chain, scan-mode clock control, and debug FSM, along with a separate test-mode clock generator netlist used for DFT simulations. The scan chain spans 248 cells and provides controllability and observability across CPU state, memory wrapper mode bits, the clock generator configuration registers, and peripheral-related scan points. This allows instructions and data to be shifted directly into IMEM and DMEM during bring-up, while also enabling cycle-stepping through the debug FSM.
    </p>
    <p>
    Overall, the RTL is organized to cleanly separate functionality and test logic while maintaining a modular structure that mirrors the physical hierarchy of the final chip. This structure supported efficient simulation, synthesis, and later physical design, and provided a clear boundary between the functional SoC and its DFT infrastructure.  
    </p>
      <img src="../images/nanologic/rtl.png" alt="System block diagram">
      <p class="caption">Figure 7. RTL Modules Architecture</p>



    <details class="code-block">
      <summary>SoC bus (soc_bus.sv)</summary>
      <div class="code-content"><pre><code>module soc_bus(
    // Clock and Reset
    input logic clk_i,
    input logic rst_ni,

    input logic scan_cg_en_i,

    // Instruction memory interface
    output logic instr_req_o,
    output logic [31:0] instr_addr_o,
    input logic instr_rvalid_i,
    input logic [31:0] instr_rdata_i,

    // Data memory interface
    output logic [3:0] data_size_o,
    output logic [15:0] data_addr_o,
    output logic [31:0] data_wdata_o,
    output logic data_CEN_o,
    output logic data_WEN_o,
    input logic [31:0] data_rdata_i,


    //Interrupt interface
    input logic irq_software_i,
    input logic irq_external_i,
    input logic irq_nm_i,
    input logic irq_UART,
    input logic [1:0] irq_SPI,
    input logic irq_I2C,
    input logic [3:0] irq_TIMER,

    // GPIO interface
    output logic [12:0]	GPIO_PADDR_o,  
    output logic [31:0]	GPIO_PWDATA_o, 
    output logic GPIO_PWRITE_o,
    output logic GPIO_PENABLE_o,
    output logic [2:0] GPIO_PSEL_o,   
    input logic [31:0] GPIO_PRDATA_i, 

    //UART interface
    output logic [12:0]	UART_PADDR_o,  
    output logic [31:0]	UART_PWDATA_o, 
    output logic UART_PWRITE_o,
    output logic UART_PENABLE_o,
    output logic [2:0] UART_PSEL_o,   
    input logic [31:0] UART_PRDATA_i, 


  //SPI interface
    output logic [12:0] SPI_PADDR_o,
    output logic [31:0] SPI_PWDATA_o,
    output logic SPI_PWRITE_o,
    output logic SPI_PENABLE_o,
    output logic [2:0] SPI_PSEL_o,
    input logic [31:0] SPI_PRDATA_i,

  //I2C interface
    output logic [12:0] I2C_PADDR_o,
    output logic [31:0] I2C_PWDATA_o,
    output logic I2C_PWRITE_o,
    output logic I2C_PENABLE_o,
    output logic [2:0] I2C_PSEL_o,
    input logic [31:0] I2C_PRDATA_i,


  //TIMER interface
    output logic [12:0] TIMER_PADDR_o,
    output logic [31:0] TIMER_PWDATA_o,
    output logic TIMER_PWRITE_o,
    output logic TIMER_PENABLE_o,
    output logic [2:0] TIMER_PSEL_o,
    input logic [31:0] TIMER_PRDATA_i

);

    // core &lt;-&gt; armbus
    logic host_req;
    logic host_gnt;
    logic host_err;
    logic host_we;
    logic host_rvalid;
    logic [3:0] host_be;
    logic [31:0] host_addr;
    logic [31:0] host_wdata;
    logic [31:0] host_rdata;




  cv32e40p_top u_cv32e40p_top(
    // Clock and Reset
    .clk_i(clk_i),
    .rst_ni(rst_ni),

    .pulp_clock_en_i(1&#x27;b0),  // PULP clock enable (only used if COREV_CLUSTER = 1)
    .scan_cg_en_i(scan_cg_en_i),  // Enable all clock gates for testing

    // Core ID, Cluster ID, debug mode halt address and boot address are considered more or less static
    .boot_addr_i(32&#x27;b0),
    .mtvec_addr_i(32&#x27;b0),
    .dm_halt_addr_i(32&#x27;b0),
    .hart_id_i(32&#x27;b0),
    .dm_exception_addr_i(32&#x27;b0),

    // Instruction memory interface
    .instr_req_o(instr_req_o),
    .instr_gnt_i(instr_req_o),
    .instr_rvalid_i(instr_rvalid_i),
    .instr_addr_o(instr_addr_o),
    .instr_rdata_i(instr_rdata_i),

    // Data memory interface
    .data_req_o(host_req),
    .data_gnt_i(host_gnt),
    .data_rvalid_i(host_rvalid),
    .data_we_o(host_we),
    .data_be_o(host_be),
    .data_addr_o(host_addr),
    .data_wdata_o(host_wdata),
    .data_rdata_i(host_rdata),

    // Interrupt inputs

    /*
    irq_i[15:12], irq_i[10:8], irq_i[6:4] and irq_i[2:0] are tied to 0 and reserved for future use in the RISC-V Privileged specification. 
    irq_i[11], irq_i[7], and irq_i[3] correspond to the Machine External Interrupt (MEI), Machine Timer Interrupt (MTI), and Machine Software Interrupt (MSI) respectively. 
    irq_i[31:16] interrupts are CV32E40P specific
    */

    .irq_i({9&#x27;b0, irq_TIMER[3:1], irq_I2C, irq_SPI, irq_UART, 4&#x27;b0, irq_external_i, 3&#x27;b0, irq_TIMER[0], 3&#x27;b0, irq_software_i, 3&#x27;b0}),
//           11         1           1         2         1      3         1           3         1          3         1          3      = 31+1
//           [31:21]    [20]        [19]   [18:17]     [16]   [15:13]    [11]      [10:8]       [7]       [6:4]    [3]        [2:0]
    .irq_ack_o(),
    .irq_id_o(),

    // Debug Interface
    .debug_req_i(1&#x27;b0),
    .debug_havereset_o(),
    .debug_running_o(),
    .debug_halted_o(),

    // CPU Control Signals
    .fetch_enable_i(1&#x27;b1),
    .core_sleep_o()
);

    arm_bus_top  u_arm_bus_top (
        .HRESETn(rst_ni),
        .HCLK(clk_i),
        .ADDR(host_addr),
        .WE(host_we),
        .REQUST(host_req),
        .WDATA(host_wdata),
        .SIZE(host_be),
        .RDATA(host_rdata),
        .GRANT(host_gnt),
        .RVALID(host_rvalid),
        .ERROR(host_err),
        .data_size(data_size_o),
        .data_A(data_addr_o),
        .data_D(data_wdata_o),
        .data_CEN(data_CEN_o),
        .data_WEN(data_WEN_o),
        .data_Q(data_rdata_i),

        .GPIO_PADDR(GPIO_PADDR_o),
        .GPIO_PWDATA(GPIO_PWDATA_o),
        .GPIO_PWRITE(GPIO_PWRITE_o),
        .GPIO_PENABLE(GPIO_PENABLE_o),
        .GPIO_PSEL(GPIO_PSEL_o),
        .GPIO_PRDATA(GPIO_PRDATA_i),   
	      .UART_PADDR(UART_PADDR_o),
	      .UART_PWDATA(UART_PWDATA_o),
	      .UART_PWRITE(UART_PWRITE_o),
	      .UART_PENABLE( UART_PENABLE_o),
	      .UART_PSEL(UART_PSEL_o),
	      .UART_PRDATA(UART_PRDATA_i),
        .SPI_PADDR(SPI_PADDR_o),
        .SPI_PWDATA(SPI_PWDATA_o),
        .SPI_PWRITE(SPI_PWRITE_o),
        .SPI_PENABLE(SPI_PENABLE_o),
        .SPI_PSEL(SPI_PSEL_o),
        .SPI_PRDATA(SPI_PRDATA_i),
        .I2C_PADDR(I2C_PADDR_o),
        .I2C_PWDATA(I2C_PWDATA_o),
        .I2C_PWRITE(I2C_PWRITE_o),
        .I2C_PENABLE(I2C_PENABLE_o),
        .I2C_PSEL(I2C_PSEL_o),
        .I2C_PRDATA(I2C_PRDATA_i),
        .TIMER_PADDR(TIMER_PADDR_o),
        .TIMER_PWDATA(TIMER_PWDATA_o),
        .TIMER_PWRITE(TIMER_PWRITE_o),
        .TIMER_PENABLE(TIMER_PENABLE_o),
        .TIMER_PSEL(TIMER_PSEL_o),
        .TIMER_PRDATA( TIMER_PRDATA_i)
    );

endmodule
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>SoC peripherals (soc_peripherals.sv)</summary>
      <div class="code-content"><pre><code>module soc_peripherals(
    input logic clk_sys,
    input logic rstn_sys,

    input logic scan_cg_en_i,
    
    input logic imem_rvalid_o,
    input logic [31:0] imem_rdata_o,
    output logic core2imem_req,
    output logic [31:0] core2imem_addr,

    input logic [31:0] dmem_rdata_o,
    output logic core2dmem_cen,
    output logic core2dmem_wen,
    output logic [3:0] core2dmem_size,
    output logic [15:0] core2dmem_addr,
    output logic [31:0] core2dmem_wdata,

    //GPIO
    input logic [7:0] gpio_pins_i,
    output logic [7:0] gpio_pins_o,
    output logic [7:0] gpio_dir,


    //UART
    input logic rx_i,
    output logic tx_o,

    //SPI
    input logic MISO,
    output logic CSN,
    output logic SCLK,
    output logic MOSI,

    //I2C
    input logic SCL_i,
    input logic SDA_i,
    output logic SDA_o,
    output logic SCL_o,
    output logic sda_dir,
    output logic scl_dir
    );


    // GPIO
    logic [12:0] core2GPIO_PADDR;
    logic [31:0] core2GPIO_PWDATA;
    logic [31:0] core2GPIO_PRDATA;
    logic core2GPIO_PWRITE;
    logic [2:0] core2GPIO_PSEL;
    logic core2GPIO_PENABLE;

    // UART
    logic [12:0] core2UART_PADDR;
    logic [31:0] core2UART_PWDATA;
    logic core2UART_PWRITE;
    logic core2UART_PENABLE;
    logic [2:0] core2UART_PSEL;
    logic [31:0] core2UART_PRDATA;
    logic INT_UART;

    // SPI
    logic [12:0] core2SPI_PADDR;
    logic [31:0] core2SPI_PWDATA;
    logic [31:0] core2SPI_PRDATA;
    logic core2SPI_PWRITE;
    logic [2:0] core2SPI_PSEL;
    logic core2SPI_PENABLE;
    logic [1:0] INT_SPI;


    //I2C Signals
    logic [12:0] core2I2C_PADDR;
    logic [31:0] core2I2C_PWDATA;
    logic [31:0] core2I2C_PRDATA;
    logic core2I2C_PWRITE;
    logic [2:0] core2I2C_PSEL;
    logic core2I2C_PENABLE;
    logic INT_I2C;


    //Timer Signals
    logic [12:0] core2TIMER_PADDR;
    logic [31:0] core2TIMER_PWDATA;
    logic [31:0] core2TIMER_PRDATA;
    logic core2TIMER_PWRITE;
    logic [2:0] core2TIMER_PSEL;
    logic core2TIMER_PENABLE;
    logic [3:0] INT_TIMER;
    logic scl_dir_n, sda_dir_n;


    assign scl_dir = ~scl_dir_n;
    assign sda_dir = ~sda_dir_n;

    soc_bus soc_bus(
        .clk_i(clk_sys),
        .rst_ni(rstn_sys),
        .instr_req_o(core2imem_req),
        .instr_addr_o(core2imem_addr),
        .instr_rvalid_i(imem_rvalid_o),
        .instr_rdata_i(imem_rdata_o),
        .data_size_o(core2dmem_size),
        .data_addr_o(core2dmem_addr),
        .data_wdata_o(core2dmem_wdata),
        .data_CEN_o(core2dmem_cen),
        .data_WEN_o(core2dmem_wen),
        .data_rdata_i(dmem_rdata_o),
        .irq_software_i(1&#x27;b0),
        .irq_external_i(1&#x27;b0),
        .irq_nm_i(1&#x27;b0),
        .GPIO_PADDR_o(core2GPIO_PADDR),
        .GPIO_PWDATA_o(core2GPIO_PWDATA),
        .GPIO_PWRITE_o(core2GPIO_PWRITE),
        .GPIO_PENABLE_o(core2GPIO_PENABLE),
        .GPIO_PSEL_o(core2GPIO_PSEL),
        .GPIO_PRDATA_i(core2GPIO_PRDATA),
        .UART_PADDR_o(core2UART_PADDR),
        .UART_PWDATA_o(core2UART_PWDATA),
        .UART_PWRITE_o(core2UART_PWRITE),
        .UART_PENABLE_o(core2UART_PENABLE),
        .UART_PSEL_o(core2UART_PSEL),
        .UART_PRDATA_i(core2UART_PRDATA),
        .SPI_PADDR_o(core2SPI_PADDR),
        .SPI_PWDATA_o(core2SPI_PWDATA),
        .SPI_PWRITE_o(core2SPI_PWRITE),
        .SPI_PENABLE_o(core2SPI_PENABLE),
        .SPI_PSEL_o(core2SPI_PSEL),
        .SPI_PRDATA_i(core2SPI_PRDATA),
        .I2C_PADDR_o(core2I2C_PADDR),
        .I2C_PWDATA_o(core2I2C_PWDATA),
        .I2C_PWRITE_o(core2I2C_PWRITE),
        .I2C_PENABLE_o(core2I2C_PENABLE),
        .I2C_PSEL_o(core2I2C_PSEL),
        .I2C_PRDATA_i(core2I2C_PRDATA),
        .TIMER_PADDR_o(core2TIMER_PADDR),
        .TIMER_PWDATA_o(core2TIMER_PWDATA),
        .TIMER_PWRITE_o(core2TIMER_PWRITE),
        .TIMER_PENABLE_o(core2TIMER_PENABLE),
        .TIMER_PSEL_o(core2TIMER_PSEL),
        .TIMER_PRDATA_i(core2TIMER_PRDATA),
        .irq_UART(INT_UART),
        .irq_SPI(INT_SPI),
        .irq_I2C(INT_I2C),
        .irq_TIMER(INT_TIMER),
        .scan_cg_en_i(scan_cg_en_i)
    );


    apb_spi_master spi(
     .HCLK(clk_sys),
     .HRESETn(rstn_sys),
     .PADDR(core2SPI_PADDR[11:0]),
     .PWDATA(core2SPI_PWDATA),
     .PWRITE(core2SPI_PWRITE),
     .PSEL(core2SPI_PSEL[0]),
     .PENABLE(core2SPI_PENABLE),
     .PRDATA(core2SPI_PRDATA),
     .spi_sdi0(MISO), 
     .spi_sdi1(1&#x27;b0),
     .spi_sdi2(1&#x27;b0),
     .spi_sdi3(1&#x27;b0),		
     .events_o(INT_SPI),
     .spi_clk(SCLK),
     .spi_mode(),
     .spi_csn0(CSN),
     .spi_csn1(),
     .spi_csn2(),
     .spi_csn3(),
     .spi_sdo0(MOSI),
     .spi_sdo1(),
     .spi_sdo2(),
     .spi_sdo3()
    );

    apb_uart_sv uart(
        .CLK(clk_sys),
        .RSTN(rstn_sys),
        .PADDR({2&#x27;b0, core2UART_PADDR[11:2]}),
        .PWDATA(core2UART_PWDATA),
        .PWRITE(core2UART_PWRITE),
        .PSEL(core2UART_PSEL[0]),
        .PENABLE(core2UART_PENABLE),
	    .PRDATA(core2UART_PRDATA),
        .rx_i(rx_i), 
        .tx_o(tx_o), 
        .event_o(INT_UART)   
    );

    gpio_top gpio(
        .HCLK(clk_sys),
        .HRESETn(rstn_sys),
        .dft_cg_enable_i(1&#x27;b0),
        .PADDR(core2GPIO_PADDR[11:0]),
        .PWDATA(core2GPIO_PWDATA),
        .PWRITE(core2GPIO_PWRITE),
        .PSEL(core2GPIO_PSEL[0]),
        .PENABLE(core2GPIO_PENABLE),
        .PRDATA(core2GPIO_PRDATA),
        .PREADY(),
        .PSLVERR(),
        .gpio_in(gpio_pins_i),
        .gpio_in_sync(),
        .gpio_out(gpio_pins_o),
        .gpio_dir(gpio_dir),
        .gpio_padcfg(),
        .interrupt()
    );

    apb_i2c i2c(
        .HCLK(clk_sys),
        .HRESETn(rstn_sys),
        .PADDR(core2I2C_PADDR[11:0]),
        .PWDATA(core2I2C_PWDATA),
        .PWRITE(core2I2C_PWRITE),
        .PSEL(core2I2C_PSEL[0]),
        .PENABLE(core2I2C_PENABLE),
        .PRDATA(core2I2C_PRDATA),
        .PREADY(),
        .PSLVERR(),
        .interrupt_o(INT_I2C),
        .scl_pad_i(SCL_i),
        .scl_pad_o(SCL_o),
        .scl_padoen_o(scl_dir_n),
        .sda_pad_i(SDA_i),
        .sda_pad_o(SDA_o),
        .sda_padoen_o(sda_dir_n)
    );

    apb_timer timer(
        .HCLK(clk_sys),
        .HRESETn(rstn_sys),
        .PADDR(core2TIMER_PADDR[11:0]),
        .PWDATA(core2TIMER_PWDATA),
        .PWRITE(core2TIMER_PWRITE),
        .PSEL(core2TIMER_PSEL[0]),
        .PENABLE(core2TIMER_PENABLE),
        .PRDATA(core2TIMER_PRDATA),
        .PREADY(),
        .PSLVERR(),
        .irq_o(INT_TIMER)
    );



endmodule
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>Memory + peripheral subsystem (soc_mem.sv)</summary>
      <div class="code-content"><pre><code>module soc_mem(
    //Clock and Reset
    input logic clk_sys,
    input logic rstn_sys,

    input logic scan_cg_en_i,
    
    //IMEM Scan Chain
    input sc2imem_ctrl,
    input sc2imem_clk,
    input sc2imem_req,
    input sc2imem_wen,
    input [31:0] sc2imem_addr,
    input [31:0] sc2imem_wdata,
    output [31:0] imem_rdata_o,

    //DMEM Scan Chain
    input sc2dmem_ctrl,
    input sc2dmem_clk,
    input sc2dmem_req,
    input sc2dmem_wen,
    input [3:0] sc2dmem_ben,
    input [31:0] sc2dmem_addr,
    input [31:0] sc2dmem_wdata,
    output [31:0] dmem_rdata_o,

   //GPIO
    input logic [7:0] gpio_pins_i,
    output logic [7:0] gpio_pins_o,
    output logic [7:0] gpio_dir,


    //UART
    input logic rx_i,
    output logic tx_o,

    //SPI
    input logic MISO,
    output logic CSN,
    output logic SCLK,
    output logic MOSI,

    //I2C
    input logic SCL_i,
    input logic SDA_i,
    output logic SDA_o,
    output logic SCL_o,
    output logic sda_dir,
    output logic scl_dir
);

logic core2imem_req;
logic [31:0] core2imem_addr;
logic imem_rvalid_o;
logic [3:0] core2dmem_size;
logic core2dmem_cen;
logic core2dmem_wen;
logic [15:0] core2dmem_addr;
logic [31:0] core2dmem_wdata;
logic dmem_rvalid_o;

imem_wrapper imem (
    .clk_i(clk_sys),
    .sc2imem_clk(sc2imem_clk),
    .rst_ni(rstn_sys),
    .RETN(1&#x27;b1),
    .EMA(3&#x27;b1),
    .core2imem_req(core2imem_req),
    .core2imem_addr(core2imem_addr),
    .sc2imem_ctrl(sc2imem_ctrl),
    .sc2imem_req(sc2imem_req),
    .sc2imem_addr(sc2imem_addr),
    .sc2imem_wen(sc2imem_wen),
    .sc2imem_wdata(sc2imem_wdata),
    .imem_rvalid_o(imem_rvalid_o),
    .imem_rdata_o(imem_rdata_o)
);

dmem_wrapper dmem (
    .clk_i(clk_sys),
    .sc2dmem_clk(sc2dmem_clk),
    .rst_ni(rstn_sys),
    .RETN(1&#x27;b1),
    .EMA(3&#x27;b1),
    .core2dmem_req(core2dmem_cen),
    .core2dmem_addr({16&#x27;b0, core2dmem_addr}),
    .core2dmem_wen(core2dmem_wen),
    .core2dmem_ben(core2dmem_size),
    .core2dmem_wdata(core2dmem_wdata),
    .sc2dmem_ctrl(sc2dmem_ctrl),
    .sc2dmem_req(sc2dmem_req),
    .sc2dmem_ben(sc2dmem_ben),
    .sc2dmem_addr(sc2dmem_addr),
    .sc2dmem_wen(sc2dmem_wen),
    .sc2dmem_wdata(sc2dmem_wdata),
    .dmem_rvalid_o(dmem_rvalid_o),
    .dmem_rdata_o(dmem_rdata_o)
);

soc_peripherals soc_p (
    .clk_sys(clk_sys),
    .rstn_sys(rstn_sys),
    .scan_cg_en_i(scan_cg_en_i),
    .imem_rvalid_o(imem_rvalid_o),
    .imem_rdata_o(imem_rdata_o),
    .core2imem_req(core2imem_req),
    .core2imem_addr(core2imem_addr),
    .dmem_rdata_o(dmem_rdata_o),
    .core2dmem_cen(core2dmem_cen),
    .core2dmem_wen(core2dmem_wen),
    .core2dmem_size(core2dmem_size),
    .core2dmem_addr(core2dmem_addr),
    .core2dmem_wdata(core2dmem_wdata),
    .gpio_pins_i(gpio_pins_i),
    .gpio_pins_o(gpio_pins_o),
    .gpio_dir(gpio_dir),
    .rx_i(rx_i),
    .tx_o(tx_o),
    .MISO(MISO),
    .CSN(CSN),
    .SCLK(SCLK),
    .MOSI(MOSI),
    .SCL_o(SCL_o),
    .SDA_o(SDA_o),
    .SDA_i(SDA_i),
    .SCL_i(SCL_i),
    .scl_dir(scl_dir),
    .sda_dir(sda_dir)
);

endmodule
</code></pre></div>
    </details>


    <details class="code-block">
      <summary>SoC top level (soc_top.sv)</summary>
      <div class="code-content"><pre><code>module soc_top(
    
    //Voltage Supply
    inout VDD_CORE,
    inout VDD_TEST,
    inout VSS,

    //Clock
    input logic clk_i,
    input clk_ext,
    output logic cnt_o,

    input logic scan_cg_en_i,

    //Reset
    input logic rstn_io,

    //Scan Chain Signals
    input logic phi_sc,
    input logic phi_bar_sc,
    input logic scan_i0o1_sc,
    input logic load_sc,
    input logic scan_in_sc,
    output logic scan_out_sc,

    //GPIO
    output logic [7:0] gpio_pins_o,
    input logic [7:0] gpio_pins_i,
    output logic [7:0] gpio_dir,

    //UART
    input logic rx_i,
    output logic tx_o,

    //SPI
    input logic MISO,
    output logic CSN,
    output logic SCLK,
    output logic MOSI

    //I2C
//  output logic SCL_o,
//  output logic SDA_o,
//  input logic SCL_i,
 // input logic SDA_i,
 // output logic sda_dir,
//  output logic scl_dir
    );

    //IMEM Signals
    logic sc2imem_clk;
    logic sc2imem_ctrl;
    logic sc2imem_reqn; //Active Low
    logic sc2imem_wen; //Active Low
    logic [31:0] sc2imem_addr;
    logic [31:0] sc2imem_wdata;
    logic [31:0] imem_rdata_o;

    //DMEM Signals
    logic sc2dmem_clk;
    logic sc2dmem_ctrl;
    logic sc2dmem_reqn; //Active Low
    logic sc2dmem_wen; //Active Low
    logic [3:0] sc2dmem_ben; //Active Low
    logic [31:0] sc2dmem_addr;
    logic [31:0] sc2dmem_wdata;
    logic [31:0] dmem_rdata_o;

    //General Scan Chain Signals
    logic phi_out_sc;
    logic phi_bar_out_sc;
    logic scan_i0o1_out_sc;
    logic load_out_sc;

    //FSM Signals
    logic clk2fsm;
    logic sc2fsm_mode;
    logic sc2fsm_indef;
    logic [31:0] sc2fsm_cycle;

    //Clock Gen Signals
    logic clk;
    wire en_cnt_from_sc;
    wire [3:0] div_from_sc;
    wire [4:0] fc_from_sc;

//edit 2025.5.12
wire vss_i2c;
assign vss_i2c=VSS;

    soc_mem soc_m(
        .clk_sys(clk),
        .rstn_sys(rstn_io),
        .sc2imem_ctrl(sc2imem_ctrl),
        .sc2imem_clk(sc2imem_clk),
        .sc2imem_req(sc2imem_req),
        .sc2imem_wen(sc2imem_wen),
        .sc2imem_addr(sc2imem_addr),
        .sc2imem_wdata(sc2imem_wdata),
        .imem_rdata_o(imem_rdata_o),
        .sc2dmem_ctrl(sc2dmem_ctrl),
        .sc2dmem_clk(sc2dmem_clk),
        .sc2dmem_req(sc2dmem_req),
        .sc2dmem_wen(sc2dmem_wen),
        .sc2dmem_ben(sc2dmem_ben),
        .sc2dmem_addr(sc2dmem_addr),
        .sc2dmem_wdata(sc2dmem_wdata),
        .dmem_rdata_o(dmem_rdata_o),
        .gpio_pins_i(gpio_pins_i),
        .gpio_pins_o(gpio_pins_o),
        .gpio_dir(gpio_dir),
        .rx_i(rx_i),
        .tx_o(tx_o),
        .MISO(MISO),
        .CSN(CSN),
        .SCLK(SCLK),
        .MOSI(MOSI),
        .SCL_o(),
        .SDA_o(),
        .SDA_i(vss_i2c),
        .SCL_i(vss_i2c),
        .scl_dir(),
        .sda_dir(),
        .scan_cg_en_i(scan_cg_en_i)
    );
    
    scan_chain sc(
        .i_imem_rdata(imem_rdata_o),
        .i_dmem_rdata(dmem_rdata_o),
        .sc_en_cnt(en_cnt_from_sc),
        .sc_clkgen_fc(fc_from_sc),
        .sc_clkgen_div(div_from_sc),
	    .sc_fsm_mode(sc2fsm_mode),
	    .sc_fsm_indef(sc2fsm_indef),
	    .sc_fsm_cycle(sc2fsm_cycle),
        .sc_imem_ctrl(sc2imem_ctrl),
        .sc_imem_req(sc2imem_req),
        .sc_imem_wen(sc2imem_wen),
        .sc_imem_addr(sc2imem_addr),
        .sc_imem_wdata (sc2imem_wdata),
	    .sc_imem_clk(sc2imem_clk),
        .sc_dmem_ctrl(sc2dmem_ctrl),
        .sc_dmem_req(sc2dmem_req),
        .sc_dmem_wen(sc2dmem_wen),
        .sc_dmem_addr(sc2dmem_addr),
	    .sc_dmem_ben(sc2dmem_ben),
        .sc_dmem_wdata (sc2dmem_wdata),
	    .sc_dmem_clk(sc2dmem_clk),
        .phi(phi_sc),
        .phib(phi_bar_sc),
        .scan_i0o1(scan_i0o1_sc),
        .load(load_sc),
        .scan_in(scan_in_sc),
        .scan_out(scan_out_sc),
	    .phi_out(phi_out_sc),
	    .phib_out(phi_bar_out_sc),
	    .load_out(load_out_sc),
	    .scan_i0o1_out(scan_i0o1_out_sc),
        .VDD(VDD_TEST),
        .VSS(VSS)
    );

    test_clkgen clk_gen (
        .VDD(VDD_TEST),
        .VSS(VSS),
        .clk_ext(clk_ext),
        .clk_out(clk2fsm),
        .en_cnt(en_cnt_from_sc),
        .cnt_out(cnt_o),
        .en_int(clk_i),
        .div0(div_from_sc[0]),
        .div1(div_from_sc[1]),
        .div2(div_from_sc[2]),
        .div3(div_from_sc[3]),
        .fc0(fc_from_sc[0]),
        .fc1(fc_from_sc[1]),
        .fc2(fc_from_sc[2]),
        .fc3(fc_from_sc[3]),
        .fc4(fc_from_sc[4])
    );

    debug_fsm dfsm (
        .i_clk(clk2fsm),
	    .i_rstn(rstn_io),
	    .i_mode(sc2fsm_mode),
	    .i_indef(sc2fsm_indef),
	    .i_cycle(sc2fsm_cycle),
	    .o_clk(clk)
    );


endmodule
</code></pre></div>
    </details>

    <h3>Design Verification</h3>
    <p>The verification of the SoC followed a directed-test methodology using a custom SystemVerilog testbench together with C-based test programs compiled for the RISC-V architecture. Instead of building a full UVM environment, we adopted a focused, system-driven verification approach that closely matches the behavior of the real chip during board-level bring-up. This allowed us to validate both the functional design and the DFT infrastructure under realistic operating conditions.</p>
    <p>All test cases were written as C programs, compiled using the RISC-V GCC toolchain, and executed directly on the embedded CV32E40P CPU core. These tests exercise the RTL in the same way real firmware will, enabling software-driven verification of processor execution, memory behavior, bus transactions, and peripheral functionality. A variety of targeted test programs were developed to isolate and validate individual modules—including DMEM read/write patterns, SPI transfers, UART transmission, GPIO toggling, I²C transactions, and timer interrupts. In addition to unit-level tests, we also created integrated programs that combine multiple peripherals and CPU-bus interactions to ensure correct end-to-end system behavior. More details of the test program structure and software toolchain will be described in the Software section.</p>
    <p>The SystemVerilog testbench models the full bring-up sequence of the physical chip. Before each run, the testbench assembles the 248-bit scan-in vector by organizing the scan chain fields according to their functional purposes, including IMEM contents, DMEM initialization, clock generator configuration, and FSM mode bits. Verification begins with a global reset, followed by placing the internal FSM into scan mode so that the testbench can shift instructions and configuration data into the scan chain. Once the scan load is complete, the FSM transitions into run mode, enabling the CPU to fetch instructions from IMEM and execute the compiled C program. Waveforms are monitored during execution to observe CPU behavior, AHB and APB transactions, peripheral activity, and memory accesses, ensuring architectural and protocol correctness.</p>
    <p>After program execution finishes, the FSM is switched back into scan mode to shift out DMEM data. By comparing the scanned-out results against the expected outputs generated by the C testcase, we verify the correctness of program execution, the integrity of the scan chain, and the functionality of the memory wrappers. This verification flow—reset → scan-in → run → scan-out—exactly mirrors the operational steps used during post-silicon bring-up, ensuring a high degree of consistency between pre-silicon simulation and hardware validation.
</p>
      <img src="../images/nanologic/dv1.png" alt="hierarchy">
      <p class="caption">Figure 7. GPIO Write Test Case</p>

      <img src="../images/nanologic/dv2.png" alt="DC - Total Cell Area">
      <p class="caption">Figure 7. GPIO READ and Memory Test Case</p>

      <img src="../images/nanologic/dv3.png" alt="DC - Total Cell Area" >
      <p class="caption">Figure 7. Chip Design Flow</p>

    <h3>Synthesis</h3>
    <p>The synthesis stage translated the RTL design into a gate-level netlist using the TSMC 65 nm standard-cell library. Before synthesis, the RTL underwent linting and cleanup to ensure complete synthesizability and consistent signal definitions across modules. We constructed a comprehensive set of timing and design constraints, including the system clock specification, input and output delays, false-path and multicycle-path declarations, and mode-specific constraints for both functional and scan operation. These constraints ensured that the synthesis tool accurately captured the intended timing behavior of the SoC across all subsystems.
</p>
    <p>During synthesis, the memory wrappers were configured to replace their behavioral models with the actual SRAM hard macros generated by the memory compiler. The wrappers provided the necessary functional and scan-mode interfaces so that the macros could be seamlessly integrated into both the RTL and gate-level flows.</p>
    <p>In our synthesis flow, we follow a hierarchical methodology aligned with the RTL file organization. All IP modules—such as the CPU core, SPI, UART, I2C, GPIO, timer, scan chain, and various FSMs—are synthesized individually to ensure modularity and ease of debugging. When synthesizing the SoC-level design, we include the previously generated netlists for these IP blocks and then proceed with synthesizing the SoC bus, SoC memory subsystem, and SoC top, together with the SRAM integration files.</p>
    <p>For each test case, we perform post-synthesis gate-level simulation to validate functional correctness. Due to several modules exhibiting hold-time violations, not all test cases pass at this stage. These hold issues are expected and will be resolved during the physical design (PD) stage through proper buffering and timing refinement. Importantly, we ensure that there are no setup-time violations after synthesis, providing a solid timing foundation for the subsequent place-and-route process.</p>
    <p>Following synthesis, we generated reports for area utilization, hierarchical timing, constraint coverage, and scan connectivity. The final synthesized netlist, along with the macro placement constraints and clock definitions, was handed off to the physical design stage for floorplanning and place-and-route. This marked the transition from RTL-level development to backend implementation.</p>
      <img src="../images/nanologic/dc1.png" alt="System block diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br>
      <p class="caption">Figure 7. Chip Design Flow</p>
      <br><br>
      <img src="../images/nanologic/dc2.png" alt="System block diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br>
      <p class="caption">Figure 7. Chip Design Flow</p>

    <h3>Physical Design</h3>
    <p>The physical design of the chip is implemented using Cadence Innovus for place-and-route and Cadence Virtuoso for final layout verification. We adopt a relatively simple but structured floorplan. The core complex, including the CPU core, system bus, and peripheral modules, is laid out as a single main block located at the center of the die. The instruction memory (IMEM) and data memory (DMEM) are implemented as two dedicated rectangular SRAM macros placed on the left and right sides of the core, respectively, to minimize critical-path interconnect length between the processor and the memories. The FSM, clock generation logic, and scan chain controller are grouped together and placed along one side of the chip. Since these blocks share the same power domain, this placement simplifies power distribution and also provides a clean topology for scan chain routing toward the rest of the design. IO pads are inserted along all four edges of the chip to interface the internal logic with the external environment and to close the power ring.
</p>
    <p>Our physical design flow in Innovus follows a standard industrial methodology. We begin by creating the floorplan, defining the core area and placing the major macros according to the architecture partition described above. Next, we generate the global and local power rails, ensuring robust power delivery to all modules in the single power domain. After that, we define and constrain all input and output ports, including timing constraints and IO placement guidelines. The standard-cell placement step is then performed, followed by pre-CTS (clock tree synthesis) optimization to reduce congestion, fix early timing issues, and improve design quality before building the clock tree.</p>
    <p>We then perform clock tree synthesis to distribute the clock to all sequential elements while controlling skew and insertion delay. A round of post-CTS optimization is run to clean up timing violations that emerge after the clock network is inserted. Once the clocks and standard cells are in good shape, we proceed to signal routing, including global and detailed routing, to connect all nets while honoring design rules. After routing, we run extraction to generate accurate parasitic (RC) information and conduct further timing and design optimizations. At this stage, decoupling capacitors and filler cells are inserted as needed to maintain power integrity, close metal density requirements, and ensure manufacturability. Finally, the design goes through a series of verification steps within Innovus (such as basic DRC and timing checks), and the tape-out-ready layout and associated views are exported.</p>
    <p>As mentioned earlier in the synthesis section, some modules exhibited hold-time violations at the netlist level. These issues are systematically resolved during the place-and-route stage. Using post-route parasitic information, we perform hold-fixing in Innovus by inserting delay cells and adjusting routing where necessary. Our goal is to eliminate all hold-time violations while preserving setup-time margins, so that the final implementation is both functionally correct and timing-clean under the target operating conditions.</p>
    <p>After the place-and-route flow is completed, the final layout is imported into Cadence Virtuoso for signoff-level physical verification. We perform full-layout DRC (Design Rule Check) and LVS (Layout Versus Schematic) to ensure that the layout is free of rule violations and is electrically consistent with the synthesized netlist. In addition, we back-annotate the extracted delay information into our simulation environment and re-run the full set of test cases at the gate-level with timing. All test cases are verified to pass with correct waveforms and converged timing behavior, providing strong confidence in both functionality and implementation quality.</p>
    <p>For timing signoff, we use Synopsys PrimeTime to perform static timing analysis across the relevant process, voltage, and temperature corners. Based on the extracted parasitics from the routed layout, we verify that no setup or hold violations remain on any timing path and that there are no additional issues such as excessive clock skew or unconstrained paths. Through this combination of Innovus PnR, Virtuoso physical verification, gate-level simulations with back-annotated delays, and PrimeTime static timing analysis, we ensure that the design is ready for fabrication with clean physical, functional, and timing signoff.</p>
    <img src="../images/nanologic/pd1.png" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Core & Bus & Pheripherals Layout</p>
    <img src="../images/nanologic/pd_sc.png" alt="layout diagram">
    <p class="caption">Figure ?. Scan Chain Layout</p>
    <p>In our physical design, the standard vertical power rails for each small module are implemented at metal layer M6, while the horizontal local power routing within the modules uses M1. Because the soc_mem block—which contains the CPU core, peripherals, and the two memory macros—also relies on vertically oriented power rails, its power grid must be precisely aligned with the internal module rails. Even a small offset would cause DRC violations due to misaligned straps or insufficient metal overlap. At the chip’s top level (soc_pin), the global power distribution network transitions to a higher metal layer, where wide horizontal power rails are used to provide low-resistance current delivery across the full SoC. This hierarchical alignment of vertical and horizontal power structures ensures correct connectivity, prevents DRC errors, and supports stable power distribution throughout the design.</p>
    <img src="../images/nanologic/layout.png" alt="layout diagram">
    <img src="../images/nanologic/layout2.png" alt="layout diagram">
    <p class="caption">Figure ?. Layout Pictures</p>
    
    <h3>Packaging Overview</h3>
    <p>The fabricated die has dimensions of 1000 µm × 2000 µm, and contains a total of 66 bond pads distributed symmetrically around the four sides of the chip. The pad arrangement consists of 25 pads on the north side, 25 pads on the south side, 8 pads on the west side, and 8 pads on the east side, providing full access to power rails, I/O interfaces, clocks, scan signals, and debug ports.
</p>
    <p>Each bond pad follows the standard TSMC 65 nm pad-frame specification. The nominal pad opening is 60 µm × 190 µm, or 30 µm × 190 µm when excluding the spacing region. This ensures compatibility with conventional gold wire bonding processes used in QFP and LQFP packaging flows.</p>
    <p>A total of 20 dies will be packaged, with the primary package type selected as LQFP64L, which provides sufficient lead-out pins for all I/O and supply connections while maintaining a compact and low-cost footprint suitable for PCB mounting and system-level testing. The pad-to-pin mapping has been verified to comply with the 64-pin lead frame configuration.
      <br><br>
    <em>Power and Ground Bonding</em><br>
    All VSS pads are highlighted in magenta in the bond diagram and are down-bonded directly to the exposed paddle, ensuring a low-impedance return path for the core and I/O grounds. This improves noise performance, reduces supply bounce during high-activity conditions, and provides robust ESD protection. The VDD rails are bonded individually to dedicated package pins to allow independent supply measurement and external regulation.
    </p>
    <p>
          <em>Bonding Diagram and Pinout</em><br>
        The bonding diagram shows the complete mapping between die pads and LQFP64L pins. Power, ground, GPIO, SPI, UART, scan chains, and test signals are organized to minimize crossing wires and to maintain short bond lengths. This arrangement improves manufacturability, reduces parasitic inductance, and enhances reliability.
    </p>
    <img src="../images/nanologic/bond_table.png" alt="layout diagram">
        <p class="caption">Figure ?. Bond Table</p>
        <img src="../images/nanologic/bond_diagram.png" alt="layout diagram" style="display:block; margin:0 auto; width:80%; height:auto;"><br>
            <p class="caption">Figure ?. Bond Diagram</p>
  </section>
  
  <section id="software">
    <h2>Software & Testing Flow</h2>
     <p class="instruction-text"> 
The software development and testing workflow begins with writing programs in C, which serve as test cases for validating the functionality of our SoC. To support this, we built a complete RISC-V toolchain, including a customized linker script and memory configuration. Since our design follows a Harvard architecture with separate instruction memory (IMEM) and data memory (DMEM), the toolchain is configured to correctly place code sections into IMEM and data sections into DMEM. The RISC-V compiler translates C programs into machine code, while also generating assembly output to assist with debugging and instruction-level verification.
      Once the C programs are compiled, the resulting machine code is loaded into the chip through the scan chain. During scan mode, the scan chain shifts the instructions directly into the IMEM and DMEM. After switching to run mode, the CPU begins fetching instructions from IMEM and executing them, allowing us to verify full-system behavior.
     </p>

      <img src="../images/nanologic/sw_flow.png" alt="layout diagram"><br>
    <p class="caption">Figure ?. Chip Software Flow </p><br>
    <h3>Software Development</h3>
   <h4>Compiler:</h4>
    <p>Our implementation of the CV32E40P core supports the RV32IMC instruction sets, and we built the corresponding RISC-V toolchain in order to compile C programs to run on our chip. We built the compiler before abandoning the FPU, so it also supports RV32Zfinx, which we simply don’t specify support for in our final bash script that calls the compiler.</p>

    <h4>Linker:</h4>
    <p>The linker is where things get a bit more complicated. GCC is designed for modified-Harvard and von-Neumann architectures, whereas our chip uses a pure Harvard Architecture. Our IMEM and DMEM both start at 0x0000_0000 and end at 0x0000_7FFF, which causes a perceived overlap between .text and .data in the linker. Our solution to this issue was to take advantage of the fact that we mask off the upper 16 bits of the word-aligned memory address coming out of the DMEM slave and into the DMEM wrapper.</p>
    <p>As previously mentioned, in the DMEM slave, we shift the address right by 2 bits to ensure it is word-aligned. What was not mentioned is that we truncate the address on both sides, dropping both the lowest 2 bits, for word alignment, and the highest 14 bits, resulting in a 16-bit word-aligned address. A full 16-bit address was used as we designed the bus before finalising the size of our DMEM, and we wanted to leave wiggle room if we ended up having extra space. With our finalised 16KiB DMEM, we just ignore the top 4 bits of that address. </p>
    <p>For our IO mapping, the AHB bus uses the most significant nibble of the 32-bit byte-aligned address coming from the CPU to determine the peripheral we want to talk to, so we need to keep that at 0 for DMEM. The second most significant nibble, however, is not used for routing and is masked off by the DMEM slave, so we set the second most significant nibble to 1, setting the origin of DMEM to 0x0100_0000 in the linker. The following example shows how it works:</p>
    <p>Let's say that we want to write to address 0x4<br>
The byte address is 0x00000004<br>
The word address is 0x0000001<br>
The final masked address is 0x00000001<br>
But what if we wrote to address 0x01000004?<br>
The byte address is 0x01000004<br>
The word address is 0x00400001<br>
The masked address is 0x00000001</p>
    <details class="code-block">
      <summary>Linker script (link.ld)</summary>
      <div class="code-content"><pre><code>/* Copyright lowRISC contributors.
   Licensed under the Apache License, Version 2.0, see LICENSE for details.
   SPDX-License-Identifier: Apache-2.0 */

OUTPUT_ARCH(riscv)
MEMORY
{
    imem  : ORIGIN = 0x00000000, LENGTH = 0x4000          /* 32 kB */
    dmem  : ORIGIN = 0x01000000, LENGTH = 0x4000          /* 32 kB */
}

/* Stack information variables */
_min_stack     = 0x1000;   /* 4K - minimum stack space to reserve */
_stack_len     = LENGTH(dmem);
_stack_start   = ORIGIN(dmem) + LENGTH(dmem);

_entry_point = 0x0;
ENTRY(_entry_point)

SECTIONS
{
    .text : {
        . = ALIGN(4);
        *(.text)
        *(.text.*)
    }  &gt; imem

    .rodata : {
        . = ALIGN(4);
        *(.rodata);
        *(.rodata.*)
    } &gt; dmem 

    .data : {
        . = ALIGN(4);
        *(.data);
        *(.data.*)
    } &gt; dmem

    .bss :
    {
        . = ALIGN(4);
        _bss_start = .;
        *(.bss)
        *(.bss.*)
        *(COMMON)
        _bss_end = .;
    } &gt; dmem

    /* ensure there is enough room for stack */
    .stack (NOLOAD): {
        . = ALIGN(4);
        . = . + _min_stack ;
        . = ALIGN(4);
        stack = . ;
        _stack = . ;
    } &gt; dmem
}
</code></pre></div>
    </details>

    <h4>Startup Handler:</h4>
    <p>With the compiler and linker set up, the next step was to create a startup routine that would reset the chip registers, point to the stack, and jump to the main function in the C program. This was done in assembly in crt0.S.</p>
    <details class="code-block">
      <summary>Startup routine (crt0.S)</summary>
      <div class="code-content"><pre><code># Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

#define EXIT_SYSCALL 93

.section .text

reset_handler:
  /* set all registers to zero */
  mv  x1, x0
  mv  x2, x1
  mv  x3, x1
  mv  x4, x1
  mv  x5, x1
  mv  x6, x1
  mv  x7, x1
  mv  x8, x1
  mv  x9, x1
  mv x10, x1
  mv x11, x1
  mv x12, x1
  mv x13, x1
  mv x14, x1
  mv x15, x1
  mv x16, x1
  mv x17, x1
  mv x18, x1
  mv x19, x1
  mv x20, x1
  mv x21, x1
  mv x22, x1
  mv x23, x1
  mv x24, x1
  mv x25, x1
  mv x26, x1
  mv x27, x1
  mv x28, x1
  mv x29, x1
  mv x30, x1
  mv x31, x1

    /* stack initilization */
  la x2, _stack_start

_start:
  .global _start

  /* clear BSS */
  la x26, _bss_start
  la x27, _bss_end


main_entry:
  /* jump to main program entry point (argc = argv = 0) */
  addi x10, x0, 0
  addi x11, x0, 0
  jal x1, main

  /* If execution ends up here just put the core to sleep */
sleep_loop:
  wfi
  j sleep_loop

</code></pre></div>
    </details>

    <h4>VHX Generator:</h4>
    <p>Ultimately, our programs need to end up as hexcode VHX files representing the raw data to load into IMEM and DMEM. To accomplish this, we have script, run.rv32.bash, which takes the specific C program, the linker, the startup routine, and any C files in our common folder, and compiles and links our C program. Once we have the object file, it is assembled into an ELF file, which is then disassembled into a DASM file and turned into our VHX files.</p>
    <details class="code-block">
      <summary>Build and VHX generation script (run.rv32.bash)</summary>
      <div class="code-content"><pre><code>#!/bin/bash
clear

SRC_MAIN=&quot;src/demo/demo.c&quot;

SRC_COMMON=&quot;common/crt0.S&quot;
MAIN_BASE=&quot;$(basename -- ${SRC_MAIN})&quot;
MAIN_NAME=&quot;${MAIN_BASE%.*}&quot;
ELF=&quot;${MAIN_NAME%.*}.elf&quot;
DASM=&quot;${MAIN_NAME%.*}.dasm&quot;
VHX8=&quot;${MAIN_NAME%.*}.vhx8&quot;
VHX32=&quot;${MAIN_NAME%.*}.vhx32&quot;
VHX=&quot;${MAIN_NAME%.*}.vhx&quot;

VHX8_INST=&quot;${MAIN_NAME%.*}_inst.vhx8&quot;
VHX8_DATA=&quot;${MAIN_NAME%.*}_data.vhx8&quot;
VHX32_INST=&quot;${MAIN_NAME%.*}_inst.vhx32&quot;
VHX32_DATA=&quot;${MAIN_NAME%.*}_data.vhx32&quot;
VHX_INST=&quot;${MAIN_NAME%.*}_inst.vhx&quot;
VHX_DATA=&quot;${MAIN_NAME%.*}_data.vhx&quot;

DIR_OBJ=&quot;obj&quot;
DIR_ELF=&quot;elf&quot;
DIR_DASM=&quot;dasm&quot;
DIR_VHX=&quot;vhx&quot;

PATH_BIN=&quot; /tools/misc/CSEE4824/riscv_zfinx/bin&quot;
CC=&quot;${PATH_BIN}/riscv32-unknown-elf-gcc&quot;
LD=&quot;${CC}&quot;
DUMP=&quot;${PATH_BIN}/riscv32-unknown-elf-objdump&quot;
OBJCP=&quot;${PATH_BIN}/riscv32-unknown-elf-objcopy&quot;
CFLAG=&quot;-march=rv32imc -mabi=ilp32 -static -mcmodel=medany -Wall -g -O0 -fvisibility=hidden -nostdlib -nostartfiles -ffreestanding &quot;
INCS=&quot;-Icommon -Isrc&quot;
LDFILE=&quot;common/link.ld&quot;

rm -rf $DIR_OBJ/*

for DIR in $DIR_OBJ $DIR_DASM $DIR_ELF $DIR_VHX
do
mkdir -p $DIR
done

rm -f $DIR_ELF/$ELF
rm -f $DIR_DASM/$DASM
rm -f $DIR_VHX/$VHX8
rm -f $DIR_VHX/$VHX32


## OBJECT from SOURCE
for FSRC in ${SRC_COMMON} ${SRC_MAIN}
do
SRC_BASE=&quot;$(basename -- $FSRC)&quot;
OBJ_NAME=&quot;${SRC_BASE%.*}&quot;
OBJ=&quot;${OBJ_NAME}.o&quot;
${CC} ${CFLAG} ${INCS} -MMD -c -o ${DIR_OBJ}/${OBJ} ${FSRC}
done

## OBJECT_LIST from OBJECT_FOLDER 
LIST_OBJ=&quot;&quot;
for OBJ_FILE in `ls ${DIR_OBJ}/*.o`
do
LIST_OBJ=&quot;${LIST_OBJ} ${OBJ_FILE}&quot;
done

## ELF from OBJECT_LIST
${LD} ${CFLAG} ${INCS} -T ${LDFILE} -o ${DIR_ELF}/${ELF} ${LIST_OBJ}

## DISASSEMBLY from ELF
${DUMP} -fhSD ${DIR_ELF}/${ELF} &gt; ${DIR_DASM}/${DASM}


## Verilog Hex from ELF
$OBJCP -O verilog ${DIR_ELF}/${ELF} ${DIR_VHX}/${VHX8}
$OBJCP -O verilog --only-section=.vectors  --only-section=.init --only-section=.text ${DIR_ELF}/${ELF} ${DIR_VHX}/${VHX8_INST}
$OBJCP -O verilog --only-section=.rodata --only-section=.data --only-section=.sdata --only-section=.bss --only-section=.stack ${DIR_ELF}/${ELF} ${DIR_VHX}/${VHX8_DATA}

python3 ./scripts/hex8tohex32.py ${DIR_VHX}/${VHX8} &gt; ${DIR_VHX}/${VHX32}
python3 ./scripts/hex8tohex32.py ${DIR_VHX}/${VHX8_INST} &gt; ${DIR_VHX}/${VHX32_INST}
python3 ./scripts/hex8tohex32.py ${DIR_VHX}/${VHX8_DATA} &gt; ${DIR_VHX}/${VHX32_DATA}


grep -v &#x27;^@&#x27; ${DIR_VHX}/${VHX32} &gt;  ${DIR_VHX}/${VHX}
grep -v &#x27;^@&#x27; ${DIR_VHX}/${VHX32_INST} &gt;  ${DIR_VHX}/${VHX_INST}
grep -v &#x27;^@&#x27; ${DIR_VHX}/${VHX32_DATA} &gt;  ${DIR_VHX}/${VHX_DATA}

printf &quot;\n[DBG] Generated Files\n&quot;
ls -lh ${DIR_ELF}/${ELF}
ls -lh ${DIR_VHX}/${VHX}
exit 1
</code></pre></div>
    </details>

    <h4>Software Drivers:</h4>
    <p>There are two files which serve as software drivers for the IO on our chip, nano_logic_utils.c and spi_lcd_driver.h.</p>
    <p>The main software driver is nano_logic_utils.c, which defines register mappings, initialization functions, and various other common functions for each of the peripherals. This driver is used in nearly all of our programs.</p>
    <details class="code-block">
      <summary>nano_logic_utils.c</summary>
      <div class="code-content"><pre><code>/*
The file contains important definitions and functions to be used in writing programs
for our SoC.
*/

#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//Memory Location Definitions

//DMEM
#define DMEM_BASE 0x00000000 //Base address DMEM is mapped to

//GPIO
#define GPIO_BASE 0x10000000 //Base address GPIO is mapped to
#define GPIO_PADDIR 0x10000000 //Set direction of GPIO pins
#define GPIO_EN 0x10000004 //Enable input sampling on GPIO pins
#define GPIO_PADIN 0x10000008 //Read input signals from GPIO pins
#define GPIO_PADOUT 0x1000000C //Set output values of GPIO pins
#define GPIO_PADOUTSET 0x10000010 //Set output of GPIO pins high
#define GPIO_PADOUTCLR 0x10000014 //Set output of GPIO pins low
#define GPIO_INTEN 0x10000018 //Enable interrupts on GPIO pins
#define GPIO_INTTYPE 0x1000001C //Configure interrupt types for GPIO pins
#define GPIO_INTSTATUS 0x10000024 
#define GPIO_PADCFG 0x10000028

//UART
#define UART_BASE 0x20000000 //Base address UART is mapped to
#define UART_LCR 0x2000000C //LCR is used for setting the Divisor Latch Access bit and the data format
#define UART_DLL 0x20000000 //DLL and DLM are used for setting the Baud Rate Divider value
#define UART_DLM 0x20000004 //DLL and DLM are used for setting the Baud Rate Divider value
#define UART_THR 0x20000000 //THR is used for Tx.
#define UART_RBR 0x20000000 //RBR is used for Rx.
#define UART_IER 0x20000004 //IER is set to interrupt the processor
#define UART_FCR 0x20000008 //FCR is used to clear the FIFO
#define UART_IIR 0x20000008 //IIR is used to identify interrupts
#define UART_MCR 0x20000010
#define UART_LSR 0x20000014
#define UART_MSR 0x20000018
#define UART_SCR 0x2000001C

//SPI
#define SPI_BASE 0x30000000 //Base address SPI is mapped to
#define SPI_STATUS 0x30000000 
#define SPI_CLKDIV 0x30000004 //Clock divider value
#define SPI_CMD 0x30000008 
#define SPI_ADR 0x3000000C 
#define SPI_LEN 0x30000010 //Sets the length of DATA, ADDR, and CMD
#define SPI_DUM 0x30000014 
#define SPI_TXFIFO 0x30000018 //FIFO storing value to transmit over MOSI
#define SPI_RXFIFO 0x30000020 //FIFO storing value received via MISO
#define SPI_INTCFG 0x30000024 
#define SPI_INTSTA 0x30000028

//Timers
#define TIMER_BASE 0x50000000 //Base address the Timer Module is mapped to
#define TIMER_0_CNT 0x50000000 //Timer 0 count
#define TIMER_0_CTRL 0x50000004 //Timer 0 control
#define TIMER_0_CMP 0x50000008 //Timer 0 compare
#define TIMER_1_CNT 0x50000020 //Timer 1 count
#define TIMER_1_CTRL 0x50000024 //Timer 1 control
#define TIMER_1_CMP 0x50000028 //Timer 1 compare


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Functions
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


//Functions for Reading from and Writing to a Specific Address
#define ADDR_READ(addr) (*((volatile uint32_t *)(addr)))
#define ADDR_WRITE(addr, val) (*((volatile uint32_t *)(addr)) = val) 




//---------------------------------------------
//GPIO Functions
//---------------------------------------------


// Note: Each GPIO instance occupies a 128-byte block (2^7 bytes).
// Full address = (instance number * 128) + local register offset.

//Used to initialize GPIO for transmission 
void gpio_init() {

    // 1. Set all pins as inputs.
    ADDR_WRITE(GPIO_PADDIR, 0x00);
    
    // 2. Enable input sampling for pins.
    ADDR_WRITE(GPIO_EN, 0xff);
    
    // 3. Clear output values.
    ADDR_WRITE(GPIO_PADOUT, 0x00);
    
    // Optionally, clear any pending output set/clear signals.
    ADDR_WRITE(GPIO_PADOUTCLR, 0xff);  // Clear any outputs 
    ADDR_WRITE(GPIO_PADOUTSET, 0x00);  // Ensure no outputs are forced high
    
    // 4. Disable interrupts.
    // Write 0 to disable all GPIO interrupts.
    ADDR_WRITE(GPIO_INTEN, 0x00);
    
    // 5. Set interrupt type to a default value.
    // Here, 0x00000000 might correspond to a default (e.g., falling-edge or disabled)
    ADDR_WRITE(GPIO_INTTYPE, 0x00);
    
    // 6. Set pad configuration to default.
    ADDR_WRITE(GPIO_PADCFG, 0x00);
}


/*
Set the direction of a single GPIO pin.
&#x27;pin_num&#x27; selects the pin (only lower 3 bits are used, as there are 8 pins).
&#x27;out&#x27; is true for output, false for input.
*/
static inline void gpio_set_pin_dir(uint32_t out) {
    ADDR_WRITE(GPIO_PADDIR, out);
    ADDR_WRITE(GPIO_EN, ~out); //Do we need this line if we set them all to be able to sample in the initialization function?
}

/*
Write a boolean value to a single GPIO pin.
&#x27;data&#x27; true sets the pin high; false clears the pin.
*/
static inline void gpio_pin_write(uint32_t data) {
    ADDR_WRITE(GPIO_PADOUT, data);
}

/*
Read the value from a single GPIO pin.
Returns true if the pin is high, false if low.
*/
static inline uint32_t gpio_pin_read() {
    return ADDR_READ(GPIO_PADIN);
}


//---------------------------------------------
//UART Functions
//---------------------------------------------



//Used to initialize UART for byte-wise transmission. 
void uart_init() {

    ADDR_WRITE(UART_LCR, 0x00000081); 

    ADDR_WRITE(UART_DLL, 0x00000059);
    ADDR_WRITE(UART_DLM, 0x00000022);
    //Baud rate of 9600 for 84.414MHz clock speed. (Baud rate = clk_freq/DLM:DLL)

    //Sending one byte at a time
    ADDR_WRITE(UART_LCR, 0x00000003);
    ADDR_WRITE(UART_THR, 0x0000000A);	
	ADDR_WRITE(UART_THR, 0x0000000A);	
	ADDR_WRITE(UART_THR, 0x0000000A);	
	ADDR_WRITE(UART_THR, 0x0000000A);	
	ADDR_WRITE(UART_THR, 0x0000000A);	
	ADDR_WRITE(UART_THR, 0x0000000A);	
}

/*
Used to transmit a byte over UART, note that the byte is transmitted LSB first.

Takes an 8-bit value data which is the byte to be transmitted
*/
static inline void uart_transmit_char(uint8_t data) {
    ADDR_WRITE(UART_THR, data);
}

//---------------------------------------------
//SPI Functions
//---------------------------------------------

//Used to initialize SPI for transmission 
void spi_init(){
    //Setting length of DATA, ADDR, CMD to one byte each
    ADDR_WRITE(SPI_LEN, 0x00080808); 
    
    ADDR_WRITE(SPI_CLKDIV, 0x000000FF);
}

/*
Used to transmit a packet over SPI

Takes a 1-byte command, 1-byte address, and 1-byte data value to be transmitted over SPI
*/
static inline void spi_transmit(uint8_t cmd, uint8_t adr, uint8_t data){
    ADDR_WRITE(SPI_CMD, cmd &lt;&lt; 24);
    ADDR_WRITE(SPI_ADR, adr &lt;&lt; 24);
    ADDR_WRITE(SPI_TXFIFO, data &lt;&lt; 24);
    ADDR_WRITE(SPI_STATUS, 0x00000102);
}

//---------------------------------------------
//Timer Functions
//---------------------------------------------

/*
Used to (re)start the count of the specified timer from 0.

Takes in a bool timer which specifies which timer, 0 or 1,
should be (re)started
*/
void timer_reset_and_start(bool timer) {
    if (timer) {

        //Reset timer 1 count to 0
        ADDR_WRITE(TIMER_1_CNT, 0x00000000);

        //Enable timer 1
        ADDR_WRITE(TIMER_1_CTRL, 0x00000019);
    }
    else {
        //Reset timer 0 count to 0
        ADDR_WRITE(TIMER_0_CNT, 0x00000000);

        //Enable timer 0
        ADDR_WRITE(TIMER_0_CTRL, 0x00000019);
    }
}

/*
Used to read the current count value of the specified timer.

Takes in a bool timer which specifies which timer, 0 or 1,
should be read
*/
static inline uint32_t timer_read(bool timer) {
    if (timer) return ADDR_READ(TIMER_1_CNT);
    else return ADDR_READ(TIMER_0_CNT);
}

/*
void timer_set_compare(bool timer, uint32_t comp) {
    if (timer) ADDR_WRITE(TIMER_1_CMP, comp);
    else ADDR_WRITE(TIMER_0_CMP, comp);
}
*/


//---------------------------------------------
//Delay Functions
//---------------------------------------------
static inline void delay(int n) {
    // Simple delay loop (adjust based on your system clock)
    volatile int i;
    for (i = 0; i &lt; n * 100; i++) {}
}

// ------------ UART helpers (single-char only) ------------
  static void uart_putc(char c) {
      uart_transmit_char((uint8_t)c);
  }
  </code></pre></div>
    </details>
    <p>The other software driver, spi_lcd_driver.h, is responsible for defining functions to control the SPI LCD backup. </p>
    <details class="code-block">
      <summary>spi_lcd_driver.h</summary>
      <div class="code-content"><pre><code>// Code based on spi_lcd.h from https://gitfront.io/r/lafis002/nsQYcfC2svzE/iRisc/

#include &quot;nano_logic_utils.c&quot; 

#define HIGH 1
#define LOW 0

volatile uint32_t SPIbuff;
volatile uint8_t  displaycontrol;

void long_delay(int n) {
	volatile int i;
	for (i = 0; i &lt; n * 1000; i++) {}
}

void spi_write(volatile uint32_t cmd, volatile uint8_t DELAY){
	ADDR_WRITE(SPI_CMD, cmd); //8 bits of CMD we want to send to LCD
	ADDR_WRITE(SPI_ADR, cmd); //8 bits of ADDR we want to send to LCD
	ADDR_WRITE(SPI_TXFIFO, cmd); 
	ADDR_WRITE(SPI_STATUS, 0x00000102); //Enable the clk to peripheral (SPI clk). Bit [1] set to enable spi_wr mode, and bit [8] set to chip select LCD. 
	long_delay(DELAY);
}


void lcd_init(volatile uint8_t DELAY) {


	ADDR_WRITE(SPI_LEN, 0x00080808); //Setting length of DATA, ADDR, CMD
	ADDR_WRITE(SPI_CLKDIV, 0x000000FF); //Setting clock divider factor

	spi_write(0x80000000, DELAY); //_digitalWrite(_rs_pin, LOW); Line 188, Adafruit_LiquidCrystal.cpp
	spi_write(0x80000000, DELAY); //_digitalWrite(_enable_pin, LOW); Line 189, Adafruit_LiquidCrystal.cpp


	//write4bits(0x03); Line 200, Adafruit_LiquidCrystal.cpp
	spi_write(0xC0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE4000000, DELAY);
	spi_write(0xE0000000, DELAY);

	//delayMicroseconds(4500); Line 201, Adafruit_LiquidCrystal.cpp
	long_delay(100);

	//write4bits(0x03); Line 204, Adafruit_LiquidCrystal.cpp
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE4000000, DELAY);
	spi_write(0xE0000000, DELAY);

	//delayMicroseconds(4500); Line 205, Adafruit_LiquidCrystal.cpp
	long_delay(100);

	//write4bits(0x03); Line 208, Adafruit_LiquidCrystal.cpp
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE0000000, DELAY);
	spi_write(0xE4000000, DELAY);
	spi_write(0xE0000000, DELAY);

	//delayMicroseconds(150); Line 209. Delay given below (1000) is more than required, can be changed
	long_delay(1000);

	//write4bits(0x02); Line 212, Adafruit_LiquidCrystal.cpp
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA4000000, DELAY);
	spi_write(0xA0000000, DELAY);

	long_delay(100); //Needed???

	//command(LCD_FUNCTIONSET | _displayfunction); Line 230, Adafruit_LiquidCrystal.cpp
	//LCD_FUNCTIONSET | _displayfunction evalutaes to 0x28
	spi_write(0xA0000000, DELAY); //_digitalWrite(_rs_pin, mode); Line 401, Adafruit_LiquidCrystal.cpp	
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xA4000000, DELAY);
	spi_write(0xA0000000, DELAY);

	spi_write(0xA0000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x88000000, DELAY);
	spi_write(0x88000000, DELAY);
	spi_write(0x8C000000, DELAY);
	spi_write(0x88000000, DELAY);

	//display(); Line 234, Adafruit_LiquidCrystal.cpp
	spi_write(0x88000000, DELAY); //_digitalWrite(_rs_pin, mode); Line 401, Adafruit_LiquidCrystal.cpp

	spi_write(0x88000000, DELAY);
	spi_write(0x88000000, DELAY);
	spi_write(0x88000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x84000000, DELAY);
	spi_write(0x80000000, DELAY);

	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x90000000, DELAY);
	spi_write(0x98000000, DELAY);
	spi_write(0x98000000, DELAY);
	spi_write(0x9C000000, DELAY);
	spi_write(0x98000000, DELAY);

	//clear(); Line 237, Adafruit_LiquidCrystal.cpp
	spi_write(0x98000000, DELAY); //_digitalWrite(_rs_pin, mode); Line 401, Adafruit_LiquidCrystal.cpp
	spi_write(0x98000000, DELAY);
	spi_write(0x98000000, DELAY);
	spi_write(0x88000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x84000000, DELAY);
	spi_write(0x80000000, DELAY);

	spi_write(0xC0000000, DELAY);
	spi_write(0xC0000000, DELAY);
	spi_write(0xC0000000, DELAY);
	spi_write(0xC0000000, DELAY);
	spi_write(0xC0000000, DELAY);
	spi_write(0xC4000000, DELAY);
	spi_write(0xC0000000, DELAY);

	long_delay(100); //delayMicroseconds(2000); Line 250, Adafruit_LiquidCrystal.cpp

	//command(LCD_ENTRYMODESET | _displaymode); Line 242, Adafruit_LiquidCrystal.cpp
	spi_write(0xC0000000, DELAY); //_digitalWrite(_rs_pin, mode); Line 401, Adafruit_LiquidCrystal.cpp
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x80000000, DELAY);
	spi_write(0x84000000, DELAY);
	spi_write(0x80000000, DELAY);

	spi_write(0x80000000, DELAY);
	spi_write(0xA0000000, DELAY);
	spi_write(0xB0000000, DELAY);
	spi_write(0xB0000000, DELAY);
	spi_write(0xB0000000, DELAY);
	spi_write(0xB4000000, DELAY);
	spi_write(0xB0000000, DELAY);

	SPIbuff = 0x000000B0;
	displaycontrol = 0x04;
}

void digitalWrite(volatile uint8_t p, volatile uint8_t d, volatile uint8_t DELAY) {
	
	volatile uint32_t mask = 0xFF000000;

	if (d == HIGH)
		SPIbuff |= (1 &lt;&lt; p);
	else
		SPIbuff &amp;= ~(1 &lt;&lt; p);
	
	volatile uint32_t word = mask &amp;  (SPIbuff &lt;&lt; 24);
	spi_write(word, DELAY);

}


void lcd_write(volatile uint8_t character, volatile uint8_t mode, volatile uint8_t DELAY) {
	// Implementing &quot;send&quot; function

	digitalWrite((uint8_t) 1, mode, DELAY);

	digitalWrite((uint8_t) 6, (uint8_t) ((character &gt;&gt; 4) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 5, (uint8_t) ((character &gt;&gt; 5) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 4, (uint8_t) ((character &gt;&gt; 6) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 3, (uint8_t) ((character &gt;&gt; 7) &amp; 0x01), DELAY);
	
	digitalWrite((uint8_t) 2, (uint8_t) LOW, DELAY);
	digitalWrite((uint8_t) 2, (uint8_t) HIGH, DELAY);
	digitalWrite((uint8_t) 2, (uint8_t) LOW, DELAY);


	digitalWrite((uint8_t) 6, (uint8_t) ((character &gt;&gt; 0) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 5, (uint8_t) ((character &gt;&gt; 1) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 4, (uint8_t) ((character &gt;&gt; 2) &amp; 0x01), DELAY);
	digitalWrite((uint8_t) 3, (uint8_t) ((character &gt;&gt; 3) &amp; 0x01), DELAY);

	digitalWrite((uint8_t) 2, (uint8_t) LOW, DELAY);
	digitalWrite((uint8_t) 2, (uint8_t) HIGH, DELAY);
	digitalWrite((uint8_t) 2, (uint8_t) LOW, DELAY);

}

void lcd_print(volatile char *string, volatile uint8_t size, volatile uint8_t DELAY) {

	volatile int i = 0;
	//uart_putc(&#x27;S&#x27;);
	//uart_putc(&#x27;T&#x27;);
	//uart_putc(&#x27;R&#x27;);
	//uart_putc(&#x27;:&#x27;);
	//uart_putc(&#x27; &#x27;);

	while (i &lt; size) {
		lcd_write((uint8_t) string[i], (uint8_t) HIGH, DELAY);
		//uart_putc((uint8_t) string[i]);
		i++;
	}
		//uart_putc(&#x27;\n&#x27;);

}


void clear() {

	lcd_write((uint8_t) 0x01, (uint8_t) LOW, 1);
	long_delay(100);
}

void home() {


	lcd_write((uint8_t) 0x02, (uint8_t) LOW, 1);
	long_delay(100);
}

void setCursor(volatile uint8_t col, volatile uint8_t row, volatile uint8_t DELAY) {


	if (row == 0)
  		lcd_write((uint8_t) (0x80 | (col + 0x00)), (uint8_t) LOW, DELAY);
	else if (row == 1)
		lcd_write((uint8_t) (0x80 | (col + 0x40)), (uint8_t) LOW, DELAY);
	else if (row == 2)
		lcd_write((uint8_t) (0x80 | (col + 0x14)), (uint8_t) LOW, DELAY);
	else
		lcd_write((uint8_t) (0x80 | (col + 0x54)), (uint8_t) LOW, DELAY);

}

void noDisplay() {

	displaycontrol = 0x00;
	lcd_write((uint8_t) 0x08, (uint8_t) LOW, 1);

}

void display() {

	displaycontrol = 0x04;
	lcd_write((uint8_t) 0x0C, (uint8_t) LOW, 1);

}

void noCursor() {

	displaycontrol &amp;= ~(0x02);

	lcd_write((uint8_t) (0x08 | displaycontrol), (uint8_t) LOW, 1);

}

void cursor() {

	displaycontrol |= 0x02;
	lcd_write((uint8_t) (0x08 | displaycontrol), (uint8_t) LOW, 1);

}

void noBlink() {

	displaycontrol &amp;= ~(0x01);
	lcd_write((uint8_t) (0x08 | displaycontrol), (uint8_t) LOW, 1);

}

void blink() {

	displaycontrol |= 0x01;
	lcd_write((uint8_t) (0x08 | displaycontrol), (uint8_t) LOW, 1);

}

void scrollDisplayLeft() {

	lcd_write((uint8_t) 0x18, (uint8_t) LOW, 1);

}

void scrollDisplayRight() {

	lcd_write((uint8_t) 0x1C, (uint8_t) LOW, 1);

}

void setBacklight (uint8_t value) {

	digitalWrite((uint8_t) 0x07, value, 1);
}</code></pre></div>
    </details>

    <h4>Demo Program:</h4>
    <details class="code-block">
      <summary>demo.c (menu and mode control)</summary>
      <div class="code-content"><pre><code>#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &quot;spi_lcd_driver.h&quot; 
#include &quot;demo_game.c&quot;
#include &quot;demo_menu.c&quot;
#include &quot;demo_prime.c&quot;
#include &quot;demo_pi.c&quot;

volatile uint8_t lcd_delay = 3;
volatile char str0[10] = &quot;          &quot;;
volatile char strnew1[6] = &quot;React!&quot;;
volatile char strnew2[8] = &quot;Printing&quot;;
volatile char strnew3[9] = &quot;Primes...&quot;;
volatile char strnew4[16]  = &quot;Press Game Start&quot;;
volatile char strnew5[14]  = &quot;Game Starting!&quot;;
volatile char strnew6[17]  = &quot;Returning to Menu&quot;;
volatile char strnew7[11] = &quot;Calculating&quot;;
volatile char strnew8[1] = {0xF7};  
volatile char strnew9[3] = &quot;...&quot;;  
volatile char str_mode_select[21] = &quot;A=Easy B=Norm C=Hard&quot;;
int button_A() { return (gpio_pin_read() &amp; (1 &lt;&lt; 0)); }   // GPIO0 → A
int button_B() { return (gpio_pin_read() &amp; (1 &lt;&lt; 1)); }   // GPIO1 → B
int button_C() { return (gpio_pin_read() &amp; (1 &lt;&lt; 2)); }   // GPIO2 → C
int button_Select() { return (gpio_pin_read() &amp; (1 &lt;&lt; 7)); }   // GPIO7 → MENU

int main(void) {
    uart_init();
    gpio_init();
    spi_init();
    lcd_init(lcd_delay);

    setCursor(0, 0, lcd_delay);
    lcd_print(str0, 10, lcd_delay);

    print_welcome_message();
    delay(50000);
    print_menu_options();

     while (1)
    {
        // ------------------ OPTION 1: Play Game ------------------
        if (button_B()) {
            uint8_t hard_mode = DIFF_EASY;
            uint8_t drawn_mode = 2; // invalid sentinel to force initial draw

            clear();
            setCursor(0, 0, lcd_delay);
            lcd_print(strnew1, 6, lcd_delay);
            if (drawn_mode != hard_mode) {
                show_mode_line(hard_mode);
                drawn_mode = hard_mode;
            }
            setCursor(0, 2, lcd_delay);
            lcd_print(str_mode_select, 20, lcd_delay);
            setCursor(0, 3, lcd_delay);
            lcd_print(strnew4, 16, lcd_delay);
            while (!game_started()) {
                if (button_A() &amp;&amp; hard_mode != DIFF_EASY) {
                    hard_mode = DIFF_EASY;
                    if (drawn_mode != hard_mode) {
                        show_mode_line(hard_mode);
                        drawn_mode = hard_mode;
                    }
                }
                if (button_B() &amp;&amp; hard_mode != DIFF_NORMAL) {
                    hard_mode = DIFF_NORMAL;
                    if (drawn_mode != hard_mode) {
                        show_mode_line(hard_mode);
                        drawn_mode = hard_mode;
                    }
                }
                if (button_C() &amp;&amp; hard_mode != DIFF_HARD) {
                    hard_mode = DIFF_HARD;
                    if (drawn_mode != hard_mode) {
                        show_mode_line(hard_mode);
                        drawn_mode = hard_mode;
                    }
                }
                delay(1000);
            }

            clear();
            setCursor(0,0,lcd_delay);
            lcd_print(strnew5, 14, lcd_delay);
            long_delay(1000);

	  
            reaction_game(hard_mode);        // your full game logic

            clear();
            setCursor(0,0,lcd_delay);
            lcd_print(strnew6, 17, lcd_delay);
            long_delay(1000);
           
            clear();
            print_menu_options();   // return to menu
        }

        // ------------------ OPTION 2: Print Primes UART ------------------
        if (button_A()) {
               
            clear();
            setCursor(0, 0, lcd_delay);
            lcd_print(strnew2, 8, lcd_delay);
            setCursor(0, 1, lcd_delay);
            lcd_print(strnew3, 9, lcd_delay);

            print_primes_uart(1000);
            uart_putc(&#x27;\n&#x27;);

          
            print_menu_options();
        }
        if (button_C()) {
            clear();
            setCursor(0, 0, lcd_delay);
            lcd_print(strnew7, 11, lcd_delay);
            setCursor(0, 1, lcd_delay);
            lcd_print(strnew8, 1, lcd_delay);
            lcd_print(strnew9, 3, lcd_delay);
            print_pi_uart(PI_DIGITS_MAX);
            print_menu_options();
        }

        // ------------------ OPTION 3: Reprint menu ------------------
        if (button_Select()) {
            print_menu_options();
        }
    }
 
    return 0;
}

</code></pre></div>
    </details>
    <details class="code-block">
      <summary>demo_game.c (reaction game)</summary>
      <div class="code-content"><pre><code>volatile uint8_t lcd_delay_game = 3;
volatile char str1[1] = &quot;A&quot;;
volatile char str2[1] = &quot;B&quot;;
volatile char str3[1] = &quot;C&quot;;
volatile char str4[1] = &quot;X&quot;;
volatile char str5[1] = &quot;Y&quot;;
volatile char str6[1] = &quot;Z&quot;;
volatile char str7[8]  = &quot;Correct!&quot;;
volatile char str8[7]  = &quot;Wrong:(&quot; ;
volatile char str9[16]  = &quot;    Game Over :(&quot;; 
volatile char str10[16]  = &quot;Press Game Start&quot;; 
volatile char str11[13]  = &quot;Game Started!&quot;; 
volatile char str_score_line[12] = &quot;Score: 0000&quot;;
volatile char str_lives_line[9] = &quot;Lives: 3&quot;;
volatile char str_timeout[9] = &quot;Too Slow&quot;;
volatile char str_mode_easy[11] = &quot;Mode: Easy&quot;;
volatile char str_mode_normal[13] = &quot;Mode: Normal&quot;;
volatile char str_mode_hard[11] = &quot;Mode: Hard&quot;;
volatile char str_gameover_prompt[21] = &quot;Start=Retry Sel=Menu&quot;;
volatile char blank_line[21] = &quot;                    &quot;;
volatile char* letters[6] = {str1, str2, str3, str4, str5, str6};
uint8_t num_letters = 6;
#define DIFF_EASY   0
#define DIFF_NORMAL 1
#define DIFF_HARD   2
#define SIMUL_WINDOW_TICKS 6000000U
#define ROUND_TIMEOUT_STEPS 125
int game_started() {
    uint32_t val = gpio_pin_read() &amp; 0xFF;
    return (val &amp; (1 &lt;&lt; 6)) != 0; // GPIO 6 = START
}

int game_stopped() {
    uint32_t val = gpio_pin_read() &amp; 0xFF;
    return (val &amp; (1 &lt;&lt; 7)) != 0; // GPIO 7 = STOP
}

int get_pressed_button() {
    uint32_t val = gpio_pin_read() &amp; 0xFF; // Read 8-bit GPIO PADIN
    for (int i = 0; i &lt; num_letters; i++) {
        if (val &amp; (1 &lt;&lt; i)) {       // Active HIGH buttons
            return i;
        }
    }
    return -1;
}

// Write an integer into a pre-sized buffer without heap/float usage.
static void write_number_to_buffer(uint32_t value, volatile char *buffer, uint8_t offset, uint8_t digits) {
    for (uint8_t i = 0; i &lt; digits; i++) {
        buffer[offset + digits - 1 - i] = (char)(&#x27;0&#x27; + (value % 10));
        value /= 10;
    }
}

static uint8_t read_letter_mask() {
    return (uint8_t)(gpio_pin_read() &amp; ((1U &lt;&lt; num_letters) - 1U));
}

static void clear_row(uint8_t row) {
    setCursor(0, row, lcd_delay_game);
    lcd_print(blank_line, 20, lcd_delay_game);
    setCursor(0, row, lcd_delay_game);
}

static void update_score_line(uint32_t score) {
    if (score &gt; 9999U) {
        score = 9999U; // clamp to displayed width
    }
    write_number_to_buffer(score, str_score_line, 7, 4);
    setCursor(0, 2, lcd_delay_game);
    lcd_print(str_score_line, 11, lcd_delay_game);
}

static void update_lives_line(uint32_t lives) {
    if (lives &gt; 9U) {
        lives = 9U;
    }
    str_lives_line[7] = (char)(&#x27;0&#x27; + lives);
    setCursor(0, 3, lcd_delay_game);
    lcd_print(str_lives_line, 8, lcd_delay_game);
}

static void show_mode_line(uint8_t hard_mode) {
    clear_row(1);
    setCursor(0, 1, lcd_delay_game);
    if (hard_mode == DIFF_EASY) lcd_print(str_mode_easy, 10, lcd_delay_game);
    else if (hard_mode == DIFF_NORMAL) lcd_print(str_mode_normal, 12, lcd_delay_game);
    else lcd_print(str_mode_hard, 10, lcd_delay_game);
}

static int pick_second_letter(int first_letter, uint32_t random_val) {
    int offset = (int)(random_val % (num_letters - 1)) + 1; // 1..num_letters-1
    return (first_letter + offset) % num_letters;
}

static uint8_t build_hard_mask(uint32_t seed0, uint32_t seed1, int *letters_out) {
    uint8_t count = (uint8_t)((seed1 % num_letters) + 1); // 1..6
    uint32_t mix = seed0 ^ (seed1 &lt;&lt; 1);
    uint8_t mask = 0;
    for (uint8_t i = 0; i &lt; count; i++) {
        int candidate = (int)((mix &gt;&gt; (i * 3)) % num_letters);
        uint8_t tries = 0;
        while ((mask &amp; (1U &lt;&lt; candidate)) &amp;&amp; tries &lt; num_letters) {
            candidate = (candidate + 1) % num_letters;
            tries++;
        }
        letters_out[i] = candidate;
        mask |= (uint8_t)(1U &lt;&lt; candidate);
    }
    return mask;
}

static void build_display_string(const int *letters_list, uint8_t count, char *buf, uint8_t *out_len) {
    uint8_t idx = 0;
    for (uint8_t i = 0; i &lt; count; i++) {
        buf[idx++] = letters[letters_list[i]][0];
        if (i + 1 &lt; count) {
            buf[idx++] = &#x27;+&#x27;;
        }
    }
    *out_len = idx;
}

static void show_round_header(const int *letters_list, uint8_t count, uint32_t score, uint32_t lives) {
    clear_row(0);
    setCursor(0, 0, lcd_delay_game);
    char display_buf[12];
    uint8_t disp_len = 0;
    build_display_string(letters_list, count, display_buf, &amp;disp_len);
    lcd_print(display_buf, disp_len, lcd_delay_game);
    update_score_line(score);
    update_lives_line(lives);
}

static uint8_t wait_for_retry_or_menu() {
    while (game_started() || game_stopped()) {
        delay(500);
    }
    while (1) {
        if (game_started()) return 1;
        if (game_stopped()) return 0;
        delay(500);
    }
}

static uint8_t show_game_over_screen(uint32_t final_score) {
    if (final_score &gt; 9999U) {
        final_score = 9999U;
    }
    write_number_to_buffer(final_score, str_score_line, 7, 4);
    clear();
    setCursor(0, 0, lcd_delay_game);
    lcd_print(str9, 16, lcd_delay_game);
    lcd_print(str9, 4, lcd_delay_game);
    setCursor(0, 2, lcd_delay_game);
    lcd_print(str_score_line, 11, lcd_delay_game);
    setCursor(0, 3, lcd_delay_game);
    lcd_print(str_gameover_prompt, 20, lcd_delay_game);
    return wait_for_retry_or_menu();
}

void reaction_game(uint8_t difficulty) {
restart_game:
    timer_reset_and_start(0);
    timer_reset_and_start(1);
    uint32_t score = 0;
    uint32_t lives = 3;
    clear();
    show_mode_line(difficulty);
    update_score_line(score);
    update_lives_line(lives);
    int target_letters[6];
    while (1) {
        uint32_t t = timer_read(0);
        uint32_t t_alt = timer_read(1);

        uint8_t expected_mask = 0;
        uint8_t target_count = 1;
        target_letters[0] = (int)(t % num_letters);
        if (difficulty == DIFF_NORMAL) {
            target_count = 2;
            target_letters[1] = pick_second_letter(target_letters[0], t_alt);
            expected_mask = (uint8_t)((1U &lt;&lt; target_letters[0]) | (1U &lt;&lt; target_letters[1]));
        } else if (difficulty == DIFF_HARD) {
            expected_mask = build_hard_mask(t, t_alt, target_letters);
            target_count = 0;
            for (uint8_t i = 0; i &lt; num_letters; i++) {
                if (expected_mask &amp; (1U &lt;&lt; i)) {
                    target_letters[target_count++] = i;
                }
            }
        } else {
            expected_mask = (uint8_t)(1U &lt;&lt; target_letters[0]);
            target_count = 1;
        }

        show_round_header(target_letters, target_count, score, lives);
        uint8_t pressed_mask = 0;
        uint8_t input_correct = 0;
        uint8_t saw_press = 0;
        uint32_t window_start = 0;
        uint32_t wait_budget = ROUND_TIMEOUT_STEPS;
        uint8_t timed_out = 0;
        while (1) {
            if (game_stopped()) {
                if (show_game_over_screen(score)) {
                    goto restart_game;
                }
                return;    // Exit to menu
            }

            pressed_mask = read_letter_mask();
            if (!saw_press) {
                if (pressed_mask == 0) {
                    if (wait_budget == 0) {
                        timed_out = 1;
                        break;
                    }
                    wait_budget--;
                    delay(500);
                    continue;
                }
                if ((pressed_mask &amp; ~expected_mask) != 0) {
                    break; // Extra buttons pressed (cheating)
                }
                saw_press = 1;
                window_start = timer_read(0);
            } else {
                if ((uint32_t)(timer_read(0) - window_start) &gt; SIMUL_WINDOW_TICKS) {
                    break; // took too long to complete combo
                }
                if ((pressed_mask &amp; ~expected_mask) != 0) {
                    break; // Extra buttons pressed (cheating)
                }
            }
            if (pressed_mask == expected_mask) {
                input_correct = 1;
                break;
            }
        }

        if (input_correct) {
            score++;
            update_score_line(score);
            clear_row(0);
            setCursor(0, 0, lcd_delay_game);
            lcd_print(str7, 8, lcd_delay_game);
            long_delay(1000);     
        } 
        else {
            if (lives &gt; 0) {
                lives--;
            }
            update_lives_line(lives);
            clear_row(0);
            setCursor(0, 0, lcd_delay_game);
            if (timed_out) {
                lcd_print(str_timeout, 8, lcd_delay_game);
            } else {
                lcd_print(str8, 7, lcd_delay_game);
            }
            long_delay(1000); 
        }

        long_delay(1000); // Adjust delay as needed
        if (lives == 0) {
            if (show_game_over_screen(score)) {
                goto restart_game;
            }
            return;
        }
    }
}
    

</code></pre></div>
    </details>
    <details class="code-block">
      <summary>demo_menu.c (LCD menu)</summary>
      <div class="code-content"><pre><code>volatile uint8_t lcd_delay_menu = 3;
volatile char str1a[9] = &quot;Hello App&quot;;
volatile char str1b[3] = &quot;le!&quot;;
volatile char str2a[12] = &quot;This is Nano&quot;;
volatile char str2b[6] = &quot;Logic!&quot;;
volatile char str3a[6] = &quot;Choose&quot;;
volatile char str3b[5] = &quot; from&quot;;
volatile char str3c[7] = &quot; below:&quot;;

volatile char str4a[7] = &quot;A:Print&quot;;
volatile char str4b[6] = &quot; Prime&quot;;
volatile char str4c[7] = &quot; (UART)&quot;;

volatile char str5a[6] = &quot;B:Play&quot;;
volatile char str5b[5] = &quot; Game&quot;;

volatile char str6a[8] = &quot;C:Print &quot;;
volatile char str6b[1] = {0xF7};
volatile char str6c[7] = &quot; (UART)&quot;;
void print_welcome_message() {

  clear();
  setCursor(0, 0, lcd_delay_menu);
  lcd_print(str1a, 9, lcd_delay_menu);
  lcd_print(str1b, 3, lcd_delay_menu);

  setCursor(0, 1, lcd_delay_menu);
  lcd_print(str2a, 12, lcd_delay_menu);
  lcd_print(str2b, 6, lcd_delay_menu);
  long_delay(1000);

}

void print_menu_options () {

  clear();
	
  lcd_print(str3a, 6, lcd_delay_menu);
  lcd_print(str3b, 5, lcd_delay_menu);
  lcd_print(str3c, 7, lcd_delay_menu);


  setCursor(0, 1, lcd_delay_menu);
  lcd_print(str4a, 7, lcd_delay_menu);
  lcd_print(str4b, 6, lcd_delay_menu);
  lcd_print(str4c, 7, lcd_delay_menu);

  setCursor(0, 2, lcd_delay_menu);
  lcd_print(str5a, 6, lcd_delay_menu);
  lcd_print(str5b, 5, lcd_delay_menu);

  setCursor(0, 3, lcd_delay_menu);
  lcd_print(str6a, 8, lcd_delay_menu);
  lcd_print(str6b, 1, lcd_delay_menu);
  lcd_print(str6c, 7, lcd_delay_menu);
  long_delay(1000);
}

</code></pre></div>
    </details>
    <details class="code-block">
      <summary>demo_prime.c (UART prime generator)</summary>
      <div class="code-content"><pre><code>// -------------------------------------------------
// Prime check
// -------------------------------------------------
int is_prime(unsigned int n) {
    if (n &lt; 2) return 0;
    if (n == 2) return 1;
    if (n % 2 == 0) return 0;

    for (unsigned int i = 3; i * i &lt;= n; i += 2) {
        if (n % i == 0) return 0;
    }
    return 1;
}

// -------------------------------------------------
// Print integer as characters over UART using uart_putc()
// -------------------------------------------------
void uart_print_number(unsigned int n) {
    char digits[10];
    int i = 0;

    // Extract digits (reverse)
    while (n &gt; 0) {
        digits[i++] = (n % 10) + &#x27;0&#x27;;
        n /= 10;
    }

    // Print in correct order
    while (--i &gt;= 0) {
        uart_putc(digits[i]);
        delay(30);
    }
}

// -------------------------------------------------
// Print all primes ≤ max_n using UART
// -------------------------------------------------
void print_primes_uart(unsigned int max_n) {
    for (unsigned int n = 2; n &lt;= max_n; n++) {
        if (is_prime(n)) {

            uart_print_number(n);    // Send digits
            uart_putc(&#x27; &#x27;);          // Space after each prime
            delay(300);
        }
    }
}
</code></pre></div>
    </details>
    <details class="code-block">
      <summary>demo_pi.c (UART pi digits)</summary>
      <div class="code-content"><pre><code>// Spigot-based digit generator for pi (integer-only, no FP needed).
// The CPU is 32-bit, so keep buffers small; this prints up to PI_DIGITS_MAX digits.

#define PI_DIGITS_MAX 500
#define PI_SPIGOT_LEN ((PI_DIGITS_MAX * 10 / 3) + 1)

static int pi_state[PI_SPIGOT_LEN];

// Emit a single digit over UART and drop a decimal point after the first digit.
static void uart_emit_digit(int digit, int *digits_written) {
    uart_putc((char)(&#x27;0&#x27; + digit));
    delay(10);

    (*digits_written)++;
    if (*digits_written == 1) {     // after leading &#x27;3&#x27;
        uart_putc(&#x27;.&#x27;);
        delay(50);
    }
}

// Generate and print `digits` digits of pi (including the leading &#x27;3&#x27;).
static void print_pi_uart(int digits) {
    if (digits &lt; 1) return;

    // Initialize spigot state
    for (int i = 0; i &lt; PI_SPIGOT_LEN; i++) {
        pi_state[i] = 2;
    }

    int nines = 0;
    int predigit = 0;
    int digits_written = 0;

    for (int j = 0; j &lt; digits; j++) {
        int carry = 0;

        // Core spigot step: update the remainder array.
        for (int i = PI_SPIGOT_LEN; i &gt; 0; i--) {
            int idx = i - 1;
            int x = pi_state[idx] * 10 + carry * i;
            pi_state[idx] = x % (2 * i - 1);
            carry = x / (2 * i - 1);
        }

        int current_digit = carry / 10;
        pi_state[0] = carry % 10;

        // The first digit is just staged; others are emitted with carry handling.
        if (j == 0) {
            predigit = current_digit;
            continue;
        }

        if (current_digit == 9) {
            nines++;
        } else if (current_digit == 10) {
            uart_emit_digit(predigit + 1, &amp;digits_written);
            for (int k = 0; k &lt; nines; k++) {
                uart_emit_digit(0, &amp;digits_written);
            }
            predigit = 0;
            nines = 0;
        } else {
            uart_emit_digit(predigit, &amp;digits_written);
            for (int k = 0; k &lt; nines; k++) {
                uart_emit_digit(9, &amp;digits_written);
            }
            predigit = current_digit;
            nines = 0;
        }
    }

    uart_emit_digit(predigit, &amp;digits_written);
    for (int k = 0; k &lt; nines; k++) {
        uart_emit_digit(9, &amp;digits_written);
    }

    uart_putc(&#x27;\n&#x27;);
    delay(10000);
}

</code></pre></div>
    </details>

    <h3>Testing Methodology</h3>
    <h4>Post-Silicon Validation</h4>
    <p>To conduct post-silicon validation on our chip, we started with a structured bring-up sequence to validate that the silicon was healthy. The very first step was to construct a testing setup on a breadboard that would allow us to test the various features of our chip. To make the setup easier, we used a QFP64 socket, which allowed us to connect our chip to the breadboard without soldering. Since the chip has 64 pins, and a single breadboard has 63 rows, each row of the breadboard was connected to pins 1 through 63 on the chip. Pin 64, which is GPIO 7, was left disconnected since there was no room, and it wasn't crucial for initial testing anyway. From there, the breadboard was set up in such a way as to mimic our testbench used in simulation. Specifically, we were most concerned with replicating the scan-chain process.</p>
    <p>To do this, we first documented the expected values and behavior of each pin based on the simulation testbench. This included identifying which pins needed to be set to what voltage, which served as scan-chain controls, which were dedicated I/O pins, and which supplied power or clocking. Having this reference made it possible to map physical pin behavior to the functional waveforms we expected to observe on the oscilloscope.</p>
    <p>Our initial plan was to use a 3.3 V Arduino Pro Mini as the external controller for scan-chain operations and general chip bring-up. However, we quickly discovered that the Pro Mini's microcontroller was not compatible with the routines in our scan-chain driver code. As a result, we switched to a 5 V Arduino Uno, using a voltage divider network to ensure that any 5 V outputs feeding into our chip were stepped down to safe levels. This let us continue development while maintaining signal integrity and protecting the silicon.</p>
    <p>Once the control hardware was selected, we programmed the Arduino with a scan-chain interface based on code from a previous project in the course. This gave us an immediate framework for clocking in scan data, latching instructions, and reading chain outputs. With this basic infrastructure ready, we attached an oscilloscope to measure the internal clock generator. Our goal was to verify that the on-chip oscillator was functional and running at the intended frequency. After several measurement attempts, including adjusting trigger levels and confirming that our power rails were stable, we were able to confirm oscillation.</p>
    <p>With the core clock verified, we moved on to testing individual subsystems. UART was the first to come online. After configuring baud rate parameters and validating the UART TX waveforms on the oscilloscope, we successfully received UART messages from the chip. This allowed us to use UART as a lightweight diagnostic channel for subsequent tests.</p>
    <p>Next, we tested GPIO inputs. By manually toggling input pins and reading the chip's internal state over UART, we confirmed that the GPIO block was latching external values correctly. This validated both the input pads and the internal routing to the processor core. </p>
    <p>For SPI testing, we created a test program to control the SPI pins and verified via oscilloscope that the chip generated the correct clock and data responses. Although initially noisy, after adjusting grounding on the breadboard and shortening several long wires, the SPI signals became reliable.</p>
    <p>One of the more complex peripherals to bring up was the LCD SPI backpack interface. With SPI known working, and using the previous project's LCD SPI backpack driver as a foundation, we adapted the initialization and command routines to work with our chip's instruction format and GPIO mapping. This took several rounds of debugging, but ultimately the LCD displayed correct characters, confirming functional integration between GPIO, instruction memory, and the CPU datapath.</p>
    <p>As we became more confident in the system's stability, we returned to improving our scan-chain infrastructure. The initial version loaded all scan data into a unified chain, but for full testing flexibility, we modified the code to load instruction memory and data memory independently. This allowed us to preload programs while separately initializing memory contents used for testing. It also fixed the remaining bug we had with the LCD, where it would often display garbage data, since the string data was not being properly loaded into data memory.</p>
    <p>With the breadboard prototype functioning well, we began transitioning toward a standalone PCB. First, we replaced the variable-voltage bench supply with a dedicated 5 V-to-1 V regulator circuit, ensuring a stable and repeatable power configuration. Then, using lessons learned from the breadboard setup, we created the first revision of the PCB. This initial design focused on routing clarity and ensuring all chip pins were accessible for test points. Once fabricated, we tested this board thoroughly, checking power distribution, confirming all traces, and verifying that the chip behaved identically to the breadboard setup.</p>
    <p>Based on these results, we developed the final revision of the PCB, incorporating layout improvements, fixes to various oversights and mistakes from the first PCB, cleaner routing, and quality-of-life enhancements such as labeled headers and in built GPIO buttons. Testing this final revision confirmed that the board performed reliably and eliminated many of the wiring issues inherent to the breadboard prototype.</p>
    <p>Finally, with the hardware stable, we created and validated the demo code used to showcase the chip's functionality. The demo serves both as a validation suite and as a demonstration of the chip's operational capabilities.</p>
  </section>

  

  <section id="pcb">
    <h2>PCB Design</h2>
   <p>Before designing the PCB, we first validated the basic functionality of our system on a breadboard. This allowed us to quickly prototype the core components, verify signal correctness, and ensure that the chip interfaces behaved as expected. However, breadboard wiring is inherently limited in terms of signal integrity, power stability, reliability, and repeatability.</p>
   <p>The purpose of creating a dedicated PCB is to provide a stable, well-structured, and electrically robust platform for testing our chip. The PCB ensures controlled routing, proper grounding, low-noise power distribution, and mechanically secure connections—all of which are essential for accurate measurement and characterization. It also integrates voltage regulators, test points, connectors, and peripheral interfaces in a clean and reproducible layout, enabling more complex experiments that would not be practical on a breadboard.
</p>
   <p>Overall, the PCB transforms the project from an early prototype into a reliable test and evaluation system, supporting systematic bring-up, debugging, and performance testing of the chip.</p>
  <img src="../images/nanologic/board.HEIC" alt="layout diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br>
    <p class="caption">Figure ?. PCB </p>

    <h3>Board Architecture</h3>
    <p>The PCB is organized around the custom test chip placed at the center of the board, with all critical signals and supplies fanning out symmetrically. On the left side, an Arduino-UNO-compatible header provides a convenient digital interface for configuration, scan control, and simple firmware development. Around the chip, dedicated connectors expose scan, load, clock, and GPIO pins for lab instrumentation and external measurement.</p>
    <p>The lower portion of the board is reserved for the power-management section, where the LDO regulators and associated jumpers, test points, and decoupling networks are grouped together. Along the bottom edge, an array of Cherry MX push buttons is connected to the chip GPIOs through pull-down resistors, forming a simple and robust user input interface. Mechanical features such as mounting holes and the reserved LCD area are aligned with the board outline so that the complete system can be mounted in a chassis or demo fixture. This layout keeps high-current power paths short, separates digital I/O from sensitive supply routing, and makes probing and debugging straightforward during bring-up.</p>
    <img src="../images/nanologic/pcb1.png" alt="layout diagram"><br>
        <p class="caption">Figure ?. PCB </p>
    <img src="../images/nanologic/pcb2.png" alt="layout diagram" style="display:block; margin:0 auto; width:60%; height:auto;"><br>
        <p class="caption">Figure ?. PCB </p>

    <h3>Power Distribution</h3>
    <p>The board is powered from a 5 V input, which is locally regulated down to several on-board supply rails. Three TPS7A7100 LDO regulators generate the main voltages used by the chip: VDD_CORE, VDD_CLEAN, and VDD_TEST. Each regulator has its own input filter, adjustable feedback network, and output decoupling, allowing the core, clean, and test domains to be powered independently and tuned to the required voltage levels.</p>
    <p>For measurement and bring-up, every rail is routed through “pre” and “post” jumpers and dedicated test points. This allows an ammeter or shunt resistor to be inserted in series with the supply to monitor per-domain current consumption without modifying the PCB. Banks of bulk (10 µF) and high-frequency (100 nF) capacitors are placed close to the test chip pins on each rail to reduce supply noise and stabilize the regulators. The 3.3 V logic domain used by the GPIO switches and external connectors is kept separate from the core supplies, ensuring that digital I/O activity does not disturb the more sensitive core and clean power domains. Together, this power-distribution scheme provides flexible, low-noise, and well-observable supplies for detailed silicon characterization.
</p>
    <img src="../images/nanologic/pcb3.png" alt="layout diagram">
            <p class="caption">Figure ?. PCB </p>

  </section>
  
  <section id="demo">
    <h2>Demonstration</h2>
    <p class="instruction-text">[Replace with demonstration description: Show working examples, test results, and real-world performance of your chip.]</p>
    
    <img src="../images/nanologic/demo/default.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Starting Our Demo </p>

    <img src="../images/nanologic/demo/prime.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Print Prime Numbers on LCD Screen</p>

    <img src="../images/nanologic/demo/primes_term.png" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Print Prime Numbers shown on PC</p>

    <img src="../images/nanologic/demo/pai.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Print Pai </p>

    <img src="../images/nanologic/demo/pi_term.png" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Print Pai shown on PC</p>

    <img src="../images/nanologic/demo/game_menu.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Print Game Menu </p>

    <img src="../images/nanologic/demo/easy.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Easy Mode </p>
   
    <img src="../images/nanologic/demo/gameover.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Over </p>

    <img src="../images/nanologic/demo/normal.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Normal Mode  </p>

    <img src="../images/nanologic/demo/normal2.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Normal Mode Ongoing </p>
    
    <img src="../images/nanologic/demo/normal_wrong.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Normal Mode Wrong </p>

    <img src="../images/nanologic/demo/normal_over.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Normal Mode Over </p>

    <img src="../images/nanologic/demo/hard.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Hard Mode </p>

    <img src="../images/nanologic/demo/hard2.jpg" alt="layout diagram" style="display:block; margin:0 auto; width:50%; height:auto;"><br>
    <p class="caption">Figure ?. Game Hard Mode Ongoing </p>

    <h3>Video Demonstration</h3>
    <div class="video-container">
      <iframe src="https://www.youtube.com/embed/LW61fFNlFcQ" title="Project demonstration video" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
  </section>
  
  <section id="specs">
    <h2>Chip Specifications</h2>
    <p class="instruction-text">[Replace with chip specifications: Provide detailed technical specifications and measured performance metrics.]</p>
    
    <table class="specs-table">
      <tr>
        <th>Parameter</th>
        <th>Specification</th>
      </tr>
      <tr>
        <td>Technology</td>
        <td>TSMC 65nm LP</td>
      </tr>
      <tr>
        <td>Die Size</td>
        <td>2.0mm × 1.0mm</td>
      </tr>
      <tr>
        <td>Maximum Frequency</td>
        <td>200 MHz</td>
      </tr>
      <tr>
        <td>Operating Frequency</td>
        <td>84.414 MHz</td>
      </tr>
      <tr>
        <td>Supply Voltage</td>
        <td>1.0 V core rails (VDD_CORE / VDD_CLEAN / VDD_TEST), 3.3 V I/O, 5 V board input</td>
      </tr>
      <tr>
        <td>Power Consumption</td>
        <td>[e.g., 85 mW typical]</td>
      </tr>
      <tr>
        <td>Performance Metric</td>
        <td>[e.g., throughput, latency]</td>
      </tr>
      <tr>
        <td>Package</td>
        <td>LQFP64L</td>
      </tr>
      <tr>
        <td>Gate Count</td>
        <td>~800,000 gates</td>
      </tr>
    </table>

     <br><br>
     <p>The table below defines the memory map of all major components connected to the SoC bus. Each peripheral is assigned a dedicated, non-overlapping address region to ensure simple decoding and deterministic access behavior. The on-chip data memory (DMEM) occupies the lower address space, enabling fast load/store operations from the CPU core. All memory-mapped peripherals—including GPIO, UART, SPI, I²C, and timer modules—are placed at aligned 4 KiB address boundaries on the bus. This organization allows the AHB/APB interconnect to efficiently route transactions based on the high-order address bits, while providing a clean, extensible structure for integrating additional peripherals in future revisions of the SoC. The CPU can interact with each module through standard load/store instructions, making software development straightforward and enabling uniform access across the entire system.</p>

 <table class="specs-table">
  <tr>
    <th>Device</th>
    <th>Start</th>
    <th>End</th>
    <th>Size</th>
  </tr>

  <tr>
    <td>DMEM</td>
    <td>0x00000000</td>
    <td>0x00007FFF</td>
    <td>16KiB</td>
  </tr>

  <tr>
    <td>GPIO</td>
    <td>0x10000000</td>
    <td>0x10000FFF</td>
    <td>4KiB</td>
  </tr>

  <tr>
    <td>UART</td>
    <td>0x20000000</td>
    <td>0x20000FFF</td>
    <td>4KiB</td>
  </tr>

  <tr>
    <td>SPI</td>
    <td>0x30000000</td>
    <td>0x30000FFF</td>
    <td>4KiB</td>
  </tr>

  <tr>
    <td>I2C</td>
    <td>0x40000000</td>
    <td>0x40000FFF</td>
    <td>4KiB</td>
  </tr>

  <tr>
    <td>Timers</td>
    <td>0x50000000</td>
    <td>0x50000FFF</td>
    <td>4KiB</td>
  </tr>

</table>

<br><br>
<p>In addition to the bus-mapped peripheral address space, the SoC includes a separate memory map for the instruction memory (IMEM). Unlike DMEM and the peripheral modules, IMEM is not connected to the AHB/APB system bus. A separate IMEM table is therefore provided to document its address boundaries and organization.</p>
 <table class="specs-table">
  <tr>
    <th>Device</th>
    <th>Start</th>
    <th>End</th>
    <th>Size</th>
  </tr>

  <tr>
    <td>IMEM</td>
    <td>0x00000000</td>
    <td>0x00007FFF</td>
    <td>16KiB</td>
  </tr>
  </table>

    <br><br>
    <p>The table below summarizes the output frequencies generated by the on-chip clock generator for different combinations of clkgen_div and clkgen_fc control signals. These configuration bits are loaded through the scan chain, allowing the clock generator to be fully programmable without requiring dedicated external pins. By shifting the desired divider (clkgen_div) and frequency-control (clkgen_fc) values into the scan chain and applying them during run mode, the SoC can dynamically select a wide range of operating frequencies. This programmability enables flexible performance scaling, thorough post-silicon characterization, and simplified validation of timing margins across various clock settings.</p>
    <table class="specs-table">
  <tr>
    <th>clkgen_div</th>
    <th>clkgen_fc</th>
    <th>Frequency (Hz)</th>
  </tr>
  <tr>
    <td>1111</td>
    <td>11111</td>
    <td>9.3424K</td>
  </tr>
  <tr>
    <td>1111</td>
    <td>01010</td>
    <td>20.682K</td>
  </tr>
  <tr>
    <td>1111</td>
    <td>00101</td>
    <td>29.361K</td>
  </tr>
  <tr><td>1110</td><td>01010</td><td>41.358K</td></tr>
  <tr><td>1110</td><td>00101</td><td>58.685K</td></tr>

  <tr><td>1101</td><td>01010</td><td>82.672K</td></tr>
  <tr><td>1101</td><td>00101</td><td>117.35K</td></tr>

  <tr><td>1100</td><td>01010</td><td>165.43K</td></tr>
  <tr><td>1100</td><td>00101</td><td>234.80K</td></tr>

  <tr><td>1011</td><td>01010</td><td>330.69K</td></tr>
  <tr><td>1011</td><td>00101</td><td>468.87K</td></tr>

  <tr><td>1010</td><td>01010</td><td>661.38K</td></tr>
  <tr><td>1010</td><td>00101</td><td>938.44K</td></tr>

  <tr><td>1001</td><td>01010</td><td>1.321M</td></tr>
  <tr><td>1001</td><td>00101</td><td>1.877M</td></tr>

  <tr><td>1000</td><td>01010</td><td>2.637M</td></tr>
  <tr><td>1000</td><td>00101</td><td>3.765M</td></tr>

  <tr><td>0111</td><td>01010</td><td>5.252M</td></tr>
  <tr><td>0111</td><td>00101</td><td>7.530M</td></tr>

  <tr><td>0110</td><td>01010</td><td>10.593M</td></tr>
  <tr><td>0110</td><td>00101</td><td>15.010M</td></tr>

  <tr><td>0101</td><td>01010</td><td>21.552M</td></tr>
  <tr><td>0101</td><td>00101</td><td>30.02M</td></tr>

  <tr><td>0100</td><td>01010</td><td>42.264M</td></tr>
  <tr><td>0100</td><td>00101</td><td>59.98M</td></tr>

  <tr><td>0011</td><td>01010</td><td>84.414M</td></tr>
  <tr><td>0011</td><td>00101</td><td>119.66M</td></tr>

  <tr><td>0010</td><td>01010</td><td>168.83M</td></tr>
  <tr><td>0010</td><td>00101</td><td>239.46M</td></tr>

  <tr><td>0001</td><td>01010</td><td>336.75M</td></tr>
  <tr><td>0001</td><td>00101</td><td>476.74M</td></tr>

  <tr><td>0000</td><td>01010</td><td>669.16M</td></tr>
  <tr><td>0000</td><td>00101</td><td>946.97M</td></tr>

  <tr><td>0000</td><td>00000</td><td>1.524G</td></tr>
</table>

  </section>
  
  <section id="conclusions">
    <h2>Conclusions</h2>
    <p class="instruction-text">[Replace with conclusions: Summarize achievements, lessons learned, challenges overcome, and potential future improvements.]</p>
   
    <h3>Key Achievements</h3>
    <p class="instruction-text">[List major accomplishments and successful design outcomes.]</p>
     <p>Our team successfully designed and verified a fully functional RISC-V based System-on-Chip (SoC) integrating a custom CPU core, AHB/APB bus interconnect, instruction and data memories, and a rich set of peripheral modules including UART, SPI, I²C, GPIO, LCD, timers, finite-state machines, and a full scan chain architecture. We implemented a complete end-to-end ASIC design flow, from architectural design, RTL implementation, and verification to synthesis, physical design, and tape-out, resolving all timing violations and achieving clean DRC/LVS signoff. To support software development, we built a customized RISC-V toolchain, linker script, and utilities tailored for a Harvard memory architecture. A comprehensive test suite, covering arithmetic kernels, peripheral interactions, metastability tests, and multiple demonstration programs, was developed and validated across both RTL and post-synthesis gate-level simulations. We also integrated deterministic scan-chain–based loading and run-mode execution for robust software-driven testing. Full post-route timing analysis and signoff were completed using Innovus, Virtuoso, and PrimeTime, culminating in the generation of the final GDSII and all required collateral for fabrication. After silicon returned, we performed post-silicon validation, designed a custom PCB for bring-up, and developed multiple demo applications to showcase the chip’s full functionality running on real hardware.
    </p>
    <h3>Lessons Learned</h3>
    <p class="instruction-text">[Discuss important insights gained during the design process.]</p>
    <p>Throughout the design and implementation of the SoC, we gained several important insights that shaped our engineering workflow. Managing a hierarchical SoC design requires careful planning of module interfaces, timing constraints, and verification strategies to ensure smooth integration and to prevent late-stage system-level issues. We found that addressing toolchain setup, linker configuration, and memory mapping early in the project greatly simplified software debugging and hardware bring-up. From a physical design standpoint, we learned that hold-time violations frequently emerge after synthesis and must be handled systematically during place-and-route through delay insertion and routing optimization. Additionally, macro placement, power grid design, and clock tree architecture proved to have substantial impact on timing closure, congestion, and overall chip robustness. Building a comprehensive testing framework—including both RTL and gate-level simulations—was essential to uncovering subtle timing and functional issues long before tape-out.</p>
    <p>After tape-out, we further learned the importance of planning for post-silicon validation, including designing accessible scan-chain hooks, preparing diagnostic firmware, and building modular test infrastructure. The bring-up process highlighted the value of well-organized PCB design, clear pin documentation, and flexible debugging utilities to quickly isolate hardware or software faults. Finally, developing real demo applications on the fabricated chip reinforced the need for strong coordination between hardware, firmware, and system validation, demonstrating that successful silicon requires not only correct design, but also thoughtful preparation for real-world testing and integration.</p>
    <h3>Future Work</h3>
    <p class="instruction-text">[Describe potential enhancements and next-generation features.]</p>
    <p>Looking ahead, several enhancements could significantly elevate the capability and performance of the next-generation SoC. CPU performance can be further improved through enabling the FPU or switching to a more performant CPU design. On the system level, integrating advanced peripherals such as DMA controllers, interrupt subsystems, or dedicated hardware accelerators for graphics or AI workloads would greatly expand the chip’s versatility. Power efficiency could be improved by introducing power-domain partitioning, fine-grained clock gating, and other low-power design techniques. From a tooling perspective, extending the software toolchain to support richer debugging features such as on-chip breakpoints, real-time trace modules, or a full JTAG interface would streamline firmware development and hardware bring-up. For physical design scalability, migrating to a more advanced technology node or increasing metal-layer count would enable higher operating frequencies and denser integration. Ultimately, these improvements could contribute to a second-generation SoC featuring larger on-chip memory, higher-speed interfaces, and greater interconnect bandwidth to support more complex real-world applications.</p>
  </section>
  
  <section id="references">
    <h2>References</h2>
    <p class="instruction-text">[Replace with references: List academic papers, technical manuals, and other resources cited in your project.]</p>
    <ol style="margin-left: 25px; color: var(--text-gray);">
      <li style="margin-bottom: 12px;"> CV32E40P Documentation: OpenHW Group, Introduction, https://docs.openhwgroup.org/projects/cv32e40p-user-manual/en/latest/intro.html</li>
      <li style="margin-bottom: 12px;"> APB Protocol Documentation: ARM Ltd, AMBA® APB Protocol Specification, https://documentation-service.arm.com/static/63fe2c1356ea36189d4e79f3%3Ftoken%3D&ved=2ahUKEwiL-or6lKeRAxVPFVkFHbZNCjIQFnoECCMQAQ&usg=AOvVaw2XkJhpaIeA4ry31JCjoQdq</li>
      <li style="margin-bottom: 12px;"> AHB Protocol Documentation: ARM Ltd, AMBA® AHB Protocol Specification, https://documentation-service.arm.com/static/6141bf0d674a052ae36ca811%3Ftoken%3D&ved=2ahUKEwjIooLn9K6RAxVF1fACHW1kCQkQFnoECAwQAQ&usg=AOvVaw0qphHfwpTSe1SQ0d2QgAIm</li>   
      <li style="margin-bottom: 12px;"> 2024 iRisc Code: iRisc, iRisc - Fully Custom Risc-V SOC, https://gitfront.io/r/lafis002/nsQYcfC2svzE/iRisc/</li>
      <li style="margin-bottom: 12px;"> RISC-V GNU Toolchain Github Repository: riscv-collab, riscv-gnu-toolchain, https://github.com/riscv-collab/riscv-gnu-toolchain</li>
      <li style="margin-bottom: 12px;">[Reference _: Author, Title, Publication, Year]</li>
    </ol>
  </section>
  
  <section id="acknowledgments">
    <h2>Acknowledgments</h2>
    <p class="instruction-text">[Replace with acknowledgments: Thank advisors, sponsors, lab staff, and others who contributed to the project.]</p>
    <p>We would like to express our deepest gratitude to Professor Mingoo Seok, whose weekly meetings, technical guidance, and continuous encouragement were fundamental to the success of this tape-out project. His insights into this area helped shape our SoC from concept to working silicon, and his support throughout each milestone kept our team moving forward.</p>
    <p>We would also like to thank our teaching assistants for their invaluable contributions. Da Won Kim’s lessons provided essential foundational knowledge that directly strengthened our design flow work. Mosom Jana’s office hours were instrumental in helping us resolve numerous technical challenges, from RTL implementation to back-end design issues. We are grateful to Chuan-Tung Lin for his extensive support during silicon validation, PCB development and final Demo; his guidance played a critical role in enabling our successful bring-up and demonstration of the fabricated chip.</p>
    <p>We further acknowledge the EE6350 VLSI Design Lab 2024 RISC-V Processor Team, whose previous work served as an important reference as we built our own system. We extend our appreciation to James Tian, whose timely assistance and practical advice helped us overcome difficulties throughout the project. We are also thankful for the collaboration and discussions with students from other fellow groups, the shared problem-solving environment in the lab greatly enriched our learning experience and contributed to the overall success of the project.</p>
    <p>Finally, we would like to extend our sincere appreciation to Apple Inc. for sponsoring this tape-out project. We are especially grateful to the Apple engineers whose guidance, technical insights, and continuous support played an essential role in helping us improve our design and better understand real-world ASIC development practices. Their contributions greatly enriched our learning experience and enabled us to complete this project successfully from design through silicon validation.</p>
    
    <h3>Team Members</h3>
    <div class="team-grid">
      <div class="team-member">
      <strong>
      <a href="https://www.linkedin.com/in/m-lippe" target="_blank">Michael Lippe</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>ml5201@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a href="https://www.linkedin.com/in/qianxufu/" target="_blank">Qianxu Fu</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>qf2181@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a href="https://www.linkedin.com/in/bhargav-sriram-4ba537203/" target="_blank">Bhargav Sriram</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>bs3586@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a>Hongrui Huang</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>hh3084@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a>Hiroki Endo</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>he2305@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a>Yuan Jiang</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>yj2848@columbia.edu</span>
      </div>

      <div class="team-member">
      <strong>
      <a>Jingyi Lai</a>
      </strong>
      <span>[Role/Contribution]</span>
      <span>jl6932@columbia.edu</span>
      </div>
  </section>
  
  <a class="back" href="../index.html">Back to all projects</a>
</div>

<footer>
  <p>EE6350 VLSI Design Lab · Department of Electrical Engineering · Columbia University</p>
  <p style="margin-top: 8px; font-size: 0.9em; opacity: 0.8;">Spring 2025</p>
</footer>
</body>
</html>
